// Autogenerated translator module for currently-unmapped C source outputs.
// Contents are syntax-validated emitted functions; wiring into runtime is separate.

// Autotranslated from sfstruct.c:105
export function historical_sfo_char(nhfp, d_char, myname, cnt) {
  bwrite(nhfp.fd,  d_char, cnt * sizeof );
}

// Autotranslated from sfstruct.c:112
export async function historical_sfi_char(nhfp, d_char, myname, cnt) {
  await mread(nhfp.fd,  d_char, cnt * sizeof );
  if (restoreinfo.mread_flags === -1) nhfp.eof = true;
}

// Autotranslated from sfstruct.c:135
export async function historical_sfi_genericptr_t(nhfp, d_genericptr_t, myname) {
  if (nhfp.eof) { sfstruct_read_error(); }
  await mread(nhfp.fd,  d_genericptr_t, sizeof *d_genericptr_t);
  if (restoreinfo.mread_flags === -1) nhfp.eof = true;
}

// Autotranslated from sfstruct.c:383
export function getidx(fd, flg) {
  let i, retval = -1;
  for (i = 0; i < MAXFD; ++i) {
    if (bw_sticky[i] === fd) return i;
  }
  if (flg === NOSLOT) return retval;
  for (i = 0; i < MAXFD; ++i) {
    if (bw_sticky[i] < 0) {
      bw_sticky[i] = fd;
      retval = i;
      break;
    }
  }
  return retval;
}

// Autotranslated from sfstruct.c:403
export function close_check(fd) {
  let idx = getidx(fd, NOSLOT), retval = false;
  if (idx >= 0) retval = true;
  return retval;
}

// Autotranslated from sfstruct.c:414
export function bufon(fd) {
  let idx = getidx(fd, NOFLG);
  if (idx >= 0) {
    bw_sticky[idx] = fd;
    if (bw_buffered[idx]) throw new Error('buffering already enabled');
    if (!bw_FILE[idx]) {
      if ((bw_FILE[idx] = fdopen(fd, "w")) === 0) panic("buffering of file %d failed", fd);
    }
    bw_buffered[idx] = (bw_FILE[idx] !== 0);
  }
}

// Autotranslated from sfstruct.c:435
export function bufoff(fd) {
  let idx = getidx(fd, NOFLG);
  if (idx >= 0) { bflush(fd); bw_buffered[idx] = 0; }
}

// Autotranslated from sfstruct.c:446
export function bclose(fd) {
  let idx = getidx(fd, NOSLOT);
  bufoff(fd);
  if (idx >= 0) {
    if (bw_FILE[idx]) { fclose(bw_FILE[idx]); bw_FILE[idx] = 0; }
    else {
      close(fd);
    }
    bw_sticky[idx] = -1;
  }
  return;
}

// Autotranslated from sfstruct.c:477
export function bflush(fd) {
  let idx = getidx(fd, NOFLG);
  if (idx >= 0) {
    if (bw_FILE[idx]) {
      if (fflush(bw_FILE[idx]) === EOF) throw new Error('flush of savefile failed!');
    }
  }
  return;
}

// Autotranslated from sfstruct.c:595
export function sfstruct_read_error() {
}
