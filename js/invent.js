// invent.js -- Inventory management
// cf. invent.c — ddoinv, display_inventory, display_pickinv, compactify, getobj, askchain

import { nhgetch, getlin } from './input.js';
import { create_nhwindow, destroy_nhwindow, NHW_MENU } from './windows.js';
import { COLNO, STATUS_ROW_1, PM_ARCHEOLOGIST, A_STR, A_CON, A_WIS,
         UNENCUMBERED, OVERLOADED } from './config.js';
import { objectData, WEAPON_CLASS, FOOD_CLASS, WAND_CLASS, SPBOOK_CLASS,
         FLINT, ROCK, SLING, MAGIC_MARKER, COIN_CLASS, ARMOR_CLASS,
         RING_CLASS, AMULET_CLASS, TOOL_CLASS, POTION_CLASS, SCROLL_CLASS,
         GEM_CLASS, ROCK_CLASS, BALL_CLASS, CHAIN_CLASS, VENOM_CLASS,
         ILLOBJ_CLASS,
         AMULET_OF_YENDOR, CANDELABRUM_OF_INVOCATION, BELL_OF_OPENING,
         SPE_BOOK_OF_THE_DEAD, LOADSTONE, FIGURINE, SCR_SCARE_MONSTER,
         CORPSE, EGG, TIN, POT_OIL, SPE_NOVEL, LEASH, STATUE, SCR_BLANK_PAPER,
         GLASS, GEMSTONE, MINERAL,
         ARM_SUIT, ARM_SHIELD, ARM_HELM, ARM_GLOVES, ARM_BOOTS, ARM_CLOAK, ARM_SHIRT,
         CLASS_SYMBOLS } from './objects.js';
import { doname, xname, weight, splitobj, Is_container, erosion_matters } from './mkobj.js';
import { promptDirectionAndThrowItem, ammoAndLauncher } from './dothrow.js';
import { pline, You, Your } from './pline.js';
import { rn2 } from './rng.js';
import { touch_petrifies } from './mondata.js';
import { newsym } from './monutil.js';
import { observeObject, discoverObject, isObjectNameKnown } from './discovery.js';
import { exercise } from './attrib_exercise.js';


// ============================================================
// Sort / classify helpers
// cf. invent.c — reorder_invent, sortloot, etc.
// ============================================================

// C ref: invent.c invletter_value() — sort order for inventory letters
function invletSortValue(ch) {
    if (ch === '$') return 0;
    if (ch >= 'a' && ch <= 'z') return ch.charCodeAt(0);
    if (ch >= 'A' && ch <= 'Z') return ch.charCodeAt(0) + 100;
    if (ch === '#') return 1000;
    return 2000 + ch.charCodeAt(0);
}

// C ref: invent.c compactify() — compress inventory letter list for prompts
export function compactInvletPromptChars(chars) {
    if (!chars) return '';
    const sorted = [...new Set(chars.split(''))].sort((a, b) => invletSortValue(a) - invletSortValue(b));
    if (sorted.length <= 5) return sorted.join('');
    const out = [];
    let i = 0;
    while (i < sorted.length) {
        const start = sorted[i];
        let j = i;
        while (j + 1 < sorted.length && sorted[j + 1].charCodeAt(0) === sorted[j].charCodeAt(0) + 1) {
            j++;
        }
        const runLen = j - i + 1;
        if (runLen >= 3) {
            out.push(start, '-', sorted[j]);
        } else {
            for (let k = i; k <= j; k++) out.push(sorted[k]);
        }
        i = j + 1;
    }
    return out.join('');
}

// C ref: invent.c currency() — pluralize gold currency name
export function currency(amount) {
    return amount === 1 ? 'zorkmid' : 'zorkmids';
}

// C ref: invent.c display_inventory() / display_pickinv()
export function buildInventoryOverlayLines(player) {
    const CLASS_NAMES = {
        1: 'Weapons', 2: 'Armor', 3: 'Rings', 4: 'Amulets',
        5: 'Tools', 6: 'Comestibles', 7: 'Potions', 8: 'Scrolls',
        9: 'Spellbooks', 10: 'Wands', 11: 'Coins', 12: 'Gems/Stones',
    };
    const INV_ORDER = [11, 4, 1, 2, 6, 8, 9, 7, 3, 10, 5, 12, 13, 14, 15];

    const groups = {};
    for (const item of player.inventory || []) {
        const cls = item?.oclass;
        if (!cls) continue;
        if (!groups[cls]) groups[cls] = [];
        groups[cls].push(item);
    }

    const lines = [];
    for (const cls of INV_ORDER) {
        if (cls === 11 && !groups[cls] && (player.gold || 0) > 0) {
            const gold = player.gold || 0;
            const goldLabel = gold === 1 ? 'gold piece' : 'gold pieces';
            lines.push('Coins');
            lines.push(`$ - ${gold} ${goldLabel}`);
            continue;
        }
        if (!groups[cls]) continue;
        lines.push(CLASS_NAMES[cls] || 'Other');
        for (const item of groups[cls]) {
            const named = doname(item, player);
            const invName = (item.oclass === WEAPON_CLASS)
                ? named.replace('(wielded)', '(weapon in right hand)')
                : named;
            lines.push(`${item.invlet} - ${invName}`);
        }
    }
    lines.push('(end)');
    return lines;
}

function buildInventoryPages(lines, rows = STATUS_ROW_1) {
    // C tty parity: if everything fits in the available menu rows,
    // keep a single page ending with "(end)".
    if (lines.length <= rows) {
        return [lines.slice()];
    }
    const contentRows = Math.max(1, rows - 1); // reserve one row for "--More--"
    const pages = [];
    for (let i = 0; i < lines.length; i += contentRows) {
        const chunk = lines.slice(i, i + contentRows);
        const hasMore = i + contentRows < lines.length;
        pages.push(hasMore ? [...chunk, '--More--'] : chunk);
    }
    return pages.length > 0 ? pages : [['--More--']];
}

function clearInventoryOverlayArea(display, lines = []) {
    if (!display || !Number.isInteger(display.rows) || !Number.isInteger(display.cols)) return;
    if (!Number.isInteger(STATUS_ROW_1)) return;
    let maxcol = 0;
    for (const line of lines) {
        const len = String(line || '').length;
        if (len > maxcol) maxcol = len;
    }
    const menuOffx = Math.max(10, Math.min(display.cols, display.cols - maxcol - 2));
    const menuRows = Math.min(STATUS_ROW_1, display.rows);
    if (typeof display.setCell === 'function') {
        for (let r = 0; r < menuRows; r++) {
            for (let col = Math.max(0, menuOffx - 1); col < display.cols; col++) {
                display.setCell(col, r, ' ', 7, 0);
            }
        }
        return;
    }
    if (typeof display.clearRow === 'function') {
        for (let r = 0; r < menuRows; r++) {
            display.clearRow(r);
        }
    }
}

function drawInventoryPage(display, lines) {
    clearInventoryOverlayArea(display, lines);
    if (typeof display.renderOverlayMenu === 'function') {
        display.renderOverlayMenu(lines);
    } else {
        display.renderChargenMenu(lines, false);
    }
}

function isMenuDismissKey(ch) {
    return ch === 32 || ch === 27 || ch === 10 || ch === 13;
}

export async function renderOverlayMenuUntilDismiss(display, lines, allowedSelectionChars = '') {
    const allowedSelections = new Set((allowedSelectionChars || '').split(''));
    let menuOffx = null;
    if (typeof display.renderOverlayMenu === 'function') {
        menuOffx = display.renderOverlayMenu(lines);
    } else {
        menuOffx = display.renderChargenMenu(lines, false);
    }

    let selection = null;
    while (true) {
        const ch = await nhgetch();
        if (isMenuDismissKey(ch)) break;
        const c = String.fromCharCode(ch);
        if (allowedSelections.has(c)) {
            selection = c;
            break;
        }
    }

    const menuRows = Math.min(lines.length, STATUS_ROW_1);
    if (typeof display.setCell === 'function'
        && Number.isInteger(display.cols)
        && Number.isInteger(menuOffx)) {
        for (let r = 0; r < menuRows; r++) {
            for (let col = menuOffx; col < display.cols; col++) {
                display.setCell(col, r, ' ', 7, 0);
            }
        }
    } else if (typeof display.clearRow === 'function') {
        for (let r = 0; r < menuRows; r++) {
            display.clearRow(r);
        }
    }

    return selection;
}

// Handle inventory display
// C ref: invent.c ddoinv()
export async function handleInventory(player, display, game) {
    if (player.inventory.length === 0 && (player.gold || 0) <= 0) {
        display.putstr_message('Not carrying anything.');
        return { moved: false, tookTime: false };
    }

    const win = create_nhwindow(NHW_MENU);
    try {
    const lines = buildInventoryOverlayLines(player);
    const pages = buildInventoryPages(lines, STATUS_ROW_1);
    let pageIndex = 0;

    drawInventoryPage(display, pages[pageIndex] || []);
    const invByLetter = new Map();
    for (const item of player.inventory || []) {
        if (item?.invlet) invByLetter.set(String(item.invlet), item);
    }
    const clearTopline = () => {
        if (typeof display.clearRow === 'function') display.clearRow(0);
        if (display && Object.hasOwn(display, 'topMessage')) display.topMessage = null;
        if (display && Object.hasOwn(display, 'messageNeedsMore')) display.messageNeedsMore = false;
    };
    // C tty/menu parity: inventory stays up until an explicit dismissal key.
    // Non-dismiss keys can be consumed without closing the menu frame.
    while (true) {
        const ch = await nhgetch();
        // C tty parity: space advances pages when present; otherwise it
        // dismisses the inventory only at the end of the final page.
        if (ch === 32) {
            if (pageIndex + 1 < pages.length) {
                pageIndex++;
                drawInventoryPage(display, pages[pageIndex] || []);
                continue;
            }
            break;
        }
        if (ch === 62) { // '>'
            if (pageIndex + 1 < pages.length) {
                pageIndex++;
                drawInventoryPage(display, pages[pageIndex] || []);
            }
            continue;
        }
        if (ch === 98 && pageIndex > 0) { // b
            pageIndex--;
            drawInventoryPage(display, pages[pageIndex] || []);
            continue;
        }
        if (ch === 60 && pageIndex > 0) { // '<'
            pageIndex--;
            drawInventoryPage(display, pages[pageIndex] || []);
            continue;
        }
        if (ch === 94 && pageIndex > 0) { // '^'
            pageIndex = 0;
            drawInventoryPage(display, pages[pageIndex] || []);
            continue;
        }
        if (ch === 124 && pageIndex + 1 < pages.length) { // '|'
            pageIndex = pages.length - 1;
            drawInventoryPage(display, pages[pageIndex] || []);
            continue;
        }
        if (ch === 27 || ch === 10 || ch === 13) break;
        const c = String.fromCharCode(ch);
        if (c === ':') {
            // C tty menu parity: ':' enters in-menu incremental search.
            // We keep menu rows in place and update only topline prompt text.
            await getlin('Search for: ', display);
            continue;
        }
        const selected = invByLetter.get(c);
        if (selected) {
            const baseName = xname({ ...selected, quan: 1 });
            const noun = xname(selected);
            const lowerBaseName = baseName.toLowerCase();
            const isLightSource = (
                lowerBaseName === 'oil lamp'
                || lowerBaseName === 'brass lantern'
                || lowerBaseName === 'magic lamp'
                || lowerBaseName === 'wax candle'
                || lowerBaseName === 'tallow candle'
            );
            const isRubbableLamp = (lowerBaseName === 'oil lamp' || lowerBaseName === 'magic lamp');
            const isWornArmor = (
                selected === player.armor
                || selected === player.shield
                || selected === player.helmet
                || selected === player.gloves
                || selected === player.boots
                || selected === player.cloak
            );
            const stackCanShoot = ammoAndLauncher(selected, player.weapon);
            let menuOffx = 34;
            const displayCols = Number.isInteger(display.cols) ? display.cols : COLNO;
            if (typeof display.setCell === 'function'
                && Number.isInteger(displayCols)
                && Number.isInteger(display.rows)) {
                let maxcol = 0;
                for (const line of lines) {
                    if (line.length > maxcol) maxcol = line.length;
                }
                menuOffx = Math.max(10, displayCols - maxcol - 2);
            }
            const rawActions = ((selected.quan || 1) > 1)
                ? (() => {
                    const stackUsesThrowMenu = (selected.oclass === WEAPON_CLASS
                        || selected.otyp === FLINT
                        || selected.otyp === ROCK);
                    if (stackUsesThrowMenu) {
                        const actions = [];
                        if (selected === player.quiver) {
                            actions.push("- - Quiver '-' to un-ready these items");
                        }
                        actions.push(`c - Name this stack of ${noun}`);
                        actions.push('d - Drop this stack');
                        actions.push('E - Write on the ground with one of these items');
                        actions.push(stackCanShoot
                            ? `f - Shoot one of these with your wielded ${xname({ ...player.weapon, quan: 1 })}`
                            : 'f - Throw one of these');
                        actions.push('i - Adjust inventory by assigning new letter');
                        actions.push('I - Adjust inventory by splitting this stack');
                        if (selected.otyp === FLINT || selected.otyp === ROCK) {
                            actions.push('R - Rub something on this stone');
                        }
                        actions.push(stackCanShoot
                            ? "t - Shoot one of these (same as 'f')"
                            : "t - Throw one of these (same as 'f')");
                        actions.push('w - Wield this stack in your hands');
                        actions.push('/ - Look up information about these');
                        actions.push('(end)');
                        return actions;
                    }
                    const actions = [
                        `c - Name this stack of ${noun}`,
                        'd - Drop this stack',
                        'i - Adjust inventory by assigning new letter',
                        'I - Adjust inventory by splitting this stack',
                        't - Throw one of these',
                        'w - Wield this stack in your hands',
                        '/ - Look up information about these',
                        '(end)',
                    ];
                    if (selected.oclass === FOOD_CLASS) {
                        actions.splice(2, 0, 'e - Eat one of these');
                    }
                    return actions;
                })()
                : (selected.oclass === SPBOOK_CLASS
                    ? [
                        `c - Name this specific ${noun}`,
                        'd - Drop this item',
                        'i - Adjust inventory by assigning new letter',
                        'r - Study this spellbook',
                        't - Throw this item',
                        'w - Wield this item in your hands',
                        '/ - Look up information about this',
                        '(end)',
                    ]
                : ((selected === player.weapon && selected.oclass === WEAPON_CLASS)
                    ? [
                        "- - Wield '-' to un-wield this weapon",
                        `c - Name this specific ${noun}`,
                        'd - Drop this item',
                        'E - Engrave on the floor with this item',
                        'i - Adjust inventory by assigning new letter',
                        "Q - Quiver this item for easy throwing with 'f'ire",
                        't - Throw this item',
                        'x - Ready this as an alternate weapon',
                        '/ - Look up information about this',
                        '(end)',
                    ]
                    : (isWornArmor
                        ? [
                            `c - Name this specific ${noun}`,
                            'i - Adjust inventory by assigning new letter',
                            'T - Take off this armor',
                            '/ - Look up information about this',
                            '(end)',
                        ]
                        : (selected.oclass === WAND_CLASS
                        ? [
                            'a - Break this wand',
                            `c - Name this specific ${noun}`,
                            'd - Drop this item',
                            'E - Engrave on the floor with this item',
                            'i - Adjust inventory by assigning new letter',
                            't - Throw this item',
                            'w - Wield this item in your hands',
                            'z - Zap this wand to release its magic',
                            '/ - Look up information about this',
                            '(end)',
                        ]
                    : [
                        ...(selected.otyp === MAGIC_MARKER
                            ? ['a - Write on something with this marker']
                            : isLightSource
                            ? [selected.lamplit
                                ? 'a - Snuff out this light source'
                                : 'a - Light this light source']
                            : baseName.toLowerCase() === 'stethoscope'
                            ? ['a - Listen through the stethoscope']
                            : []),
                        `c - Name this specific ${noun}`,
                        'd - Drop this item',
                        ...(selected.otyp === MAGIC_MARKER
                            ? ['E - Scribble graffiti on the floor']
                            : []),
                        'i - Adjust inventory by assigning new letter',
                        ...(isRubbableLamp ? [`R - Rub this ${noun}`] : []),
                        't - Throw this item',
                        'w - Wield this item in your hands',
                        '/ - Look up information about this',
                        '(end)',
                    ]))));

            const promptText = `Do what with the ${noun}?`;
            const maxAction = rawActions.reduce((m, line) => Math.max(m, line.length), promptText.length);
            menuOffx = Math.max(10, displayCols - maxAction - 2);
            const pad = ' '.repeat(menuOffx);
            const stackActions = rawActions.map((line) => `${pad}${line}`);
            const actionPrompt = `${pad}${promptText}`;
            if (game && typeof game.renderCurrentScreen === 'function') {
                game.renderCurrentScreen();
            }
            if (typeof display.setCell === 'function'
                && Number.isInteger(display.cols)
                && Number.isInteger(display.rows)) {
                // Clear only the rows we will repaint for this submenu so
                // underlying map glyphs below remain visible, matching tty flow.
                const maxActionRow = Math.min(STATUS_ROW_1 - 1, stackActions.length + 1);
                for (let r = 0; r <= maxActionRow; r++) {
                    for (let col = menuOffx; col < display.cols; col++) {
                        display.setCell(col, r, ' ', 7, 0);
                    }
                }
            }
            if (typeof display.putstr === 'function' && typeof display.clearRow === 'function') {
                display.clearRow(0);
                display.putstr(0, 0, pad, 7, 0);
                display.putstr(menuOffx, 0, promptText, 7, 1);
                if (display && Object.hasOwn(display, 'topMessage')) display.topMessage = actionPrompt;
                if (display && Object.hasOwn(display, 'messageNeedsMore')) display.messageNeedsMore = false;
            } else {
                display.putstr_message(actionPrompt);
            }
            if (typeof display.putstr === 'function') {
                for (let i = 0; i < stackActions.length; i++) {
                    if (typeof display.clearRow === 'function') display.clearRow(i + 2);
                    display.putstr(0, i + 2, stackActions[i]);
                }
            }
            const actionKeys = new Set(rawActions.map((line) => String(line || '').charAt(0)));
            while (true) {
                const actionCh = await nhgetch();
                if (actionCh === 32 || actionCh === 27 || actionCh === 10 || actionCh === 13) {
                    if (typeof display.clearRow === 'function') {
                        for (let i = 0; i < stackActions.length; i++) {
                            display.clearRow(i + 2);
                        }
                    }
                    clearTopline();
                    return { moved: false, tookTime: false };
                }
                const actionKey = String.fromCharCode(actionCh);
                if (!actionKeys.has(actionKey)) continue;
                if (typeof display.clearRow === 'function') {
                    for (let i = 0; i < stackActions.length; i++) {
                        display.clearRow(i + 2);
                    }
                }
                clearTopline();
                if ((actionKey === 'f' || actionKey === 't') && game?.map) {
                    return await promptDirectionAndThrowItem(
                        player,
                        game.map,
                        display,
                        selected,
                        { fromFire: stackCanShoot }
                    );
                }
                if (actionKey === 'i') {
                    // cf. invent.c doorganize() / #adjust — reassign inventory letter
                    if (game && typeof game.renderCurrentScreen === 'function') {
                        game.renderCurrentScreen();
                    }
                    const inv = player.inventory || [];
                    const usedLetters = new Set(inv.map(o => o.invlet));
                    // Build available-letter string for prompt
                    const allLetters = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ';
                    let availStr = '';
                    {
                        let i = 0;
                        while (i < allLetters.length) {
                            const ch = allLetters[i];
                            if (!usedLetters.has(ch) || ch === selected.invlet) {
                                // Find run of consecutive available letters
                                let j = i;
                                while (j + 1 < allLetters.length
                                    && (!usedLetters.has(allLetters[j + 1]) || allLetters[j + 1] === selected.invlet)) {
                                    j++;
                                }
                                if (availStr) availStr += '';
                                if (j - i >= 2) {
                                    availStr += `${allLetters[i]}-${allLetters[j]}`;
                                } else {
                                    for (let k = i; k <= j; k++) availStr += allLetters[k];
                                }
                                i = j + 1;
                            } else {
                                i++;
                            }
                        }
                    }
                    const adjustPrompt = `Adjust letter to what [${availStr}] (? see used letters)?`;
                    display.putstr_message(adjustPrompt);
                    const adjCh = await nhgetch();
                    const adjChar = String.fromCharCode(adjCh);
                    if (adjCh === 27 || adjCh === 10 || adjCh === 13 || adjCh === 32) {
                        clearTopline();
                        display.putstr_message('Never mind.');
                        return { moved: false, tookTime: false };
                    }
                    if (/^[a-zA-Z]$/.test(adjChar)) {
                        // Swap if another item has that letter
                        const other = inv.find(o => o !== selected && o.invlet === adjChar);
                        if (other) {
                            other.invlet = selected.invlet;
                        }
                        selected.invlet = adjChar;
                    }
                    clearTopline();
                    return { moved: false, tookTime: false };
                }
                if (actionKey === 'c') {
                    if (game && typeof game.renderCurrentScreen === 'function') {
                        game.renderCurrentScreen();
                    }
                    const namedInput = await getlin(`What do you want to name this ${baseName}? `, display);
                    if (namedInput !== null) {
                        const nextName = namedInput.trim();
                        selected.oname = nextName;
                    }
                    clearTopline();
                }
                return { moved: false, tookTime: false };
            }
        }
    }
    clearTopline();

    return { moved: false, tookTime: false };
    } finally {
        destroy_nhwindow(win);
    }
}


// ============================================================
// Ported functions from invent.c
// ============================================================
// JS architecture notes:
//   - Player state passed as parameter (not global)
//   - Inventory is player.inventory (array), not linked list
//   - Floor objects in map.objects (array), not level.objects[x][y]
//   - Worn items: player.weapon, player.armor, player.shield, etc.
//   - Constants: invlet_basic = 52 (a-z + A-Z)

const invlet_basic = 52;
const NOINVSYM = '#';
const GOLD_SYM = '$';
const HANDS_SYM = '-';
const CONTAINED_SYM = '>';
const INVENTORY_LETTERS = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ';

// BUC filter constants — cf. pickup.c
export const BUC_BLESSED = 1;
export const BUC_UNCURSED = 2;
export const BUC_CURSED = 3;
export const BUC_UNKNOWN = 4;

// GETOBJ return codes — cf. invent.c
export const GETOBJ_EXCLUDE = 0;
export const GETOBJ_SUGGEST = 1;
export const GETOBJ_DOWNPLAY = 2;
export const GETOBJ_EXCLUDE_INACCESS = 3;
export const GETOBJ_EXCLUDE_SELECTABLE = 4;
export const GETOBJ_EXCLUDE_NONINVENT = 5;

// GETOBJ control flags
export const GETOBJ_ALLOWCNT = 0x01;
export const GETOBJ_PROMPT = 0x02;
export const GETOBJ_NOFLAGS = 0;

// Object class names — cf. invent.c names[]
const CLASS_NAMES = [
    null, 'Illegal objects', 'Weapons', 'Armor', 'Rings', 'Amulets', 'Tools',
    'Comestibles', 'Potions', 'Scrolls', 'Spellbooks', 'Wands', 'Coins',
    'Gems/Stones', 'Boulders/Statues', 'Iron balls', 'Chains', 'Venoms',
];


// ============================================================
// 1. Sort / classify
// ============================================================

// C ref: invent.c inuse_classify() — classify object as worn/wielded for loot sorting
export function inuse_classify(sort_item, obj, player) {
    let rating = 0;
    let altclass = 0;
    const w_mask = obj.owornmask || 0;

    function USE_RATING(test) {
        ++rating;
        if (test) return true;
        return false;
    }

    // Miscellaneous
    ++altclass; // 1
    if (USE_RATING(!w_mask && obj.otyp === LEASH && obj.leashmon)) { assign(); return; }
    if (USE_RATING(!w_mask && obj.oclass === TOOL_CLASS && obj.lamplit)) { assign(); return; }
    // Armor
    ++altclass; // 2
    if (USE_RATING(obj === player?.shirt)) { assign(); return; }
    if (USE_RATING(obj === player?.boots)) { assign(); return; }
    if (USE_RATING(obj === player?.gloves)) { assign(); return; }
    if (USE_RATING(obj === player?.helmet)) { assign(); return; }
    if (USE_RATING(obj === player?.shield)) { assign(); return; }
    if (USE_RATING(obj === player?.cloak)) { assign(); return; }
    if (USE_RATING(obj === player?.armor)) { assign(); return; }
    // Weapons
    ++altclass; // 3
    if (USE_RATING(obj === player?.quiver)) { assign(); return; }
    if (USE_RATING(obj === player?.swapWeapon)) { assign(); return; }
    if (USE_RATING(obj === player?.weapon)) { assign(); return; }
    // Accessories
    ++altclass; // 4
    if (USE_RATING(obj === player?.blindfold)) { assign(); return; }
    if (USE_RATING(obj === player?.leftRing)) { assign(); return; }
    if (USE_RATING(obj === player?.rightRing)) { assign(); return; }
    if (USE_RATING(obj === player?.amulet)) { assign(); return; }

    rating = 0;
    altclass = -1;

    function assign() {
        sort_item.inuse = rating;
        sort_item.orderclass = altclass;
        sort_item.subclass = 0;
        sort_item.disco = 0;
    }
    assign();
}

// C ref: invent.c loot_classify() — classify object for loot menu grouping
export function loot_classify(sort_item, obj) {
    const def_srt_order = [
        COIN_CLASS, AMULET_CLASS, RING_CLASS, WAND_CLASS, POTION_CLASS,
        SCROLL_CLASS, SPBOOK_CLASS, GEM_CLASS, FOOD_CLASS, TOOL_CLASS,
        WEAPON_CLASS, ARMOR_CLASS, ROCK_CLASS, BALL_CLASS, CHAIN_CLASS,
    ];
    const otyp = obj.otyp;
    const oclass = obj.oclass;
    const od = objectData[otyp] || {};
    const seen = !!obj.dknown;
    const discovered = !!od.name_known;

    // class order
    const idx = def_srt_order.indexOf(oclass);
    sort_item.orderclass = idx >= 0 ? idx + 1 : def_srt_order.length + 1 + (oclass !== VENOM_CLASS ? 1 : 0);

    // subclass
    let k;
    switch (oclass) {
    case ARMOR_CLASS: {
        const armcatMap = [7, 4, 1, 2, 3, 5, 6]; // ARM_SUIT..ARM_SHIRT -> sort order
        const ac = od.sub ?? 0;
        k = (ac >= 0 && ac < 7) ? (armcatMap[ac] || 8) : 8;
        break;
    }
    case WEAPON_CLASS: {
        const skill = od.skill || 0;
        k = (skill < 0) ? 3 : 5;
        break;
    }
    case TOOL_CLASS:
        if (Is_container(obj)) k = 1;
        else k = 4;
        break;
    case FOOD_CLASS:
        if (otyp === CORPSE) k = 5;
        else if (otyp === EGG) k = 4;
        else if (otyp === TIN) k = 3;
        else k = 2;
        break;
    case GEM_CLASS: {
        const mat = od.material;
        if (mat === GEMSTONE) k = !seen ? 1 : !discovered ? 2 : 3;
        else if (mat === GLASS) k = !seen ? 1 : !discovered ? 2 : 4;
        else k = !seen ? 5 : 8;
        break;
    }
    default:
        k = 1;
        break;
    }
    sort_item.subclass = k;

    // discovery status
    k = !seen ? 1
        : (discovered || !od.desc) ? 4
        : (od.uname) ? 3
        : 2;
    sort_item.disco = k;
    sort_item.inuse = 0;
}

// C ref: invent.c sortloot() — sort a list of objects for display
// In JS, takes an array of objects and returns a sorted array of
// {obj, indx, orderclass, subclass, disco, inuse, str} items.
export function sortloot(objList, mode, filterfunc) {
    const SORTLOOT_PACK = 0x01;
    const SORTLOOT_INVLET = 0x02;
    const SORTLOOT_LOOT = 0x04;
    const SORTLOOT_INUSE = 0x08;

    const items = [];
    let i = 0;
    for (const o of objList) {
        if (filterfunc && !filterfunc(o)) continue;
        items.push({ obj: o, indx: i++, orderclass: 0, subclass: 0, disco: 0, inuse: 0, str: null });
    }

    if (mode && items.length > 1) {
        items.sort((a, b) => {
            // in-use takes precedence
            if (mode & SORTLOOT_INUSE) {
                if (!a.orderclass) inuse_classify(a, a.obj);
                if (!b.orderclass) inuse_classify(b, b.obj);
                if (a.inuse !== b.inuse) return b.inuse - a.inuse;
                return a.indx - b.indx;
            }
            // class order
            if ((mode & (SORTLOOT_PACK | SORTLOOT_INVLET)) !== SORTLOOT_INVLET) {
                if (!a.orderclass) loot_classify(a, a.obj);
                if (!b.orderclass) loot_classify(b, b.obj);
                if (a.orderclass !== b.orderclass) return a.orderclass - b.orderclass;
                if (!(mode & SORTLOOT_INVLET)) {
                    if (a.subclass !== b.subclass) return a.subclass - b.subclass;
                    if (a.disco !== b.disco) return a.disco - b.disco;
                }
            }
            // invlet order
            if (mode & SORTLOOT_INVLET) {
                const va = invletSortValue(a.obj.invlet || '?');
                const vb = invletSortValue(b.obj.invlet || '?');
                if (va !== vb) return va - vb;
            }
            // tiebreak
            return a.indx - b.indx;
        });
    }
    return items;
}

// C ref: invent.c unsortloot() — no-op in JS (GC handles it)
export function unsortloot() {}

// C ref: invent.c reorder_invent() — sort inventory by invlet
// JS adaptation: sort the player.inventory array in-place
export function reorder_invent(player) {
    if (!player || !player.inventory) return;
    player.inventory.sort((a, b) => {
        const ra = inv_rank_value(a);
        const rb = inv_rank_value(b);
        return ra - rb;
    });
}

// Helper for reorder_invent: toggling bit puts lowercase before uppercase
function inv_rank_value(obj) {
    const c = (obj.invlet || '?').charCodeAt(0);
    return c ^ 0x20;
}


// ============================================================
// 2. Inventory add / remove
// ============================================================

// C ref: invent.c assigninvlet() — assign an inventory letter to an object
export function assigninvlet(obj, player) {
    if (obj.oclass === COIN_CLASS) {
        obj.invlet = GOLD_SYM;
        return;
    }

    const inuse = new Array(invlet_basic).fill(false);
    for (const o of player.inventory) {
        if (o === obj) continue;
        const ch = o.invlet;
        if (ch >= 'a' && ch <= 'z') inuse[ch.charCodeAt(0) - 97] = true;
        else if (ch >= 'A' && ch <= 'Z') inuse[ch.charCodeAt(0) - 65 + 26] = true;
        if (ch === obj.invlet) obj.invlet = null;
    }

    // If existing invlet is still valid, keep it
    const ic = obj.invlet;
    if (ic && ((ic >= 'a' && ic <= 'z') || (ic >= 'A' && ic <= 'Z'))) return;

    const lastinvnr = player.lastInvlet ?? (invlet_basic - 1);
    let i = lastinvnr + 1;
    const start = i;
    do {
        if (i === invlet_basic) { i = 0; continue; }
        if (!inuse[i]) break;
        i++;
    } while (i !== start);

    if (inuse[i]) {
        obj.invlet = NOINVSYM;
    } else {
        obj.invlet = i < 26 ? String.fromCharCode(97 + i) : String.fromCharCode(65 + i - 26);
    }
    player.lastInvlet = i;
}

// C ref: invent.c merge_choice() — find an object in objList that can merge with obj
export function merge_choice(objList, obj) {
    if (!objList || !objList.length) return null;
    if (obj.otyp === SCR_SCARE_MONSTER) return null;
    for (const o of objList) {
        if (mergable(o, obj)) return o;
    }
    return null;
}

// C ref: invent.c merged() — merge obj into otmp if compatible; returns true if merged
export function merged(otmp, obj) {
    if (!mergable(otmp, obj)) return false;

    // Approximate age
    if (!obj.lamplit && !obj.globby) {
        otmp.age = Math.floor(
            ((otmp.age || 0) * (otmp.quan || 1) + (obj.age || 0) * (obj.quan || 1))
            / ((otmp.quan || 1) + (obj.quan || 1))
        );
    }

    if (!obj.globby) {
        otmp.quan = (otmp.quan || 1) + (obj.quan || 1);
    }

    // Recompute weight
    if (otmp.oclass === COIN_CLASS) {
        otmp.owt = weight(otmp);
        otmp.bknown = false;
    } else if (!obj.globby) { // not Is_pudding check simplified
        otmp.owt = weight(otmp);
    }

    // Copy name if otmp lacks one
    if (!otmp.oname && obj.oname) {
        otmp.oname = obj.oname;
    }

    // Identification by comparison
    if (obj.known !== otmp.known) otmp.known = true;
    if (obj.rknown !== otmp.rknown) otmp.rknown = true;
    if (obj.bknown !== otmp.bknown) otmp.bknown = true;

    // Handle worn mask merging (for wielded stacks)
    if (obj.owornmask) {
        const wmask = (otmp.owornmask || 0) | (obj.owornmask || 0);
        // simplified: just keep otmp's mask
        otmp.owornmask = otmp.owornmask || obj.owornmask;
    }

    if (obj.bypass) otmp.bypass = true;

    return true;
}

// C ref: invent.c addinv_core1() — side effects before adding to inventory
export function addinv_core1(obj, player) {
    if (obj.oclass === COIN_CLASS) {
        // botl update — handled elsewhere in JS
    } else if (obj.otyp === AMULET_OF_YENDOR) {
        if (!player.uhave) player.uhave = {};
        player.uhave.amulet = true;
    } else if (obj.otyp === CANDELABRUM_OF_INVOCATION) {
        if (!player.uhave) player.uhave = {};
        player.uhave.menorah = true;
    } else if (obj.otyp === BELL_OF_OPENING) {
        if (!player.uhave) player.uhave = {};
        player.uhave.bell = true;
    } else if (obj.otyp === SPE_BOOK_OF_THE_DEAD) {
        if (!player.uhave) player.uhave = {};
        player.uhave.book = true;
    }
}

// C ref: invent.c addinv_core2() — side effects after adding to inventory
export function addinv_core2(obj, player) {
    // confers_luck check would go here
    // C ref: invent.c addinv_core2() — archeologists can decipher scroll labels.
    if (player
        && player.roleIndex === PM_ARCHEOLOGIST
        && obj?.oclass === SCROLL_CLASS
        && obj?.otyp !== SCR_BLANK_PAPER
        && !player.blind
        && !isObjectNameKnown(obj.otyp)) {
        observeObject(obj);
        discoverObject(obj.otyp, true, true);
        exercise(player, A_WIS, true);
        if (!player.uconduct) player.uconduct = {};
        player.uconduct.literate = (player.uconduct.literate || 0) + 1;
    }
}

// C ref: invent.c carry_obj_effects() — side effects of carrying an object
export function carry_obj_effects(obj) {
    // Cursed figurines can spontaneously transform — not yet implemented in JS
}

// C ref: invent.c addinv() — add object to hero inventory
// This is now a standalone function wrapping player.addToInventory
export function addinv(obj, player) {
    if (!obj || !player) return obj;
    addinv_core1(obj, player);
    const result = player.addToInventory(obj) || obj;
    addinv_core2(result, player);
    carry_obj_effects(result);
    return result;
}

// C ref: invent.c addinv_nomerge() — add without merging
export function addinv_nomerge(obj, player) {
    const save = obj.nomerge;
    obj.nomerge = true;
    const result = addinv(obj, player);
    obj.nomerge = save;
    return result;
}

const WT_WEIGHTCAP_STRCON = 25;
const WT_WEIGHTCAP_SPARE = 50;
const MAX_CARR_CAP = 1000;
const WT_WOUNDEDLEG_REDUCT = 100;

function weight_cap_for_inventory(player) {
    const str = player?.attributes ? player.attributes[A_STR] : 10;
    const con = player?.attributes ? player.attributes[A_CON] : 10;
    let carrcap = WT_WEIGHTCAP_STRCON * (str + con) + WT_WEIGHTCAP_SPARE;
    if (player?.levitating || player?.flying) {
        carrcap = MAX_CARR_CAP;
    } else {
        if (carrcap > MAX_CARR_CAP) carrcap = MAX_CARR_CAP;
        if (!player?.flying) {
            if (player?.woundedLegLeft) carrcap -= WT_WOUNDEDLEG_REDUCT;
            if (player?.woundedLegRight) carrcap -= WT_WOUNDEDLEG_REDUCT;
        }
    }
    return Math.max(carrcap, 1);
}

function near_capacity_for_inventory(player) {
    let wt = 0;
    for (const obj of (player?.inventory || [])) {
        if (!obj) continue;
        if (obj.oclass === COIN_CLASS) wt += Math.floor(((obj.quan || 0) + 50) / 100);
        else wt += obj.owt || weight(obj) || 0;
    }
    const wc = weight_cap_for_inventory(player);
    const over = wt - wc;
    if (over <= 0) return UNENCUMBERED;
    const cap = Math.floor((over * 2) / wc) + 1;
    return Math.min(cap, OVERLOADED);
}

function encumber_msg_transition(prevCap, newCap) {
    if (prevCap < newCap) {
        switch (newCap) {
        case 1:
            Your('movements are slowed slightly because of your load.');
            break;
        case 2:
            You('rebalance your load.  Movement is difficult.');
            break;
        case 3:
            You('stagger under your heavy load.  Movement is very hard.');
            break;
        default:
            You('%s move a handspan with this load!', newCap === 4 ? 'can barely' : "can't even");
            break;
        }
    } else if (prevCap > newCap) {
        switch (newCap) {
        case 0:
            Your('movements are now unencumbered.');
            break;
        case 1:
            Your('movements are only slowed slightly by your load.');
            break;
        case 2:
            You('rebalance your load.  Movement is still difficult.');
            break;
        case 3:
            You('stagger under your load.  Movement is still very hard.');
            break;
        default:
            break;
        }
    }
}

// C ref: invent.c hold_another_object() — add object or drop if can't hold
export function hold_another_object(obj, player, drop_fmt, drop_arg, hold_msg) {
    const prevCap = near_capacity_for_inventory(player);
    const oquan = obj?.quan || 0;
    const result = addinv(obj, player);
    if (result && (hold_msg || drop_fmt)) {
        prinv(hold_msg || null, result, oquan, player);
    }
    const newCap = near_capacity_for_inventory(player);
    if (player) player.encumbrance = newCap;
    encumber_msg_transition(prevCap, newCap);
    return result;
}


// ============================================================
// 3. Object consumption
// ============================================================

// C ref: invent.c useupall() — consume entire stack of an object
export function useupall(obj, player) {
    setnotworn_safe(obj, player);
    freeinv(obj, player);
}

// C ref: invent.c useup() — consume one item from a stack
// TRANSLATOR: AUTO (invent.c:1320)
export function useup(obj) {
  if (obj.quan > 1) {
    obj.in_use = false;
    obj.quan--;
    obj.owt = weight(obj);
    update_inventory();
  }
  else { useupall(obj); }
}

// C ref: invent.c consume_obj_charge() — consume a charge from a wand/tool
export function consume_obj_charge(obj, maybe_unpaid, player) {
    // maybe_unpaid shop billing not yet implemented
    obj.spe = (obj.spe || 0) - 1;
    if (obj.known) update_inventory(player);
}

// C ref: invent.c useupf() — consume one item from floor stack
export function useupf(obj, numused, map) {
    if ((obj.quan || 1) > numused) {
        obj.quan -= numused;
        obj.owt = weight(obj);
    } else {
        delobj(obj, map);
    }
}


// ============================================================
// 4. Free / delete
// ============================================================

// C ref: invent.c freeinv_core() — intrinsics adjustment when removing from inventory
export function freeinv_core(obj, player) {
    if (obj.oclass === COIN_CLASS) return;
    if (!player.uhave) player.uhave = {};
    if (obj.otyp === AMULET_OF_YENDOR) player.uhave.amulet = false;
    else if (obj.otyp === CANDELABRUM_OF_INVOCATION) player.uhave.menorah = false;
    else if (obj.otyp === BELL_OF_OPENING) player.uhave.bell = false;
    else if (obj.otyp === SPE_BOOK_OF_THE_DEAD) player.uhave.book = false;

    if (obj.otyp === LOADSTONE) {
        obj.cursed = true;
        obj.blessed = false;
    }
}

// C ref: invent.c freeinv() — remove object from hero inventory chain
export function freeinv(obj, player) {
    player.removeFromInventory(obj);
    obj.pickup_prev = 0;
    freeinv_core(obj, player);
}

// C ref: invent.c delallobj() — delete all objects at a location
export function delallobj(x, y, map) {
    if (!map || !map.objects) return;
    const toDelete = map.objects.filter(o => o.ox === x && o.oy === y && !o.buried);
    for (const obj of toDelete) {
        delobj(obj, map);
    }
}

// C ref: invent.c delobj() — delete a single object
// TRANSLATOR: AUTO (invent.c:1429)
export function delobj(obj) {
  delobj_core(obj, false);
}

// C ref: invent.c delobj_core() — core object deletion
export function delobj_core(obj, map, force) {
    if (!force && obj_resists(obj)) {
        obj.in_use = false;
        return;
    }
    const wasOnFloor = map && map.objects;
    if (wasOnFloor) {
        const idx = map.objects.indexOf(obj);
        if (idx >= 0) {
            map.objects.splice(idx, 1);
            if (typeof newsym === 'function') {
                newsym(map, obj.ox, obj.oy);
            }
        }
    }
}

// Helper: obj_resists — simplified check for indestructible objects
function obj_resists(obj) {
    if (obj.otyp === AMULET_OF_YENDOR) return true;
    if (obj.otyp === CANDELABRUM_OF_INVOCATION) return true;
    if (obj.otyp === BELL_OF_OPENING) return true;
    if (obj.otyp === SPE_BOOK_OF_THE_DEAD) return true;
    return false;
}


// ============================================================
// 5. Object queries
// ============================================================

// C ref: invent.c sobj_at() — find specific object type at location
export function sobj_at(otyp, x, y, map) {
    if (!map || !map.objects) return null;
    for (const obj of map.objects) {
        if (obj.ox === x && obj.oy === y && obj.otyp === otyp && !obj.buried) return obj;
    }
    return null;
}

// C ref: invent.c nxtobj() — find next object of given type after obj in a list
// TRANSLATOR: AUTO (invent.c:1478)
export function nxtobj(obj, type, by_nexthere) {
  let otmp;
  otmp = obj;
  do {
    otmp = !by_nexthere ? otmp.nobj : otmp.nexthere;
    if (!otmp) {
      break;
    }
  } while (otmp.otyp !== type);
  return otmp;
}

// C ref: invent.c carrying() — check if hero carries object of given type
export function carrying(type, player) {
    for (const obj of (player.inventory || [])) {
        if (obj.otyp === type) return obj;
    }
    return null;
}

// C ref: invent.c carrying_stoning_corpse() — check for cockatrice corpse
export function carrying_stoning_corpse(player) {
    for (const obj of (player.inventory || [])) {
        if (obj.otyp === CORPSE && obj.corpsenm != null && touch_petrifies_corpsenm(obj.corpsenm)) {
            return obj;
        }
    }
    return null;
}

// Helper: check if monster type causes petrification on touch
function touch_petrifies_corpsenm(corpsenm) {
    // Requires mons data; simplified stub — checks for cockatrice-like
    try {
        const { mons } = require('./monsters.js');
        if (corpsenm >= 0 && corpsenm < mons.length) {
            return touch_petrifies(mons[corpsenm]);
        }
    } catch (e) { /* mons not available */ }
    return false;
}

// C ref: invent.c u_carried_gloves() — check if hero carries gloves
export function u_carried_gloves(player) {
    if (player.gloves) return player.gloves;
    for (const obj of (player.inventory || [])) {
        if (obj.oclass === ARMOR_CLASS && (objectData[obj.otyp]?.sub === ARM_GLOVES)) {
            return obj;
        }
    }
    return null;
}

// C ref: invent.c u_have_novel() — check if hero has a novel
export function u_have_novel(player) {
    for (const obj of (player.inventory || [])) {
        if (obj.otyp === SPE_NOVEL) return obj;
    }
    return null;
}

// C ref: invent.c o_on() — find object by id in a chain (recursive for containers)
export function o_on(id, objList) {
    for (const obj of (objList || [])) {
        if (obj.o_id === id) return obj;
        if (obj.cobj) {
            const found = o_on(id, obj.cobj);
            if (found) return found;
        }
    }
    return null;
}

// C ref: invent.c obj_here() — check if specific object is at location
export function obj_here(obj, x, y, map) {
    if (!map || !map.objects) return false;
    for (const o of map.objects) {
        if (o === obj && o.ox === x && o.oy === y && !o.buried) return true;
    }
    return false;
}

// C ref: invent.c g_at() — find gold at location
export function g_at(x, y, map) {
    if (!map || !map.objects) return null;
    for (const obj of map.objects) {
        if (obj.ox === x && obj.oy === y && obj.oclass === COIN_CLASS && !obj.buried) return obj;
    }
    return null;
}


// ============================================================
// 6. Splitting
// ============================================================

// C ref: invent.c splittable() — check if object stack can be split
export function splittable(obj, player) {
    if (obj.otyp === LOADSTONE && obj.cursed) return false;
    if (obj === player?.weapon && obj.welded) return false;
    return true;
}


// ============================================================
// 7. getobj / ggetobj
// ============================================================

// C ref: invent.c taking_off() — check if action is a take-off operation
export function taking_off(action) {
    return action === 'take off' || action === 'remove';
}

// C ref: invent.c mime_action() — mime gesture for empty-handed action
export function mime_action(word) {
    You('mime %sing something.', word);
}

// C ref: invent.c any_obj_ok() — callback that allows any object but not hands
// TRANSLATOR: AUTO (invent.c:1709)
export function any_obj_ok(obj) {
  if (obj) return GETOBJ_SUGGEST;
  return GETOBJ_EXCLUDE;
}

// C ref: invent.c silly_thing() — message for using silly object
export function silly_thing(word, otmp) {
    pline("That is a silly thing to %s.", word);
}

// C ref: invent.c ckvalidcat() — check if object belongs to valid category
export function ckvalidcat(otmp) {
    // Simplified: always valid
    return 1;
}

// C ref: invent.c ckunpaid() — check if object is unpaid
export function ckunpaid(otmp) {
    return !!(otmp.unpaid || (otmp.cobj && count_unpaid(otmp.cobj)));
}

// C ref: invent.c wearing_armor() — check if hero is wearing any armor
// TRANSLATOR: AUTO (invent.c:2148)
export function wearing_armor() {
  return (uarm || uarmc || uarmf || uarmg || uarmh || uarms || uarmu);
}

// C ref: invent.c is_worn() — check if object is being worn/wielded
// TRANSLATOR: AUTO (invent.c:2155)
export function is_worn(otmp) {
  return (otmp.owornmask & (W_ARMOR | W_ACCESSORY | W_SADDLE | W_WEAPONS)) ? true : false;
}

// C ref: invent.c is_inuse() — check if object is in use (worn/wielded/active tool)
export function is_inuse(obj, player) {
    return is_worn(obj, player) || tool_being_used(obj, player);
}

// C ref: invent.c getobj() — prompt player to select an inventory object
// Simplified JS version that works with the existing input system
export function getobj_simple(word, obj_ok, player) {
    // Returns the first suggested object, or null
    for (const obj of (player.inventory || [])) {
        const result = obj_ok(obj);
        if (result === GETOBJ_SUGGEST) return obj;
    }
    return null;
}

// C ref: invent.c ggetobj() — get object with class filter
// Simplified: just returns count of suggested items
export function ggetobj_count(word, player) {
    if (!player.inventory || !player.inventory.length) return 0;
    return player.inventory.length;
}

// C ref: invent.c safeq_xprname() / safeq_shortxprname() — safe name for prompts
export function safeq_xprname(obj) {
    return xprname_simple(obj);
}

export function safeq_shortxprname(obj) {
    return xprname_simple(obj);
}

// C ref: invent.c getobj_hands_txt() — text for empty-hand prompts
export function getobj_hands_txt(action) {
    if (action === 'wield') return 'your bare hands';
    if (action === 'ready') return 'empty quiver';
    return 'your hands';
}


// ============================================================
// 8. Identification
// ============================================================

// C ref: invent.c set_cknown_lknown() — set container/lock known flags
// TRANSLATOR: AUTO (invent.c:2623)
export function set_cknown_lknown(obj) {
  if (Is_container(obj) || obj.otyp === STATUE) obj.cknown = obj.lknown = 1;
  else if (obj.otyp === TIN) obj.cknown = 1;
  return;
}

// C ref: invent.c not_fully_identified() — check if object is not fully ID'd
export function not_fully_identified(obj) {
    const od = objectData[obj.otyp] || {};
    if (!od.name_known) return true;
    if (!obj.known || !obj.bknown || !obj.rknown) return true;
    if ((Is_container(obj) || obj.otyp === STATUE) && !obj.cknown) return true;
    return false;
}

// C ref: invent.c fully_identify_obj() — fully identify an object
export function fully_identify_obj(otmp) {
    const od = objectData[otmp.otyp];
    if (od) od.name_known = true; // makeknown
    otmp.known = true;
    otmp.bknown = true;
    otmp.rknown = true;
    otmp.dknown = true;
    set_cknown_lknown(otmp);
}

// C ref: invent.c identify() — identify object and give feedback
export function identify(otmp, player) {
    fully_identify_obj(otmp);
    prinv(null, otmp, 0, player);
    return 1;
}

// C ref: invent.c count_unidentified() — count unidentified objects
// TRANSLATOR: AUTO (invent.c:2697)
export function count_unidentified(objchn) {
  let unid_cnt = 0, obj;
  for (obj = objchn; obj; obj = obj.nobj) {
    if (not_fully_identified(obj)) ++unid_cnt;
  }
  return unid_cnt;
}

// C ref: invent.c identify_pack() — identify pack items
export function identify_pack(id_limit, player, learning_id) {
    const inv = player.inventory || [];
    let unid_cnt = count_unidentified(inv);

    if (!unid_cnt) {
        You('have already identified %s of your possessions.',
            !learning_id ? 'all' : 'the rest');
        return;
    }
    if (!id_limit || id_limit >= unid_cnt) {
        for (const obj of inv) {
            if (not_fully_identified(obj)) {
                identify(obj, player);
                if (--unid_cnt < 1) break;
            }
        }
    } else {
        // identify up to id_limit items — simplified: identify first N
        let remaining = id_limit;
        for (const obj of inv) {
            if (remaining <= 0) break;
            if (not_fully_identified(obj)) {
                identify(obj, player);
                remaining--;
            }
        }
    }
    update_inventory(player);
}

// C ref: invent.c learn_unseen_invent() — mark inventory objects as seen
export function learn_unseen_invent(player) {
    for (const obj of (player.inventory || [])) {
        if (!obj.dknown) {
            obj.dknown = true;
        }
    }
}


// ============================================================
// 9. Display
// ============================================================

// C ref: invent.c update_inventory() — update permanent inventory window
// In JS, this is a no-op placeholder; the UI refreshes via other mechanisms
export function update_inventory(player) {
    // Placeholder — UI updates are driven by the game loop in JS
}

// C ref: invent.c obj_to_let() — get inventory letter for an object
export function obj_to_let(obj) {
    return obj.invlet || NOINVSYM;
}

// C ref: invent.c xprname() — format an inventory line
export function xprname(obj, txt, let_char, dot, cost, quan, player = null) {
    let savequan = 0;
    if (quan && obj) {
        savequan = obj.quan;
        obj.quan = quan;
    }
    if (!txt) {
        txt = obj ? doname(obj, player) : '???';
    }
    let suffix = '';
    if (cost) {
        suffix = `  ${cost} ${currency(cost)}`;
    } else {
        suffix = dot ? '.' : '';
    }

    const result = `${let_char} - ${txt}${suffix}`;

    if (savequan && obj) obj.quan = savequan;
    return result;
}

// Simplified xprname for internal use
function xprname_simple(obj) {
    if (!obj) return '???';
    const let_char = obj.invlet || NOINVSYM;
    const txt = doname(obj);
    return `${let_char} - ${txt}`;
}

// C ref: invent.c prinv() — print an inventory item
export function prinv(prefix, obj, quan, player) {
    if (!prefix) prefix = '';
    const let_char = obj_to_let(obj);
    const line = xprname(obj, null, let_char, true, 0, quan, player);
    pline('%s%s%s', prefix, prefix ? ' ' : '', line);
}

// C ref: invent.c find_unpaid() — find unpaid items recursively
export function find_unpaid(list, last_found_ref) {
    for (const obj of (list || [])) {
        if (obj.unpaid) {
            if (last_found_ref.obj) {
                if (obj === last_found_ref.obj) last_found_ref.obj = null;
            } else {
                last_found_ref.obj = obj;
                return obj;
            }
        }
        if (obj.cobj) {
            const found = find_unpaid(obj.cobj, last_found_ref);
            if (found) return found;
        }
    }
    return null;
}

// C ref: invent.c display_inventory() — placeholder; actual UI is in handleInventory
export function display_inventory_items(lets, player) {
    // Actual display is handled by buildInventoryOverlayLines / handleInventory
    return buildInventoryOverlayLines(player);
}

// C ref: invent.c invdisp_nothing() — display "nothing" message
export function invdisp_nothing(hdr, txt) {
    pline('%s: %s', hdr, txt);
}


// ============================================================
// 10. Counting
// ============================================================

// C ref: invent.c count_unpaid() — count unpaid items including containers
export function count_unpaid(list) {
    let count = 0;
    for (const obj of (list || [])) {
        if (obj.unpaid) count++;
        if (obj.cobj) count += count_unpaid(obj.cobj);
    }
    return count;
}

// C ref: invent.c count_buc() — count items by BUC status
export function count_buc(list, type, filterfunc) {
    let count = 0;
    for (const obj of (list || [])) {
        if (filterfunc && !filterfunc(obj)) continue;
        if (obj.oclass === COIN_CLASS) {
            if (type === BUC_UNCURSED) count++;
            continue;
        }
        if (!obj.bknown) {
            if (type === BUC_UNKNOWN) count++;
        } else if (obj.blessed) {
            if (type === BUC_BLESSED) count++;
        } else if (obj.cursed) {
            if (type === BUC_CURSED) count++;
        } else {
            if (type === BUC_UNCURSED) count++;
        }
    }
    return count;
}

// C ref: invent.c tally_BUCX() — tally all BUC states at once
export function tally_BUCX(list) {
    let bcp = 0, ucp = 0, ccp = 0, xcp = 0, ocp = 0, jcp = 0;
    for (const obj of (list || [])) {
        if (obj.pickup_prev) jcp++;
        if (obj.oclass === COIN_CLASS) { ucp++; continue; }
        if (!obj.bknown) xcp++;
        else if (obj.blessed) bcp++;
        else if (obj.cursed) ccp++;
        else ucp++;
    }
    return { bcp, ucp, ccp, xcp, ocp, jcp };
}

// C ref: invent.c count_contents() — count items in a container
export function count_contents(container, nested, quantity, everything) {
    let count = 0;
    for (const obj of (container.cobj || [])) {
        if (nested && obj.cobj) {
            count += count_contents(obj, nested, quantity, everything);
        }
        if (everything || obj.unpaid) {
            count += quantity ? (obj.quan || 1) : 1;
        }
    }
    return count;
}

// C ref: invent.c this_type_only() — filter for specific object type
export function this_type_only(obj, filterType) {
    if (filterType === 'P') return !!obj.pickup_prev;
    if (obj.oclass === COIN_CLASS) {
        if (filterType && 'BUCX'.includes(filterType))
            return filterType === 'U';
    }
    switch (filterType) {
    case 'B': return !!(obj.bknown && obj.blessed);
    case 'U': return !!(obj.bknown && !obj.blessed && !obj.cursed);
    case 'C': return !!(obj.bknown && obj.cursed);
    case 'X': return !obj.bknown;
    default: return obj.oclass === filterType;
    }
}

// C ref: invent.c inv_cnt() — count inventory items
export function inv_cnt(incl_gold, player) {
    let ct = 0;
    for (const obj of (player.inventory || [])) {
        if (incl_gold || obj.invlet !== GOLD_SYM) ct++;
    }
    return ct;
}


// ============================================================
// 11. Look here
// ============================================================

// C ref: invent.c dfeature_at() — describe dungeon feature at location
export function dfeature_at(x, y, map) {
    if (!map || !map.grid) return null;
    const cell = map.grid[y]?.[x];
    if (!cell) return null;
    // Simplified: return feature description from cell type
    const typ = cell.typ || cell.type;
    if (typ === 'fountain') return 'fountain';
    if (typ === 'throne') return 'opulent throne';
    if (typ === 'sink') return 'sink';
    if (typ === 'altar') return 'altar';
    if (typ === 'grave') return 'grave';
    if (typ === 'tree') return 'tree';
    return null;
}

// C ref: invent.c look_here() — look at objects at hero location
export function look_here(player, map, obj_cnt) {
    const x = player.x, y = player.y;
    const objects = (map?.objects || []).filter(o => o.ox === x && o.oy === y && !o.buried);
    const dfeature = dfeature_at(x, y, map);

    if (dfeature) {
        pline('There is %s here.', dfeature);
    }

    if (objects.length === 0) {
        You('see no objects here.');
    } else if (objects.length === 1) {
        You('see here %s.', doname(objects[0]));
    } else {
        pline('Things that are here:');
        for (const obj of objects) {
            pline('  %s', doname(obj));
        }
    }
}

// C ref: invent.c dolook() — look command
export function dolook(player, map) {
    return look_here(player, map, 0);
}

// C ref: invent.c will_feel_cockatrice() — check if touching will petrify
export function will_feel_cockatrice(otmp, force_touch, player) {
    if ((!player?.blind && !force_touch) || player?.gloves) return false;
    if (otmp.otyp === CORPSE && otmp.corpsenm != null) {
        return touch_petrifies_corpsenm(otmp.corpsenm);
    }
    return false;
}

// C ref: invent.c feel_cockatrice() — handle touching cockatrice corpse
export function feel_cockatrice(otmp, force_touch, player) {
    if (will_feel_cockatrice(otmp, force_touch, player)) {
        pline('Touching that is a fatal mistake...');
        // instapetrify would be called here
    }
}


// ============================================================
// 12. Stacking / merging
// ============================================================

// C ref: invent.c stackobj() — try to merge object into existing stack on floor
export function stackobj(obj, map) {
    if (!map || !map.objects) return;
    for (const otmp of map.objects) {
        if (otmp !== obj && otmp.ox === obj.ox && otmp.oy === obj.oy
            && !otmp.buried && !obj.buried && mergable(otmp, obj)) {
            // Merge obj into otmp
            otmp.quan = (otmp.quan || 1) + (obj.quan || 1);
            otmp.owt = weight(otmp);
            // Remove obj from map
            const idx = map.objects.indexOf(obj);
            if (idx >= 0) map.objects.splice(idx, 1);
            return;
        }
    }
}

// C ref: invent.c mergable() — check if two objects can merge
export function mergable(otmp, obj) {
    if (obj === otmp) return false;
    if (obj.otyp !== otmp.otyp) return false;
    if (obj.nomerge || otmp.nomerge) return false;
    const od = objectData[obj.otyp];
    if (!od || !od.merge) return false;

    // Coins always merge
    if (obj.oclass === COIN_CLASS) return true;

    if (!!obj.cursed !== !!otmp.cursed || !!obj.blessed !== !!otmp.blessed)
        return false;

    // Globs always merge (beyond bless/curse check)
    if (obj.globby) return true;

    if (!!obj.unpaid !== !!otmp.unpaid) return false;
    if ((obj.spe ?? 0) !== (otmp.spe ?? 0)) return false;
    if (!!obj.no_charge !== !!otmp.no_charge) return false;
    if (!!obj.obroken !== !!otmp.obroken) return false;
    if (!!obj.otrapped !== !!otmp.otrapped) return false;
    if (!!obj.lamplit !== !!otmp.lamplit) return false;

    if (obj.oclass === FOOD_CLASS) {
        if ((obj.oeaten ?? 0) !== (otmp.oeaten ?? 0)) return false;
        if (!!obj.orotten !== !!otmp.orotten) return false;
    }

    if (!!obj.dknown !== !!otmp.dknown) return false;
    if (!!obj.bknown !== !!otmp.bknown) return false;
    if ((obj.oeroded ?? 0) !== (otmp.oeroded ?? 0)) return false;
    if ((obj.oeroded2 ?? 0) !== (otmp.oeroded2 ?? 0)) return false;
    if (!!obj.greased !== !!otmp.greased) return false;

    if (erosion_matters(obj)) {
        if (!!obj.oerodeproof !== !!otmp.oerodeproof) return false;
        if (!!obj.rknown !== !!otmp.rknown) return false;
    }

    if (obj.otyp === CORPSE || obj.otyp === EGG || obj.otyp === TIN) {
        if ((obj.corpsenm ?? -1) !== (otmp.corpsenm ?? -1)) return false;
    }

    // Hatching eggs don't merge
    if (obj.otyp === EGG && (obj.timed || otmp.timed)) return false;

    // Burning oil never merges
    if (obj.otyp === POT_OIL && obj.lamplit) return false;

    // Names must match
    const oname1 = obj.oname || '';
    const oname2 = otmp.oname || '';
    if (oname1 !== oname2) {
        // Corpses must have matching names (both or neither)
        if (obj.otyp === CORPSE) return false;
        // One named, one not: allow merge if only one is named
        if (oname1 && oname2) return false;
    }

    // Artifacts must match
    if ((obj.oartifact || 0) !== (otmp.oartifact || 0)) return false;

    if (!!obj.known !== !!otmp.known) return false;
    if (!!obj.opoisoned !== !!otmp.opoisoned) return false;

    return true;
}


// ============================================================
// 13. Print equipment
// ============================================================

// C ref: invent.c doprgold() — print gold amount
export function doprgold(player) {
    const gold = player.gold || 0;
    if (gold) {
        Your('wallet contains %d %s.', gold, currency(gold));
    } else {
        Your('wallet is empty.');
    }
}

// C ref: invent.c doprwep() — print wielded weapon
export function doprwep(player) {
    if (!player.weapon) {
        You('are empty handed.');
    } else {
        prinv(null, player.weapon, 0, player);
    }
}

// C ref: invent.c noarmor() — report no armor worn
export function noarmor() {
    You('are not wearing any armor.');
}

// C ref: invent.c doprarm() — print worn armor
export function doprarm(player) {
    if (!wearing_armor(player)) {
        noarmor();
    } else {
        const pieces = [player.armor, player.cloak, player.shield,
                       player.helmet, player.gloves, player.boots, player.shirt]
                       .filter(Boolean);
        for (const obj of pieces) {
            prinv(null, obj, 0, player);
        }
    }
}

// C ref: invent.c doprring() — print worn rings
export function doprring(player) {
    if (!player.leftRing && !player.rightRing) {
        You('are not wearing any rings.');
    } else {
        if (player.rightRing) prinv(null, player.rightRing, 0, player);
        if (player.leftRing) prinv(null, player.leftRing, 0, player);
    }
}

// C ref: invent.c dopramulet() — print worn amulet
export function dopramulet(player) {
    if (!player.amulet) {
        You('are not wearing an amulet.');
    } else {
        prinv(null, player.amulet, 0, player);
    }
}

// C ref: invent.c tool_being_used() — check if tool is in active use
// TRANSLATOR: AUTO (invent.c:4697)
export function tool_being_used(obj) {
  if ((obj.owornmask & (W_TOOL | W_SADDLE)) !== 0) return true;
  if (obj.oclass !== TOOL_CLASS) return false;
  return (obj === uwep || obj.lamplit || (obj.otyp === LEASH && obj.leashmon));
}

// C ref: invent.c doprtool() — print tools in use
export function doprtool(player) {
    const tools = (player.inventory || []).filter(o => tool_being_used(o, player));
    if (!tools.length) {
        You('are not using any tools.');
    } else {
        for (const obj of tools) {
            prinv(null, obj, 0, player);
        }
    }
}

// C ref: invent.c doprinuse() — print all items in use
export function doprinuse(player) {
    const inuse = (player.inventory || []).filter(o => is_inuse(o, player));
    if (!inuse.length) {
        You('are not wearing or wielding anything.');
    } else {
        for (const obj of inuse) {
            prinv(null, obj, 0, player);
        }
    }
}


// ============================================================
// 14. Inventory letters
// ============================================================

// C ref: invent.c let_to_name() — convert class to name string
export function let_to_name(let_char, unpaid, showsym) {
    const oclass = (typeof let_char === 'number' && let_char >= 1 && let_char <= 16)
        ? let_char : 0;
    let name;
    if (oclass) {
        name = CLASS_NAMES[oclass] || 'Illegal objects';
    } else if (let_char === CONTAINED_SYM) {
        name = 'Bagged/Boxed items';
    } else {
        name = 'Illegal objects';
    }
    if (unpaid) name = 'Unpaid ' + name;
    if (oclass && showsym) {
        const sym = CLASS_SYMBOLS[oclass] || '?';
        name += `  ('${sym}')`;
    }
    return name;
}

// C ref: invent.c reassign() — reassign consecutive inventory letters
export function reassign(player) {
    const inv = player.inventory || [];
    // Separate gold
    const goldIdx = inv.findIndex(o => o.oclass === COIN_CLASS);
    let goldObj = null;
    if (goldIdx >= 0) {
        goldObj = inv.splice(goldIdx, 1)[0];
    }
    // Re-letter
    for (let i = 0; i < inv.length; i++) {
        if (i < 26) inv[i].invlet = String.fromCharCode(97 + i); // a-z
        else if (i < 52) inv[i].invlet = String.fromCharCode(65 + i - 26); // A-Z
        else inv[i].invlet = NOINVSYM;
    }
    // Re-insert gold at front
    if (goldObj) {
        goldObj.invlet = GOLD_SYM;
        inv.unshift(goldObj);
    }
    player.lastInvlet = Math.min(inv.length - 1, 51);
}

// C ref: invent.c check_invent_gold() — check inventory gold consistency
export function check_invent_gold(player) {
    const inv = player.inventory || [];
    let goldStacks = 0;
    let wrongSlot = 0;
    for (const obj of inv) {
        if (obj.oclass === COIN_CLASS) {
            goldStacks++;
            if (obj.invlet !== GOLD_SYM) wrongSlot++;
        }
    }
    return goldStacks > 1 || wrongSlot > 0;
}


// ============================================================
// 15. Monster / container inventory
// ============================================================

// C ref: invent.c worn_wield_only() — filter to worn/wielded items only
// TRANSLATOR: AUTO (invent.c:5308)
export function worn_wield_only(obj) {
  return (obj.owornmask !== 0);
}

// C ref: invent.c display_minventory() — display monster inventory
export function display_minventory(mon) {
    if (!mon || !mon.minvent || !mon.minvent.length) {
        return null;
    }
    // Simplified: return formatted lines
    return mon.minvent.map(obj => doname(obj));
}

// C ref: invent.c display_cinventory() — display container inventory
export function display_cinventory(obj) {
    if (!obj.cobj || !obj.cobj.length) return null;
    obj.cknown = true;
    return obj.cobj.map(o => doname(o));
}

// C ref: invent.c only_here() — filter objects at current location
export function only_here(obj, x, y) {
    return obj.ox === x && obj.oy === y;
}

// C ref: invent.c display_binventory() — display buried inventory
export function display_binventory(x, y, map) {
    if (!map || !map.objects) return 0;
    const buried = map.objects.filter(o => o.ox === x && o.oy === y && o.buried);
    return buried.length;
}


// ============================================================
// 16. Permanent inventory — no-ops in JS
// ============================================================

// C ref: invent.c prepare_perminvent() — prepare permanent inventory display
export function prepare_perminvent() {}

// C ref: invent.c sync_perminvent() — sync permanent inventory with actual
export function sync_perminvent() {}

// C ref: invent.c perm_invent_toggled() — handle permanent inventory toggle
export function perm_invent_toggled() {}


// ============================================================
// Helpers
// ============================================================

// Helper: safely un-wear an object
function setnotworn_safe(obj, player) {
    if (!player) return;
    if (obj === player.weapon) player.weapon = null;
    if (obj === player.armor) player.armor = null;
    if (obj === player.shield) player.shield = null;
    if (obj === player.helmet) player.helmet = null;
    if (obj === player.gloves) player.gloves = null;
    if (obj === player.boots) player.boots = null;
    if (obj === player.cloak) player.cloak = null;
    if (obj === player.shirt) player.shirt = null;
    if (obj === player.amulet) player.amulet = null;
    if (obj === player.leftRing) player.leftRing = null;
    if (obj === player.rightRing) player.rightRing = null;
    if (obj === player.swapWeapon) player.swapWeapon = null;
    if (obj === player.quiver) player.quiver = null;
    if (obj === player.blindfold) player.blindfold = null;
}
