// Autogenerated translator module for currently-unmapped C source outputs.
// Contents are syntax-validated emitted functions; wiring into runtime is separate.

// TRANSLATOR: AUTO (files.c:353)
export function fqname(basenam, whichprefix, buffnum) {
  return basenam;
}

// TRANSLATOR: AUTO (files.c:393)
export function validate_prefix_locations(reasonbuf) {
  if (reasonbuf) reasonbuf[0] = '\0';
  return 1;
}

// TRANSLATOR: AUTO (files.c:443)
export function fopen_datafile(filename, mode, prefix) {
  let fp;
  filename = fqname(filename, prefix, prefix === TROUBLEPREFIX ? 3 : 0);
  fp = fopen(filename, mode);
  return fp;
}

// TRANSLATOR: AUTO (files.c:460)
export function init_nhfile(nhfp) {
  if (nhfp.structlevel) {
    if (nhfp.fd !== -1) {
      impossible("Warning - Unclosed structlevel file being reinitialized");
      nhclose(nhfp.fd);
    }
  }
  else if (nhfp.fpdef) {
    if (nhfp.fpdef) {
      impossible("Warning - Unclosed fieldlevel file being reinitialized");
      fclose(nhfp.fpdef);
    }
  }
  nhfp.fd = -1;
  nhfp.fpdef = null;
  nhfp.mode = COUNTING;
  nhfp.structlevel = true;
  nhfp.fieldlevel = false;
  nhfp.addinfo = false;
  nhfp.bendian = IS_BIGENDIAN();
  nhfp.fplog = null;
  nhfp.fpdebug = null;
  nhfp.rcount = nhfp.wcount = 0;
  nhfp.eof = false;
  nhfp.fnidx = 0;
  nhfp.style.deflt = false;
  nhfp.style.binary = true;
  nhfp.nhfpconvert = 0;
}

// TRANSLATOR: AUTO (files.c:508)
export function free_nhfile(nhfp) {
  if (nhfp) { init_nhfile(nhfp); (nhfp, 0); }
}

// TRANSLATOR: AUTO (files.c:517)
export function close_nhfile(nhfp) {
  if (nhfp.structlevel && nhfp.fd !== -1) nhclose(nhfp.fd), nhfp.fd = -1;
  else if (nhfp.fpdef) fclose(nhfp.fpdef), nhfp.fpdef = null;
  if (nhfp.fplog) {
    fprintf(nhfp.fplog, "# closing\n");
  }
  if (nhfp.fplog) {
    fclose(nhfp.fplog);
  }
  if (nhfp.fpdebug) {
    fclose(nhfp.fpdebug);
  }
  free_nhfile(nhfp);
}

// TRANSLATOR: AUTO (files.c:548)
export function viable_nhfile(nhfp) {
  if (nhfp) {
    if (((nhfp.fd === -1) && !nhfp.fpdef) || (nhfp.structlevel && nhfp.fd < 0) || (nhfp.fieldlevel && !nhfp.fpdef)) {
      if (nhfp.fieldlevel) {
        if (nhfp.fpdef) { fclose(nhfp.fpdef); nhfp.fpdef = null; }
        if (nhfp.fplog) { fprintf(nhfp.fplog, "# closing, not viable\n"); fclose(nhfp.fplog); }
        if (nhfp.fpdebug) {
          fclose(nhfp.fpdebug);
        }
      }
      free_nhfile(nhfp);
      nhfp = null;
    }
  }
  return nhfp;
}

// TRANSLATOR: AUTO (files.c:582)
export function nhclose(fd) {
  let retval = 0;
  if (fd >= 0) {
    if (close_check(fd)) bclose(fd);
    else {
      retval = close(fd);
    }
  }
  return retval;
}

// TRANSLATOR: AUTO (files.c:605)
export function set_levelfile_name(file, lev) {
  let tf;
  tf = strrchr(file, '.');
  if (!tf) tf = eos(file);
  Sprintf(tf, ".%d", lev);
  return;
}

// TRANSLATOR: AUTO (files.c:904)
export function commit_bonesfile(lev) {
  let fq_bones, tempname, ret;
  set_bonesfile_name(gb.bones, lev);
  fq_bones = fqname(gb.bones, BONESPREFIX, 0);
  tempname = set_bonestemp_name();
  tempname = fqname(tempname, BONESPREFIX, 1);
  ret = rename(tempname, fq_bones);
  if (wizard && ret !== 0) pline("couldn't rename %s to %s.", tempname, fq_bones);
}

// TRANSLATOR: AUTO (files.c:929)
export function open_bonesfile(lev, bonesid) {
  let fq_bones, nhfp = null;
   bonesid = set_bonesfile_name(gb.bones, lev);
  fq_bones = fqname(gb.bones, BONESPREFIX, 0);
  nh_uncompress(fq_bones);
  nhfp = new_nhfile();
  if (nhfp) {
    nhfp.structlevel = true;
    nhfp.fieldlevel = false;
    nhfp.ftype = NHF_BONESFILE;
    nhfp.mode = READING;
    nhfp.addinfo = true;
    nhfp.style.deflt = true;
    nhfp.style.binary = (sysopt.bonesformat[0] !== exportascii);
    nhfp.fnidx = sysopt.bonesformat[0];
    nhfp.fd = -1;
    nhfp.fpdef = fopen(fq_bones, nhfp.style.binary ? RDBMODE : RDTMODE);
    if (nhfp.fpdef) {
    }
    if (nhfp.structlevel) {
      nhfp.fd = open(fq_bones, O_RDONLY | O_BINARY, 0);
    }
  }
  nhfp = viable_nhfile(nhfp);
  return nhfp;
}

// TRANSLATOR: AUTO (files.c:971)
export function delete_bonesfile(lev) {
  let reslt;
  set_bonesfile_name(gb.bones, lev);
  reslt = unlink(fqname(gb.bones, BONESPREFIX, 0));
  delete_convertedfile(fqname(gb.bones, BONESPREFIX, 0));
  return !(reslt < 0);
}

// TRANSLATOR: AUTO (files.c:984)
export function compress_bonesfile() {
  nh_sfconvert(fqname(gb.bones, BONESPREFIX, 0));
  nh_compress(fqname(gb.bones, BONESPREFIX, 0));
}

// TRANSLATOR: AUTO (files.c:1106)
export function save_savefile_name(nhfp) {
  Sfo_char(nhfp, gs.SAVEF, "savefile_name", sizeof(gs.SAVEF));
}

// TRANSLATOR: AUTO (files.c:1115)
export function set_error_savefile() {
  Strcat(gs.SAVEF, ".e");
}

// TRANSLATOR: AUTO (files.c:1237)
export function delete_savefile() {
  let sfname = fqname(gs.SAVEF, SAVEPREFIX, 0);
  unlink(sfname);
  delete_convertedfile(sfname);
  return 0;
}

// TRANSLATOR: AUTO (files.c:1248)
export function restore_saved_game() {
  let fq_save, nhfp = null, sfstatus = 0;
  set_savefile_name(true);
  fq_save = fqname(gs.SAVEF, SAVEPREFIX, 0);
  nh_uncompress(fq_save);
  if ((nhfp = open_savefile()) !== 0) {
    if ((sfstatus = validate(nhfp, fq_save, false)) !== SF_UPTODATE) { close_nhfile(nhfp); nhfp = problematic_savefile(sfstatus, fq_save); }
  }
  return nhfp;
}

// TRANSLATOR: AUTO (files.c:1277)
export function get_freeing_nhfile() {
  let nhfp = null;
  nhfp = new_nhfile();
  if (nhfp) { nhfp.mode = FREEING; }
  return nhfp;
}

// TRANSLATOR: AUTO (files.c:1521)
export function free_saved_games(saved) {
  if (saved) {
    let i;
    for (i = 0; saved[i]; ++i) {
      (saved[i], 0);
    }
    (saved, 0);
  }
}

// TRANSLATOR: AUTO (files.c:1540)
export function redirect(filename, mode, stream, uncomp) {
  if (freopen(filename, mode, stream) === null) {
    let details;
    if ((details = strerror(errno)) === 0) details = "";
    fprintf(stderr, "freopen of %s for %scompress failed; (%d) %s\n", filename, uncomp ? "un" : "", errno, details);
    nh_terminate(EXIT_FAILURE);
  }
}

// TRANSLATOR: AUTO (files.c:1764)
export function nh_compress(filename) {
  docompress_file(filename, false);
}

// TRANSLATOR: AUTO (files.c:1773)
export function nh_uncompress(filename) {
  docompress_file(filename, true);
}

// TRANSLATOR: AUTO (files.c:2039)
export function doconvert_file(filename, sfstatus, unconvert) {
  nhUse(filename);
  nhUse(sfstatus);
  nhUse(unconvert);
  return 1;
}

// TRANSLATOR: AUTO (files.c:2049)
export function nh_sfconvert(filename) {
  doconvert_file(filename, 0, false);
}

// TRANSLATOR: AUTO (files.c:2055)
export function nh_sfunconvert(filename) {
  doconvert_file(filename, 0, true);
}

// TRANSLATOR: AUTO (files.c:2132)
export function delete_convertedfile(basefilename) {
  if (!converted_filename) make_converted_name(basefilename);
  if (converted_filename) { unlink(converted_filename); }
  return 0;
}

// TRANSLATOR: AUTO (files.c:2143)
export function free_convert_filenames() {
  if (converted_filename) (converted_filename, 0), converted_filename = 0;
  if (unconverted_filename) (unconverted_filename, 0), unconverted_filename = 0;
  cvtinit = false;
}

// TRANSLATOR: AUTO (files.c:2390)
export function unlock_file(filename) {
  if (gn.nesting === 1) {
    sflock.l_type = F_UNLCK;
    if (lockfd >= 0) {
      if (fcntl(lockfd, F_SETLK, sflock) === -1) {
        if (HUP) raw_printf("Can't remove fcntl lock on %s.", filename);
      }
      close(lockfd), lockfd = -1;
    }
  }
  gn.nesting--;
}

// TRANSLATOR: AUTO (files.c:2536)
export function proc_wizkit_line(buf) {
  let otmp;
  if (strlen(buf) >= BUFSZ) buf[BUFSZ - 1] = '\0';
  otmp = readobjnam(buf,  0);
  if (otmp) { if (otmp !== hands_obj) wizkit_addinv(otmp); }
  else {
    config_error_add("Bad wizkit item: \"%.60s\"", buf);
    return false;
  }
  return true;
}

// TRANSLATOR: AUTO (files.c:2661)
export function check_recordfile(dir) {
  let fq_record, fd;
  fq_record = fqname(RECORD, SCOREPREFIX, 0);
  fd = open(fq_record, O_RDWR, 0);
  if (fd >= 0) { nhclose(fd); }
  else if ((fd = open(fq_record, O_CREAT | O_RDWR, FCMASK)) >= 0) { nhclose(fd); }
  else {
    raw_printf("Warning: cannot write scoreboard file '%s'", fq_record);
    wait_synch();
  }
}

// TRANSLATOR: AUTO (files.c:2808)
export function testinglog(filenm, type, reason) {
  let lfile, fnbuf;
  if (!filenm) return;
  Strcpy(fnbuf, filenm);
  if (strchr(fnbuf, '.') === 0) {
    Strcat(fnbuf, ".log");
  }
  lfile = fopen_datafile(fnbuf, "a", TROUBLEPREFIX);
  if (lfile) { fprintf(lfile, "%s\n%s\n", type, reason); fclose(lfile); }
  return;
}

// TRANSLATOR: AUTO (files.c:3057)
export function do_deferred_showpaths(code) {
  gd.deferred_showpaths = false;
  reveal_paths(code);
  freedynamicdata();
  l_nhcore_done();
  after_opt_showpaths(gd.deferred_showpaths_dir);
}

// TRANSLATOR: AUTO (files.c:3093)
export function debugcore(filename, wildcards) {
  let debugfiles, p;
  if (!wizard) return false;
  if (!filename || !filename) return false;
  debugfiles = sysopt.debugfiles;
  if (!debugfiles || !debugfiles) return false;
  filename = nh_basename(filename, true);
  if (wildcards && pmatch(debugfiles, filename)) return true;
  if ((p = strstr(debugfiles, filename)) !== 0) {
    let l =  strlen(filename);
    if ((p === debugfiles || p[-1] === ' ' || p[-1] === '/') && (p[l] === ' ' || p[l] === '\0')) return true;
  }
  return false;
}

// TRANSLATOR: AUTO (files.c:304)
export function fname_decode(quotechar, s, callerbuf, bufsz) {
  let sp, op, k, calc, cnt = 0, hexdigits = "0123456789ABCDEF";
  sp = s;
  op = callerbuf;
   op = '\x00';
  while ( sp) {
    if ((bufsz - cnt) <= 2) return callerbuf;
    if ( sp === quotechar) {
      sp++;
      for (k = 0; k < 16; ++k) {
        if ( sp === hexdigits[k]) {
          break;
        }
      }
      if (k >= 16) return callerbuf;
      calc = k << 4;
      sp++;
      for (k = 0; k < 16; ++k) {
        if ( sp === hexdigits[k]) {
          break;
        }
      }
      if (k >= 16) return callerbuf;
      calc += k;
      sp++;
       op = calc;
       op = '\x00';
    }
    else { op = sp++; op = '\x00'; }
    cnt++;
  }
  return callerbuf;
}

// TRANSLATOR: AUTO (files.c:533)
export function rewind_nhfile(nhfp) {
  if (nhfp.structlevel) { lseek(nhfp.fd,  0, 0); }
  else { rewind(nhfp.fpdef); }
}

// TRANSLATOR: AUTO (files.c:2065)
export function make_converted_name(filename) {
  let ln, xtra, finaldirchar, dir = null, needsep = false;
  if (!filename) return false;
  if (unconverted_filename) (unconverted_filename, 0), unconverted_filename = 0;
  if (converted_filename) (converted_filename, 0), converted_filename = 0;
  ln =  strlen(filename);
  if (!contains_directory(filename)) {
    dir = nh_getenv("NETHACKDIR");
    if (!dir) dir = nh_getenv("HACKDIR");
    if (!dir) dir = HACKDIR;
    if (dir) {
      finaldirchar = c_eos(dir);
      finaldirchar--;
      if (!( finaldirchar === '/' || finaldirchar === '\\' || finaldirchar === ':')) { needsep = true; ln += 1; }
      ln += strlen(dir);
    }
  }
  unconverted_filename =  alloc(ln + 1);
  Snprintf(unconverted_filename, ln + 1, "%s%s%s", dir ? dir : "", (dir && needsep) ? "/" : "", filename);
  xtra = ".exportascii";
  ln +=  strlen(xtra);
  converted_filename =  alloc(ln + 1);
  Strcpy(converted_filename, unconverted_filename);
  Strcat(converted_filename, xtra);
  return true;
}

// TRANSLATOR: AUTO (files.c:2153)
export function contains_directory(s) {
  let i, slen = strlen(s), cp = s;
  for (i = 0; i < slen; ++i) {
    if ( cp === '\\' || cp === '/' || cp === ':') return true;
    cp++;
  }
  return false;
}

// TRANSLATOR: AUTO (files.c:3147)
export function reveal_paths(code) {
  let skip_sysopt = false, fqn, nodumpreason, buf, filep;
  let gamename = (gh.hname && gh.hname) ? gh.hname : "NetHack";
  let endp, envp, cwdbuf;
  buf[0] = '\x00';
  raw_printf("%s %s%s:", s_suffix(gamename), SYSCONFFILE, buf);
  filep = SYSCF_FILE;
  fqn = fqname(filep, SYSCONFPREFIX, 0);
  if (fqn) { set_configfile_name(fqn); filep = get_configfile(); }
  raw_printf(" \"%s\"", filep);
  if (code === 1) {
    raw_printf("NOTE: The %s above is missing or inaccessible!", SYSCONFFILE);
    skip_sysopt = true;
  }
  buf[0] = '\x00';
  envp = getcwd(cwdbuf, PATH_MAX);
  if (envp) {
    raw_print("The loadable symbols file:");
    raw_printf(" \"%s/%s\"", envp, SYMBOLS);
  }
  buf[0] = '\x00';
  raw_printf("Basic data files%s are in_ many separate files.", buf);
  fqn =  0;
  nodumpreason = "not supported";
  buf[0] = '\x00';
  raw_printf("Your personal configuration file%s:", buf);
  buf[0] = '\x00';
  if ((envp = nh_getenv("HOME")) !== 0) { copynchars(buf, envp,  buf.length - 1 - 1); Strcat(buf, "/"); }
  endp = eos(buf);
  copynchars(endp, get_default_configfile(),  (buf.length - 1 - strlen(buf)));
  raw_printf(" \"%s\"", buf);
  raw_print("");
  nhUse(skip_sysopt);
  nhUse(nodumpreason);
}

// TRANSLATOR: AUTO (files.c:998)
export function set_savefile_name(regularize_it) {
  let regoffset = 0, overflow = 0, indicator_spot = 0;
  let postappend =  0, sfindicator =  0;
  Sprintf(gs.SAVEF, "save/%d%s",  getuid(), svp.plname);
  regoffset = 5;
  indicator_spot = 2;
  if (regularize_it) regularize(gs.SAVEF + regoffset);
  if (indicator_spot === 1 && sfindicator && !overflow) {
    if (strlen(gs.SAVEF) + strlen(sfindicator) < (SAVESIZE - 1)) {
      Strcat(gs.SAVEF, sfindicator);
    }
    else {
      overflow = 2;
    }
  }
  if (strlen(SAVE_EXTENSION) > (0) && !overflow) {
    if (strlen(gs.SAVEF) + strlen(SAVE_EXTENSION) < (SAVESIZE - 1)) { Strcat(gs.SAVEF, SAVE_EXTENSION); }
    else {
      overflow = 3;
    }
  }
  if (indicator_spot === 2 && sfindicator && !overflow) {
    if (strlen(gs.SAVEF) + strlen(sfindicator) < (SAVESIZE - 1)) {
      Strcat(gs.SAVEF, sfindicator);
    }
    else {
      overflow = 4;
    }
  }
  if (postappend && !overflow) {
    if (strlen(gs.SAVEF) + strlen(postappend) < (SAVESIZE - 1)) {
      Strcat(gs.SAVEF, postappend);
    }
    else {
      overflow = 5;
    }
  }
  if (overflow) impossible("set_savefile_name() couldn't complete" + " without overflow %d", overflow);
}
