// Autogenerated translator module for currently-unmapped C source outputs.
// Contents are syntax-validated emitted functions; wiring into runtime is separate.

// TRANSLATOR: AUTO (coloratt.c:237)
export function color_attr_to_str(ca) {
  let buf;
  Sprintf(buf, "%s&%s", clr2colorname(ca.color), attr2attrname(ca.attr));
  return buf;
}

// TRANSLATOR: AUTO (coloratt.c:249)
export function color_attr_parse_str(ca, str) {
  let buf, amp = null, tmp, c = NO_COLOR, a = ATR_NONE;
  strncpy(buf, str, buf.length - 1);
  buf[buf.length - 1] = '\0';
  if ((amp = strchr(buf, '&')) !== 0) amp = '\0';
  if (amp) {
    amp++;
    c = match_str2clr(buf, false);
    a = match_str2attr(amp, true);
    if (c >= CLR_MAX && a === -1) { c = match_str2clr(amp, false); a = match_str2attr(buf, true); }
    if (c >= CLR_MAX || a === -1) return false;
  }
  else {
    tmp = match_str2attr(buf, false);
    if (tmp === -1) {
      tmp = match_str2clr(buf, false);
      if (tmp >= CLR_MAX) return false;
      c = tmp;
    }
    else { a = tmp; }
  }
  ca.attr = a;
  ca.color = c;
  return true;
}

// TRANSLATOR: AUTO (coloratt.c:292)
export async function query_color_attr(ca, prompt) {
  let c, a;
  c = query_color(prompt, ca.color);
  if (c === -1) return false;
  a = query_attr(prompt, ca.attr);
  if (a === -1) return false;
  ca.color = c;
  ca.attr = a;
  return true;
}

// TRANSLATOR: AUTO (coloratt.c:308)
export function attr2attrname(attr) {
  let i;
  for (i = 0; i < SIZE(attrnames); i++) {
    if (attrnames[i].attr === attr) return attrnames[i].name;
  }
  return  0;
}

// TRANSLATOR: AUTO (coloratt.c:326)
export function clr2colorname(clr) {
  let i;
  for (i = 0; i < SIZE(colornames); i++) {
    if (colornames[i].name && colornames[i].color === clr) return colornames[i].name;
  }
  return  0;
}

// TRANSLATOR: AUTO (coloratt.c:337)
export function match_str2clr(str, suppress_msg) {
  let i, c = CLR_MAX;
  for (i = 0; i < SIZE(colornames); i++) {
    if (colornames[i].name && fuzzymatch(str, colornames[i].name, " -_", true)) { c = colornames[i].color; break; }
  }
  if (i === SIZE(colornames) && digit( str)) c = atoi(str);
  if (c < 0 || c >= CLR_MAX) {
    if (!suppress_msg) config_error_add("Unknown color '%.60s'", str);
    c = CLR_MAX;
  }
  return c;
}

// TRANSLATOR: AUTO (coloratt.c:362)
export function match_str2attr(str, complain) {
  let i, a = -1;
  for (i = 0; i < SIZE(attrnames); i++) {
    if (attrnames[i].name && fuzzymatch(str, attrnames[i].name, " -_", true)) { a = attrnames[i].attr; break; }
  }
  if (a === -1 && complain) config_error_add("Unknown text attribute '%.50s'", str);
  return a;
}

// TRANSLATOR: AUTO (coloratt.c:672)
export function free_one_menu_coloring(idx, game) {
  let tmp = game.menu_colorings, prev = null;
  while (tmp) {
    if (idx === 0) {
      let next = tmp.next;
      regex_free(tmp.match);
      (tmp.origstr, 0);
      (tmp, 0);
      if (prev) prev.next = next;
      else {
        game.menu_colorings = next;
      }
      return;
    }
    idx--;
    prev = tmp;
    tmp = tmp.next;
  }
}

// TRANSLATOR: AUTO (coloratt.c:697)
export function count_menucolors(game) {
  let tmp, count = 0;
  for (tmp = game.menu_colorings; tmp; tmp = tmp.next) {
    count++;
  }
  return count;
}

// TRANSLATOR: AUTO (coloratt.c:985)
export function closest_color(lcolor, closecolor, clridx) {
  let i, color_index = -1, similar = INT_MAX, current, retbool = false;
  for (i = 0; i < SIZE(color_256_definitions); i++) {
    if (lcolor === color_256_definitions[i].value) { color_index = i; break; }
    current = color_distance(lcolor, color_256_definitions[i].value);
    if (current < similar) { color_index = i; similar = current; }
  }
  if (closecolor && clridx && color_index >= 0) {
     closecolor = color_256_definitions[color_index].value;
     clridx = color_256_definitions[color_index].index;
    retbool = true;
  }
  return retbool;
}

// TRANSLATOR: AUTO (coloratt.c:463)
export async function query_color(prompt, dflt_color) {
  let tmpwin, any, i, pick_cnt, picks = null;
  basic_menu_colors(true);
  tmpwin = create_nhwindow(NHW_MENU);
  start_menu(tmpwin, MENU_BEHAVE_STANDARD);
  any = cg.zeroany;
  for (i = 0; i < SIZE(colornames); i++) {
    if (!colornames[i].name) {
      break;
    }
    any.a_int = i + 1;
    add_menu(tmpwin, nul_glyphinfo, any, 0, 0, ATR_NONE, NO_COLOR, colornames[i].name, (colornames[i].color === dflt_color) ? MENU_ITEMFLAGS_SELECTED : MENU_ITEMFLAGS_NONE);
  }
  end_menu(tmpwin, (prompt && prompt) ? prompt : "Pick a color");
  pick_cnt = select_menu(tmpwin, PICK_ONE, picks);
  destroy_nhwindow(tmpwin);
  basic_menu_colors(false);
  if (pick_cnt > 0) {
    i = colornames[picks[0].item.a_int - 1].color;
    if (pick_cnt === 2 && i === NO_COLOR) i = colornames[picks[1].item.a_int - 1].color;
    (picks, 0);
    return i;
  }
  else if (pick_cnt === 0) { return dflt_color; }
  return -1;
}

// TRANSLATOR: AUTO (coloratt.c:605)
export function add_menu_coloring(tmpstr) {
  let c = NO_COLOR, a = ATR_NONE, tmps, cs, amp, str;
  strncpy(str, tmpstr, str.length - 1);
  str[str.length - 1] = '\x00';
  if ((cs = strchr(str, '=')) === 0) { config_error_add("Malformed MENUCOLOR"); return false; }
  tmps = cs + 1;
  mungspaces(tmps);
  if ((amp = strchr(tmps, '&')) !== 0) amp = '\x00';
  c = match_str2clr(tmps, false);
  if (c >= CLR_MAX) return false;
  if (amp) {
    tmps = amp + 1;
    a = match_str2attr(tmps, true);
    if (a === -1) return false;
  }
   cs = '\x00';
  tmps = str;
  if ( tmps === '"' || tmps === '\'') {
    cs--;
    while (isspace( cs)) {
      cs--;
    }
    if ( cs === tmps) { cs = '\x00'; tmps++; }
  }
  return add_menu_coloring_parsed(tmps, c, a);
}

// TRANSLATOR: AUTO (coloratt.c:789)
export function onlyhexdigits(buf) {
  let dp = buf;
  for (dp = buf;  dp; ++dp) {
    if (!(strchr(hexdd, dp) || dp === '-')) return false;
  }
  return true;
}
