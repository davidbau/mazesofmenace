// cmd.js -- Command dispatch
// Mirrors cmd.c from the C source.
// Maps keyboard input to game actions.

import { A_STR, A_DEX, A_CON, A_WIS, STATUS_ROW_1,
         PM_CAVEMAN, PM_ROGUE, RACE_ORC } from './config.js';
import { rn2 } from './rng.js';
import { handleWizLoadDes, wizLevelChange, wizMap, wizTeleport, wizGenesis, wizWish } from './wizcmds.js';
import { DIRECTION_KEYS, handleThrow, handleFire } from './dothrow.js';
import { handleKnownSpells } from './spell.js';
import { handleEngrave } from './engrave.js';
import { handleApply } from './apply.js';
import { COIN_CLASS } from './objects.js';
import { nhgetch, ynFunction, getlin, cmdq_pop_command, cmdq_clear, cmdq_add_ec,
         CQ_REPEAT } from './input.js';
import { handleEat } from './eat.js';
import { handleQuaff } from './potion.js';
import { handleRead } from './read.js';
import { handleWear, handlePutOn, handleTakeOff, handleRemove } from './do_wear.js';
import { handleWield, handleSwapWeapon, handleQuiver } from './wield.js';
import { handleDownstairs, handleUpstairs, handleDrop } from './do.js';
import { handleInventory, currency } from './invent.js';
import { handleCallObjectTypePrompt, handleDiscoveries } from './discovery.js';
import { handlePrevMessages, handleHelp, handleWhatdoes, handleHistory, handleViewMapPrompt } from './pager.js';
import { dolook, dowhatis, doquickwhatis } from './look.js';
import { handleKick } from './kick.js';
import { handleZap } from './zap.js';
import { handleSave } from './storage.js';
import { handleForce, handleOpen, handleClose } from './lock.js';
import { handlePickup, handleLoot, handlePay, handleTogglePickup } from './pickup.js';
import { handleSet } from './options_menu.js';
import { pline, impossible } from './pline.js';
import { domove, do_run, do_rush, findPath, dotravel, dotravel_target,
         RUN_KEYS, performWaitSearch } from './hack.js';

function Sprintf(fmt, ...args) {
    let i = 0;
    return String(fmt || '').replace(/%[lds]/g, () => String(args[i++] ?? ''));
}

function Strcpy(_dst, src) {
    return String(src || '');
}

function t_at(x, y, map) {
    if (!map || !Array.isArray(map.traps)) return null;
    for (const t of map.traps) {
        if (t && t.x === x && t.y === y) return t;
    }
    return null;
}

function m_at(x, y, map) {
    if (!map) return null;
    if (typeof map.monsterAt === 'function') return map.monsterAt(x, y);
    if (Array.isArray(map.monsters)) {
        for (const mon of map.monsters) {
            if (mon && mon.mx === x && mon.my === y) return mon;
        }
    }
    return null;
}

function u_at(player, x, y) {
    return !!(player && player.x === x && player.y === y);
}

// Process a command from the player
// C ref: cmd.c rhack() -- main command dispatch
// Returns: { moved: boolean, tookTime: boolean }
// Autotranslated from cmd.c:3744
export async function rhack(ch, game) {
    const { player, map, display, fov } = game;
    const svc = game.svc || (game.svc = {});
    const context = svc.context || (svc.context = {});
    const getRunMode = () => {
        if (Number.isInteger(context.run)) return Number(context.run || 0);
        if (Number.isInteger(game.runMode)) return Number(game.runMode || 0);
        return 0;
    };
    const getMenuRequested = () => {
        if (Number.isInteger(context.nopick)) return !!context.nopick;
        if (typeof game.menuRequested !== 'undefined') return !!game.menuRequested;
        return false;
    };
    const setMenuRequested = (value) => {
        context.nopick = value ? 1 : 0;
        if ('menuRequested' in game) game.menuRequested = !!value;
    };
    const getForceFight = () => {
        if (Number.isInteger(context.forcefight)) return !!context.forcefight;
        if (typeof game.forceFight !== 'undefined') return !!game.forceFight;
        return false;
    };
    const setForceFight = (value) => {
        context.forcefight = value ? 1 : 0;
        if ('forceFight' in game) game.forceFight = !!value;
    };
    const clearRunMode = () => {
        context.run = 0;
        if ('runMode' in game) game.runMode = 0;
    };
    const setRunMode = (mode) => {
        const n = Number(mode) || 0;
        const canonical = (n === 2) ? 2 : (n ? 3 : 0);
        context.run = canonical;
        if ('runMode' in game) game.runMode = canonical;
    };
    if (ch === 0) {
        const queued = cmdq_pop_command(!!game?.inDoAgain);
        if (!queued) return { moved: false, tookTime: false };
        if (queued.countPrefix > 0) {
            game.commandCount = queued.countPrefix;
            game.multi = Math.max(0, queued.countPrefix - 1);
        }
        if (queued.extcmd) {
            if (typeof queued.extcmd === 'function') {
                return await queued.extcmd(game);
            }
            if (typeof queued.extcmd?.ef_funct === 'function') {
                return await queued.extcmd.ef_funct(game);
            }
            return { moved: false, tookTime: false };
        }
        if (!queued.key) return { moved: false, tookTime: false };
        ch = queued.key;
    }
    const c = String.fromCharCode(ch);
    const isMetaKey = ch >= 128 && ch <= 255;
    const metaBaseChar = isMetaKey ? String.fromCharCode(ch & 0x7f).toLowerCase() : '';
    // C ref: you.h u.ux0/u.uy0 are the hero's pre-command position.
    // Monster throw logic (mthrowu.c URETREATING) compares against these.
    game.ux0 = player.x;
    game.uy0 = player.y;
    // C ref: tty command input acknowledges previous topline state before
    // processing a new command, so cross-turn messages don't auto-concatenate.
    if (display && 'messageNeedsMore' in display) {
        display.messageNeedsMore = false;
    }
    if (ch !== 16) {
        display.prevMessageCycleIndex = null;
    }
    if (ch !== 4) {
        player.kickedloc = null;
    }

    // C ref: cmdhelp/keyhelp + fixes3-6-3:
    // ^J (LF/newline) is bound to a south "go until near something" command
    // in non-numpad mode, while ^M is separate (often transformed before core).
    if (ch === 10) {
        return await do_rush(DIRECTION_KEYS.j, player, map, display, fov, game);
    }

    // C-faithful: both LF (^J) and CR from Enter should behave like the
    // movement binding in non-numpad mode (rush south).
    if (ch === 13) {
        return await do_rush(DIRECTION_KEYS.j, player, map, display, fov, game);
    }

    // Meta command keys (M-x / Alt+x).
    // C ref: command set includes M('l') for loot, M('f') for #force.
    if (metaBaseChar === 'l') {
        return await handleLoot(game);
    }
    if (metaBaseChar === 'f') {
        return await handleForce(game);
    }

    // Movement keys
    if (DIRECTION_KEYS[c]) {
        // Check if 'G' or 'g' prefix was used (run/rush mode)
        if (getRunMode()) {
            clearRunMode();
            return do_run(DIRECTION_KEYS[c], player, map, display, fov, game);
        }
        return await domove(DIRECTION_KEYS[c], player, map, display, game);
    }

    // Run keys (capital letter = run in that direction)
    if (RUN_KEYS[c]) {
        return do_run(RUN_KEYS[c], player, map, display, fov, game);
    }

    function clearTopline() {
        if (!display) return;
        if (typeof display.clearRow === 'function') display.clearRow(0);
        if ('topMessage' in display) display.topMessage = '';
        if ('messageNeedsMore' in display) display.messageNeedsMore = false;
    }

    // C ref: cmd.c do_rush()/do_run() prefix handling.
    // If the next key after g/G is not a movement command, cancel prefix
    // with a specific message instead of treating it as an unknown command.
    if (getRunMode() && c !== 'g' && c !== 'G' && ch !== 27) {
        const prefix = getRunMode() === 2 ? 'g' : 'G';
        clearRunMode();
        // C getdir-style quit keys after a run/rush prefix do not produce
        // the prefix-specific warning; they fall through as ordinary input.
        const isQuitLike = (ch === 32 || ch === 10 || ch === 13);
        if (!isQuitLike) {
            display.putstr_message(`The '${prefix}' prefix should be followed by a movement command.`);
            return { moved: false, tookTime: false };
        }
    }

    // Period/space = wait/search
    // C ref: cmd.c — space maps to donull only when rest_on_space is enabled.
    if (c === '.' || c === 's' || (c === ' ' && game?.flags?.rest_on_space)) {
        const result = performWaitSearch(c, game, map, player, fov, display);
        // C ref: cmd.c set_occupation(..., "waiting"/"searching", gm.multi)
        // for counted repeats of rest/search. timed_occupation executes the
        // command then decrements multi each turn.
        if (result.tookTime && game && game.multi > 0 && !game.occupation) {
            const occCmd = c;
            game.occupation = {
                occtxt: occCmd === 's' ? 'searching' : 'waiting',
                fn(g) {
                    performWaitSearch(occCmd, g, g.map, g.player, g.fov, g.display);
                    if (g.multi > 0) g.multi--;
                    return g.multi > 0;
                },
            };
        }
        return result;
    }

    if (game && game.lastSafetyWarningMessage) {
        game.lastSafetyWarningMessage = '';
    }

    // Pick up
    if (c === ',') {
        // C ref: cmd.c -- ',' is pickup
        return handlePickup(player, map, display);
    }

    // Go down stairs
    if (c === '>') {
        return await handleDownstairs(player, map, display, game);
    }

    // Go up stairs
    if (c === '<') {
        return await handleUpstairs(player, map, display, game);
    }

    // Open door
    if (c === 'o') {
        return await handleOpen(player, map, display, game);
    }

    // Close door
    if (c === 'c') {
        return await handleClose(player, map, display, game);
    }

    // Inventory
    if (c === 'i') {
        return await handleInventory(player, display, game);
    }

    // Count gold
    // C ref: cmd.c doprgold()
    if (c === '$') {
        const amount = Number.isFinite(player.gold) ? Math.max(0, Math.floor(player.gold)) : 0;
        display.putstr_message(`Your wallet contains ${amount} ${currency(amount)}.`);
        return { moved: false, tookTime: false };
    }

    // Wield weapon
    if (c === 'w') {
        return await handleWield(player, display);
    }

    // Swap primary/secondary weapon
    // C ref: wield.c doswapweapon()
    if (c === 'x') {
        return await handleSwapWeapon(player, display);
    }

    // Throw item
    // C ref: dothrow()
    if (c === 't') {
        return await handleThrow(player, map, display);
    }

    // Fire from quiver/launcher
    // C ref: dothrow() fire command path
    if (c === 'f') {
        return await handleFire(player, map, display, game);
    }

    // Quiver
    // C ref: wield.c dowieldquiver()
    if (c === 'Q') {
        return await handleQuiver(player, display);
    }

    // Remove ring/amulet
    // C ref: do_wear.c doremring()
    if (c === 'R') {
        return await handleRemove(player, display);
    }

    // Engrave
    // C ref: engrave.c doengrave()
    if (c === 'E') {
        return await handleEngrave(player, display);
    }

    // Wear armor
    if (c === 'W') {
        return await handleWear(player, display);
    }

    // Put on ring/accessory
    // C ref: do_wear.c doputon()
    if (c === 'P') {
        return await handlePutOn(player, display);
    }

    // Take off armor
    if (c === 'T') {
        return await handleTakeOff(player, display);
    }

    // Drop
    if (c === 'd') {
        return await handleDrop(player, map, display);
    }

    // Eat
    if (c === 'e') {
        return await handleEat(player, display, game);
    }

    // Quaff (drink)
    if (c === 'q') {
        return await handleQuaff(player, map, display);
    }

    // Apply / use item
    // C ref: apply.c doapply()
    if (c === 'a') {
        return await handleApply(player, map, display, game);
    }

    // Pay shopkeeper
    // C ref: shk.c dopay() -- full billing flow is not yet ported; preserve no-shopkeeper message.
    if (c === 'p') {
        return await handlePay(player, map, display);
    }

    // Read scroll/spellbook
    // C ref: read.c doread()
    if (c === 'r') {
        if (getMenuRequested()) setMenuRequested(false);
        return await handleRead(player, display, game);
    }

    // Zap wand
    if (c === 'z') {
        return await handleZap(player, map, display, game);
    }

    // Look (:)
    if (c === ':') {
        return dolook(game);
    }

    // What is (;)
    if (c === ';') {
        return await doquickwhatis(game);
    }

    // Whatis (/)
    // C ref: pager.c dowhatis()
    if (c === '/') {
        return await dowhatis(game);
    }

    // Whatdoes (&)
    // C ref: pager.c dowhatdoes()
    if (c === '&') {
        return await handleWhatdoes(game);
    }

    // Discoveries (\)
    // C ref: o_init.c dodiscovered()
    if (c === '\\') {
        return await handleDiscoveries(game);
    }

    // History (V)
    // C ref: pager.c dohistory()
    if (c === 'V') {
        return await handleHistory(game);
    }

    // List known spells (+)
    // C ref: spell.c dovspell()
    if (c === '+') {
        return await handleKnownSpells(player, display);
    }

    // Version (v)
    // C ref: pager.c doversion()
    if (c === 'v') {
        if (typeof display.clearRow === 'function') display.clearRow(0);
        display.topMessage = null;
        display.messageNeedsMore = false;
        return { moved: false, tookTime: false };
    }

    // Kick (Ctrl+D)
    if (ch === 4) {
        return await handleKick(player, map, display, game);
    }

    // Previous messages (Ctrl+P)
    if (ch === 16) {
        return await handlePrevMessages(display);
    }

    // View map overlays (DEL / Backspace on some tty keymaps)
    // C ref: cmd.c dooverview()
    if (ch === 127 || ch === 8) {
        return await handleViewMapPrompt(game);
    }

    // Help (?)
    if (c === '?') {
        return await handleHelp(game);
    }

    // Save (S)
    if (c === 'S') {
        return await handleSave(game);
    }

    // Options (O) — C ref: doset()
    if (c === 'O') {
        return await handleSet(game);
    }

    // Toggle autopickup (@) — C ref: dotogglepickup()
    if (c === '@') {
        return await handleTogglePickup(game);
    }

    // Quit (#quit or Ctrl+C)
    if (ch === 3) {
        const ans = await ynFunction('Really quit?', 'yn', 'n'.charCodeAt(0), display);
        if (String.fromCharCode(ans) === 'y') {
            game.gameOver = true;
            game.gameOverReason = 'quit';
            player.deathCause = 'quit';
            display.putstr_message('Goodbye...');
        }
        return { moved: false, tookTime: false };
    }

    // Extended command (#)
    // C ref: cmd.c doextcmd()
    if (c === '#') {
        return await handleExtendedCommand(game);
    }

    // Travel command (_)
    // C ref: cmd.c dotravel()
    if (c === '_') {
        return await dotravel(game);
    }

    // Retravel (Ctrl+_)
    // C ref: cmd.c dotravel_target()
    if (ch === 31) { // Ctrl+_ (ASCII 31)
        if (game.travelX !== undefined && game.travelY !== undefined) {
            const path = findPath(map, player.x, player.y, game.travelX, game.travelY);
            if (!path) {
                display.putstr_message('No path to previous destination.');
                return { moved: false, tookTime: false };
            }
            if (path.length === 0) {
                display.putstr_message('You are already there.');
                return { moved: false, tookTime: false };
            }
            game.travelPath = path;
            game.travelStep = 0;
            display.putstr_message(`Traveling... (${path.length} steps)`);
            return await dotravel_target(game);
        } else {
            display.putstr_message('No previous travel destination.');
            return { moved: false, tookTime: false };
        }
    }

    // Wizard mode: Ctrl+V = #levelchange
    // C ref: cmd.c wiz_level_change()
    if (ch === 22 && game.wizard) {
        return await wizLevelChange(game);
    }

    // Wizard mode: Ctrl+F = magic mapping (reveal map)
    // C ref: cmd.c wiz_map()
    if (ch === 6 && game.wizard) {
        return wizMap(game);
    }

    // Wizard mode: Ctrl+T = teleport
    // C ref: cmd.c wiz_teleport()
    if (ch === 20 && game.wizard) {
        return await wizTeleport(game);
    }

    // Wizard mode: Ctrl+G = genesis (create monster)
    // C ref: cmd.c wiz_genesis()
    if (ch === 7 && game.wizard) {
        return await wizGenesis(game);
    }

    // Wizard mode: Ctrl+W = wish
    // C ref: cmd.c wiz_wish()
    if (ch === 23 && game.wizard) {
        return await wizWish(game);
    }

    // Wizard mode: Ctrl+I = identify all
    // C ref: cmd.c wiz_identify()
    if (ch === 9 && game.wizard) {
        display.putstr_message('All items in inventory identified.');
        return { moved: false, tookTime: false };
    }

    // Redraw (Ctrl+R)
    if (ch === 18) {
        display.renderMap(map, player, fov);
        display.renderStatus(player);
        return { moved: false, tookTime: false };
    }

    // Prefix commands (modifiers for next command)
    // C ref: cmd.c:1624 do_reqmenu() — 'm' prefix
    if (c === 'm') {
        if (getMenuRequested()) {
            setMenuRequested(false);
        } else {
            setMenuRequested(true);
            // C ref: cmd.c do_reqmenu() — sets iflags.menu_requested
            // silently; no screen message in C's TTY implementation.
        }
        return { moved: false, tookTime: false };
    }

    // C ref: cmd.c:1671 do_fight() — 'F' prefix
    if (c === 'F') {
        if (getForceFight()) {
            display.putstr_message('Double fight prefix, canceled.');
            setForceFight(false);
        } else {
            setForceFight(true);
            if (game.flags.verbose) {
                display.putstr_message('Next movement will force fight even if no monster visible.');
            }
        }
        return { moved: false, tookTime: false };
    }

    // C ref: cmd.c:1655 do_run() — 'G' prefix (run)
    if (c === 'G') {
        if (getRunMode()) {
            display.putstr_message('Double run prefix, canceled.');
            clearRunMode();
        } else {
            setRunMode(3); // run mode
            if (game.flags.verbose) {
                display.putstr_message('Next direction will run until something interesting.');
            }
        }
        return { moved: false, tookTime: false };
    }

    // C ref: cmd.c:1639 do_rush() — 'g' prefix (rush)
    if (c === 'g') {
        if (getRunMode()) {
            display.putstr_message('Double rush prefix, canceled.');
            clearRunMode();
        } else {
            setRunMode(2); // rush mode
            if (game.flags.verbose) {
                display.putstr_message('Next direction will rush until something interesting.');
            }
        }
        return { moved: false, tookTime: false };
    }

    // Escape -- ignore silently (cancels pending prompts)
    // C ref: cmd.c -- ESC aborts current command
    if (ch === 27) {
        // Also clear prefix flags
        setMenuRequested(false);
        setForceFight(false);
        clearRunMode();
        return { moved: false, tookTime: false };
    }

    // Unknown command
    display.putstr_message(`Unknown command '${ch < 32 ? '^' + String.fromCharCode(ch + 64) : c}'.`);
    return { moved: false, tookTime: false };
}

async function handleExtendedCommand(game) {
    const { player, display } = game;
    const input = await getlin('# ', display);
    if (input === null || input.trim() === '') {
        return { moved: false, tookTime: false };
    }
    const rawCmd = input.trim();
    const cmd = rawCmd.toLowerCase();
    const queueRepeatExtcmd = (fn) => {
        if (game?.inDoAgain || typeof fn !== 'function') return;
        cmdq_clear(CQ_REPEAT);
        cmdq_add_ec(CQ_REPEAT, fn);
    };
    switch (cmd) {
        case 'o':
        case 'options':
        case 'optionsfull':
            queueRepeatExtcmd((g) => handleSet(g));
            return await handleSet(game);
        case 'n':
        case 'name': {
            queueRepeatExtcmd(async (g) => handleExtendedCommandName(g));
            return await handleExtendedCommandName(game);
        }
        case 'force':
            queueRepeatExtcmd((g) => handleForce(g));
            return await handleForce(game);
        case 'loot':
            queueRepeatExtcmd((g) => handleLoot(g));
            return await handleLoot(game);
        case 'levelchange':
            queueRepeatExtcmd((g) => wizLevelChange(g));
            return await wizLevelChange(game);
        case 'wish':
            queueRepeatExtcmd((g) => wizWish(g));
            return await wizWish(game);
        case 'map':
            queueRepeatExtcmd((g) => wizMap(g));
            return wizMap(game);
        case 'teleport':
            queueRepeatExtcmd((g) => wizTeleport(g));
            return await wizTeleport(game);
        case 'genesis':
            queueRepeatExtcmd((g) => wizGenesis(g));
            return await wizGenesis(game);
        case 'wizloaddes':
            queueRepeatExtcmd((g) => handleWizLoadDes(g));
            return await handleWizLoadDes(game);
        case 'quit': {
            const ans = await ynFunction('Really quit?', 'yn', 'n'.charCodeAt(0), display);
            if (String.fromCharCode(ans) === 'y') {
                game.gameOver = true;
                game.gameOverReason = 'quit';
                player.deathCause = 'quit';
                display.putstr_message('Goodbye...');
            }
            return { moved: false, tookTime: false };
        }
        // C ref: cmd.c extcmdlist[] — extended command aliases that map
        // to regular key commands. These appear in wizard-mode sessions
        // when players type #<cmd> instead of the single-key shortcut.
        case 'w':
        case 'wield':
            queueRepeatExtcmd((g) => handleWield(g.player, g.display));
            return await handleWield(player, display);
        case 'wear':
            queueRepeatExtcmd((g) => handleWear(g.player, g.display));
            return await handleWear(player, display);
        case 'e':
        case 'eat':
            queueRepeatExtcmd((g) => handleEat(g.player, g.display, g));
            return await handleEat(player, display, game);
        case 'r':
        case 'read':
            queueRepeatExtcmd((g) => handleRead(g.player, g.display, g));
            return await handleRead(player, display, game);
        case 'a':
        case 'again':
        case 'repeat':
            return { moved: false, tookTime: false, repeatRequest: true };
        default:
            // C-style unknown extended command feedback
            display.putstr_message(`#${rawCmd}: unknown extended command.`);
            return { moved: false, tookTime: false };
    }
}

async function handleExtendedCommandName(game) {
    const { player, display } = game;
    while (true) {
        display.putstr_message('                                What do you want to name?');
        const sel = await nhgetch();
        const c = String.fromCharCode(sel).toLowerCase();
        if (sel === 27 || c === ' ') {
            display.putstr_message('Never mind.');
            return { moved: false, tookTime: false };
        }
        if (c === 'a') {
            await getlin('What do you want to call this dungeon level?', display);
            return { moved: false, tookTime: false };
        }
        if (c === 'o' || c === 'n') {
            return await handleCallObjectTypePrompt(player, display);
        }
        // Keep waiting for a supported selection.
    }
}

// Autotranslated from cmd.c:407
export function doprev_message() {
  nh_doprev_message();
  return ECMD_OK;
}

// Autotranslated from cmd.c:415
export function timed_occupation(game) {
  let result;
  midlog_enter("timed_occupation", __FILE__, __LINE__, __func__);
  timed_occ_fn();
  if (game.multi > 0) game.multi--;
  result = game.multi > 0;
  midlog_exit_int("timed_occupation", result, __FILE__, __LINE__, __func__);
  return result;
}

// Autotranslated from cmd.c:442
export function reset_occupations() {
  reset_remarm();
  reset_pick();
  reset_trapset();
}

// Autotranslated from cmd.c:622
export function cmdq_reverse(head) {
  let prev = null, curr = head, next;
  while (curr) {
    next = curr.next;
    curr.next = prev;
    prev = curr;
    curr = next;
  }
  return prev;
}

// Autotranslated from cmd.c:1201
export async function enter_explore_mode() {
  if (discover) { You("are already in explore mode."); }
  else {
    let oldmode = !wizard ? "normal game" : "debug mode";
    if (!authorize_explore_mode()) {
      if (!wizard) { You("cannot access explore mode."); return ECMD_OK; }
      else {
        pline( "Note: normally you wouldn't be allowed into explore mode.");
      }
    }
    pline("Beware! From explore mode there will be no return to %s,", oldmode);
    if (paranoid_query(ParanoidQuit, "Do you want to enter explore mode?")) {
      discover = true;
      wizard = false;
      clear_nhwindow(WIN_MESSAGE);
      You("are now in non-scoring explore mode.");
    }
    else { clear_nhwindow(WIN_MESSAGE); pline("Continuing with %s.", oldmode); }
  }
  return ECMD_OK;
}

// Autotranslated from cmd.c:1323
export function wiz_dumpmap(map) {
  let fname, fp, x, y;
  fname = getenv("NETHACK_DUMPMAP");
  if (!fname || !fname) fname = "dumpmap.txt";
  fp = fopen(fname, "w");
  if (!fp) { pline("Cannot open %s for writing.", fname); return ECMD_OK; }
  for (y = 0; y < ROWNO; y++) {
    for (x = 0; x < COLNO; x++) {
      if (x > 0) fputc(' ', fp);
      fprintf(fp, "%d", map.locations[x][y].typ);
    }
    fputc('\n', fp);
  }
  fclose(fp);
  pline("Map dumped to %s.", fname);
  return ECMD_OK;
}

// Autotranslated from cmd.c:1357
export function wiz_dumpobj() {
  let fname, fp, obj;
  fname = getenv("NETHACK_DUMPOBJ");
  if (!fname || !fname) fname = "dumpobj.txt";
  fp = fopen(fname, "w");
  if (!fp) { pline("Cannot open %s for writing.", fname); return ECMD_OK; }
  for (obj = fobj; obj; obj = obj.nobj) {
    fprintf(fp, "%d %d %d %u %s\n", obj.ox, obj.oy, obj.otyp, obj.owt, OBJ_NAME(objectData[obj.otyp]));
  }
  fclose(fp);
  pline("Objects dumped to %s.", fname);
  return ECMD_OK;
}

// Autotranslated from cmd.c:1387
export async function wiz_dumpsnap() {
  let phasebuf;
  Sprintf(phasebuf, "manual");
  await getlin("Checkpoint phase tag:", phasebuf);
  mungspaces(phasebuf);
  if (!phasebuf) {
    Strcpy(phasebuf, "manual");
  }
  harness_dump_checkpoint(phasebuf);
  pline("Snapshot appended (%s).", phasebuf);
  return ECMD_OK;
}

// Autotranslated from cmd.c:1595
export function dolookaround_floodfill_findroom(x, y, map) {
  let typ = map.locations[x][y].typ;
  if (IS_STWALL(typ) || IS_DOOR(typ) || IS_TREE(typ) || IS_WATERWALL(typ) || typ === LAVAWALL || typ === IRONBARS || typ === SCORR || typ === SDOOR || typ === DRAWBRIDGE_UP) return false;
  return true;
}

// Autotranslated from cmd.c:1608
export function lookaround_known_room(x, y, player) {
  let sel = selection_new(), rmno = player.urooms[0] - ROOMOFFSET, qbuf;
  set_selection_floodfillchk(dolookaround_floodfill_findroom);
  selection_floodfill(sel, x, y, true);
  if (!u_at(x, y)) set_msg_xy(x, y);
  if (u_have_seen_whole_selection(sel)) {
    let u_in =  selection_getpoint(x, y, sel);
    You("%s %s %s.", u_at(x, y) && u_in && u_can_see_whole_selection(sel) ? "are in" : (u_at(x, y)) ? "remember this as" : "remember that as", an(selection_size_description(sel, qbuf)), rmno >= 0 ? "room" : "area");
  }
  else if (u_have_seen_bounds_selection(sel)) {
    You("guess %s to be %s %s.", u_at(x, y) ? "this" : "that", an(selection_size_description(sel, qbuf)), rmno >= 0 ? "room" : "area");
  }
  else {
    You("can't guess the size of %s area.", u_at(x, y) ? "this" : "that");
  }
  selection_free(sel, true);
}

// Autotranslated from cmd.c:1721
export function do_move_west() {
  set_move_cmd(DIR_W, 0);
  return ECMD_TIME;
}

// Autotranslated from cmd.c:1728
export function do_move_northwest() {
  set_move_cmd(DIR_NW, 0);
  return ECMD_TIME;
}

// Autotranslated from cmd.c:1735
export function do_move_north() {
  set_move_cmd(DIR_N, 0);
  return ECMD_TIME;
}

// Autotranslated from cmd.c:1742
export function do_move_northeast() {
  set_move_cmd(DIR_NE, 0);
  return ECMD_TIME;
}

// Autotranslated from cmd.c:1749
export function do_move_east() {
  set_move_cmd(DIR_E, 0);
  return ECMD_TIME;
}

// Autotranslated from cmd.c:1756
export function do_move_southeast() {
  set_move_cmd(DIR_SE, 0);
  return ECMD_TIME;
}

// Autotranslated from cmd.c:1763
export function do_move_south() {
  set_move_cmd(DIR_S, 0);
  return ECMD_TIME;
}

// Autotranslated from cmd.c:1770
export function do_move_southwest() {
  set_move_cmd(DIR_SW, 0);
  return ECMD_TIME;
}

// Autotranslated from cmd.c:1778
export function do_rush_west() {
  set_move_cmd(DIR_W, 3);
  return ECMD_TIME;
}

// Autotranslated from cmd.c:1785
export function do_rush_northwest() {
  set_move_cmd(DIR_NW, 3);
  return ECMD_TIME;
}

// Autotranslated from cmd.c:1792
export function do_rush_north() {
  set_move_cmd(DIR_N, 3);
  return ECMD_TIME;
}

// Autotranslated from cmd.c:1799
export function do_rush_northeast() {
  set_move_cmd(DIR_NE, 3);
  return ECMD_TIME;
}

// Autotranslated from cmd.c:1806
export function do_rush_east() {
  set_move_cmd(DIR_E, 3);
  return ECMD_TIME;
}

// Autotranslated from cmd.c:1813
export function do_rush_southeast() {
  set_move_cmd(DIR_SE, 3);
  return ECMD_TIME;
}

// Autotranslated from cmd.c:1820
export function do_rush_south() {
  set_move_cmd(DIR_S, 3);
  return ECMD_TIME;
}

// Autotranslated from cmd.c:1827
export function do_rush_southwest() {
  set_move_cmd(DIR_SW, 3);
  return ECMD_TIME;
}

// Autotranslated from cmd.c:1835
export function do_run_west() {
  set_move_cmd(DIR_W, 1);
  return ECMD_TIME;
}

// Autotranslated from cmd.c:1842
export function do_run_northwest() {
  set_move_cmd(DIR_NW, 1);
  return ECMD_TIME;
}

// Autotranslated from cmd.c:1849
export function do_run_north() {
  set_move_cmd(DIR_N, 1);
  return ECMD_TIME;
}

// Autotranslated from cmd.c:1856
export function do_run_northeast() {
  set_move_cmd(DIR_NE, 1);
  return ECMD_TIME;
}

// Autotranslated from cmd.c:1863
export function do_run_east() {
  set_move_cmd(DIR_E, 1);
  return ECMD_TIME;
}

// Autotranslated from cmd.c:1870
export function do_run_southeast() {
  set_move_cmd(DIR_SE, 1);
  return ECMD_TIME;
}

// Autotranslated from cmd.c:1877
export function do_run_south() {
  set_move_cmd(DIR_S, 1);
  return ECMD_TIME;
}

// Autotranslated from cmd.c:1884
export function do_run_southwest() {
  set_move_cmd(DIR_SW, 1);
  return ECMD_TIME;
}

// Autotranslated from cmd.c:1939
export function do_fight(game) {
  if (game.game.svc.context.forcefight) {
    Norep("Double fight prefix, canceled.");
    game.game.svc.context.forcefight = 0;
    game.gd.domove_attempting = 0;
    return ECMD_CANCEL;
  }
  game.game.svc.context.forcefight = 1;
  game.gd.domove_attempting |= DOMOVE_WALK;
  return ECMD_OK;
}

// Autotranslated from cmd.c:2613
export async function handler_change_autocompletions() {
  let win, any, i, n, picks = null, clr = NO_COLOR, ec, buf;
  win = create_nhwindow(NHW_MENU);
  start_menu(win, MENU_BEHAVE_STANDARD);
  any = cg.zeroany;
  for (i = 0; i < extcmdlist_length; i++) {
    ec = extcmdlist;
    if ((ec.flags & (INTERNALCMD|CMD_NOT_AVAILABLE)) !== 0) {
      continue;
    }
    if (strlen(ec.ef_txt) < 2) {
      continue;
    }
    any.a_int = (i + 1);
    Sprintf(buf, "%c %s: %s", (ec.flags & AUTOCOMP_ADJ) ? '*' : ' ', ec.ef_txt, ec.ef_desc);
    add_menu(win, nul_glyphinfo, any, '\0', 0, ATR_NONE, clr, buf, (ec.flags & AUTOCOMPLETE) ? MENU_ITEMFLAGS_SELECTED : MENU_ITEMFLAGS_NONE);
  }
  end_menu(win, "Which commands autocomplete?");
  n = select_menu(win, PICK_ANY, picks);
  if (n >= 0) {
    let j;
    for (i = 0; i < extcmdlist_length; i++) {
      let setit = false;
      ec = extcmdlist;
      if ((ec.flags & (INTERNALCMD|CMD_NOT_AVAILABLE)) !== 0) {
        continue;
      }
      if (strlen(ec.ef_txt) < 2) {
        continue;
      }
      Sprintf(buf, "%s", ec.ef_txt);
      for (j = 0; j < n; ++j) {
        if (ec === extcmdlist[(picks[j].item.a_int - 1)]) {
          parseautocomplete(buf, true);
          setit = true;
          break;
        }
      }
      if (!setit) { parseautocomplete(buf, false); }
    }
    if (n > 0) (picks, 0);
  }
  destroy_nhwindow(win);
}

// Autotranslated from cmd.c:3144
export function cmd_from_dir(dir, mode) {
  return cmd_from_func(move_funcs[dir][mode]);
}

// Autotranslated from cmd.c:3321
export function spkey_name(nhkf) {
  let name = 0, i;
  for (i = 0; i < SIZE(spkeys_binds); i++) {
    if (spkeys_binds[i].nhkf === nhkf) {
      name = (nhkf === NHKF_ESC) ? "escape" : spkeys_binds[i].name;
      break;
    }
  }
  return name;
}

// Autotranslated from cmd.c:3409
export function all_options_autocomplete(sbuf) {
  let efp, buf;
  for (efp = extcmdlist; efp.ef_txt; efp++) {
    if ((efp.flags & AUTOCOMP_ADJ) !== 0) {
      Sprintf(buf, "AUTOCOMPLETE=%s%s\n", (efp.flags & AUTOCOMPLETE) ? "" : "!", efp.ef_txt);
      strbuf_append(sbuf, buf);
    }
  }
}

// Autotranslated from cmd.c:3425
export function count_autocompletions() {
  let efp, n = 0;
  for (efp = extcmdlist; efp.ef_txt; efp++) {
    if ((efp.flags & AUTOCOMP_ADJ) !== 0) n++;
  }
  return n;
}

// Autotranslated from cmd.c:3717
export function rnd_extcmd_idx() {
  return rn2(extcmdlist_length + 1) - 1;
}

// Autotranslated from cmd.c:3960
export function xytod(x, y) {
  let dd;
  for (dd = 0; dd < N_DIRS; dd++) {
    if (x === xdir[dd] && y === ydir) return dd;
  }
  return DIR_ERR;
}

// Autotranslated from cmd.c:3972
export function dtoxy(cc, dd) {
  if (dd > DIR_ERR && dd < N_DIRS_Z) { cc.x = xdir; cc.y = ydir; }
}

// Autotranslated from cmd.c:4014
export function dxdy_moveok(player) {
  if (player.dx && player.dy && NODIAG(player.umonnum)) player.dx = player.dy = 0;
  return player.dx || player.dy;
}

// Autotranslated from cmd.c:4042
export async function get_adjacent_loc(prompt, emsg, x, y, cc, player) {
  let new_x, new_y;
  if (!getdir(prompt)) { pline1(Never_mind); return 0; }
  new_x = x + player.dx;
  new_y = y + player.dy;
  if (cc && isok(new_x, new_y)) { cc.x = new_x; cc.y = new_y; }
  else { if (emsg) pline1(emsg); return 0; }
  return 1;
}

// Autotranslated from cmd.c:4233
export function show_direction_keys(win, centerchar, nodiag) {
  let buf;
  if (!centerchar) centerchar = ' ';
  if (nodiag) {
    Sprintf(buf, " %s ", visctrl(cmd_from_func(do_move_north)));
    putstr(win, 0, buf);
    putstr(win, 0, " | ");
    Sprintf(buf, " %s- %c -%s", visctrl(cmd_from_func(do_move_west)), centerchar, visctrl(cmd_from_func(do_move_east)));
    putstr(win, 0, buf);
    putstr(win, 0, " | ");
    Sprintf(buf, " %s ", visctrl(cmd_from_func(do_move_south)));
    putstr(win, 0, buf);
  }
  else {
    Sprintf(buf, " %s %s %s", visctrl(cmd_from_func(do_move_northwest)), visctrl(cmd_from_func(do_move_north)), visctrl(cmd_from_func(do_move_northeast)));
    putstr(win, 0, buf);
    putstr(win, 0, " \\ | / ");
    Sprintf(buf, " %s- %c -%s", visctrl(cmd_from_func(do_move_west)), centerchar, visctrl(cmd_from_func(do_move_east)));
    putstr(win, 0, buf);
    putstr(win, 0, " / | \\ ");
    Sprintf(buf, " %s %s %s", visctrl(cmd_from_func(do_move_southwest)), visctrl(cmd_from_func(do_move_south)), visctrl(cmd_from_func(do_move_southeast)));
    putstr(win, 0, buf);
  }
}

// Autotranslated from cmd.c:4411
export function confdir(force_impairment, player) {
  if (force_impairment || u_maybe_impaired()) {
    let kmax = NODIAG(player.umonnum) ? (N_DIRS / 2) : N_DIRS, k =  dirs_ord;
    player.dx = xdir;
    player.dy = ydir;
  }
  return;
}

// Autotranslated from cmd.c:4424
export function directionname(dir) {
  let dirnames = [ "west", "northwest", "north", "northeast", "east", "southeast", "south", "southwest", "down", "up", ];
  if (dir < 0 || dir >= N_DIRS_Z) return "invalid";
  return dirnames;
}

// Autotranslated from cmd.c:4437
export function isok(x, y) {
  return x >= 1 && x <= COLNO - 1 && y >= 0 && y <= ROWNO - 1;
}

// Autotranslated from cmd.c:4635
export function there_cmd_menu_next2u(win, x, y, mod, act, map, player) {
  let K = 0, buf, typ = map.locations[x][y].typ, ttmp, mtmp;
  if (!next2u(x, y)) return K;
  if (IS_DOOR(typ)) {
    let key_or_pick, card, dm = map.locations[x][y].doormask;
    if ((dm & (D_CLOSED | D_LOCKED))) {
      mcmd_addmenu(win, MCMD_OPEN_DOOR, "Open the door"), ++K;
      key_or_pick = (carrying(SKELETON_KEY) || carrying(LOCK_PICK));
      card = (carrying(CREDIT_CARD) !== 0);
      if (key_or_pick || card) {
        Sprintf(buf, "%sunlock the door", key_or_pick ? "lock or " : "");
        mcmd_addmenu(win, MCMD_LOCK_DOOR, upstart(buf)), ++K;
      }
      mcmd_addmenu(win, MCMD_UNTRAP_DOOR, "Search the door for a trap"), ++K;
      mcmd_addmenu(win, MCMD_KICK_DOOR, "Kick the door"), ++K;
    }
    else if ((dm & D_ISOPEN) && (mod === CLICK_2)) {
      mcmd_addmenu(win, MCMD_CLOSE_DOOR, "Close the door"), ++K;
    }
  }
  if (typ <= SCORR) mcmd_addmenu(win, MCMD_SEARCH, "Search for secret doors"), ++K;
  if ((ttmp = t_at(x, y)) !== 0 && ttmp.tseen) {
    mcmd_addmenu(win, MCMD_LOOK_TRAP, "Examine trap"), ++K;
    if (ttmp.ttyp !== VIBRATING_SQUARE) mcmd_addmenu(win, MCMD_UNTRAP_TRAP, "Attempt to disarm trap"), ++K;
    mcmd_addmenu(win, MCMD_MOVE_DIR, "Move on the trap"), ++K;
  }
  if (map.locations[x][y].glyph === objnum_to_glyph(BOULDER)) mcmd_addmenu(win, MCMD_MOVE_DIR, "Push the boulder"), ++K;
  mtmp = m_at(x, y);
  if (mtmp && !canspotmon(mtmp)) mtmp = 0;
  if (mtmp && which_armor(mtmp, W_SADDLE)) {
    let mnam = x_monnam(mtmp, ARTICLE_THE,  0, SUPPRESS_SADDLE, false);
    if (!player.usteed) { Sprintf(buf, "Ride %s", mnam); mcmd_addmenu(win, MCMD_RIDE, buf), ++K; }
    Sprintf(buf, "Remove saddle from %s", mnam);
    mcmd_addmenu(win, MCMD_REMOVE_SADDLE, buf), ++K;
  }
  if (mtmp && can_saddle(mtmp) && !which_armor(mtmp, W_SADDLE) && carrying(SADDLE)) {
    Sprintf(buf, "Put saddle on %s", mon_nam(mtmp));
    mcmd_addmenu(win, MCMD_APPLY_SADDLE, buf), ++K;
  }
  if (mtmp && (mtmp.mpeaceful || mtmp.mtame)) {
    Sprintf(buf, "Talk to %s", mon_nam(mtmp));
    mcmd_addmenu(win, MCMD_TALK, buf), ++K;
    Sprintf(buf, "Swap places with %s", mon_nam(mtmp));
    mcmd_addmenu(win, MCMD_MOVE_DIR, buf), ++K;
    Sprintf(buf, "%s %s", !has_mgivenname(mtmp) ? "Name" : "Rename", mon_nam(mtmp));
    mcmd_addmenu(win, MCMD_NAME, buf), ++K;
  }
  if ((mtmp && !(mtmp.mpeaceful || mtmp.mtame)) || glyph_is_invisible(glyph_at(x, y))) {
    Sprintf(buf, "Attack %s", mtmp ? mon_nam(mtmp) : "unseen creature");
    mcmd_addmenu(win, MCMD_ATTACK_NEXT2U, buf), ++K;
     act = MCMD_ATTACK_NEXT2U;
  }
  else {
  }
  return K;
}

// Autotranslated from cmd.c:4735
export function there_cmd_menu_far(win, x, y, mod, player) {
  let K = 0;
  if (mod === CLICK_1) {
    if (linedup(player.x, player.y, x, y, 1) && dist2(player.x, player.y, x, y) < 18*18) mcmd_addmenu(win, MCMD_THROW_OBJ, "Throw something"), ++K;
    mcmd_addmenu(win, MCMD_TRAVEL, "Travel here"), ++K;
  }
  return K;
}

// Autotranslated from cmd.c:4750
export function there_cmd_menu_common(win, x, y, mod, act, player) {
  let K = 0;
  if (mod === CLICK_1 || mod === CLICK_2) {
    if (!u_at(x, y) || (player?.Upolyd || (player?.mtimedone > 0) || false) || glyph_at(x, y) !== hero_glyph) mcmd_addmenu(win, MCMD_LOOK_AT, "Look at map symbol"), ++K;
  }
  return K;
}

// Autotranslated from cmd.c:5010
export async function here_cmd_menu(player) {
  await there_cmd_menu(player.x, player.y, CLICK_1);
  return '\0';
}

// Autotranslated from cmd.c:5385
export async function readchar(player) {
  let ch, x = player.x, y = player.y, mod = 0;
  ch = readchar_core( x, y, mod);
  return ch;
}

// Autotranslated from cmd.c:5511
export function yn_func_menu_opt(win, key, text, def) {
  let any;
  any = cg.zeroany;
  any.a_char = key;
  add_menu(win, nul_glyphinfo, any, key, 0, ATR_NONE, NO_COLOR, text, (def === key) ? MENU_ITEMFLAGS_SELECTED : MENU_ITEMFLAGS_NONE);
}

// Autotranslated from cmd.c:5808
export function dummyfunction() {
  return ECMD_CANCEL;
}

// Autotranslated from cmd.c:2416
export function extcmds_getentry(i) {
  if (i < 0 || i > extcmdlist_length) return 0;
  return extcmdlist[i];
}

// Autotranslated from cmd.c:3338
export function key2txt(c, txt) {
  if (c === ' ') {
    Sprintf(txt, "<space>");
  }
  else if (c === '\x1b') {
    Sprintf(txt, "<esc>");
  }
  else if (c === '\n') {
    Sprintf(txt, "<enter>");
  }
  else if (c === '\x7f') {
    Sprintf(txt, "<del>");
  }
  else {
    Strcpy(txt, visctrl( c));
  }
  return txt;
}

// Autotranslated from cmd.c:3697
export function random_response(buf, sz) {
  let c, count = 0;
  for (; ; ) {
    c = randomkey();
    if (c === '\n') {
      break;
    }
    if (c === '\x1b') { count = 0; break; }
    if (count < sz - 1) buf[count++] = c;
  }
  buf[count] = '\x00';
}

// Autotranslated from cmd.c:154
export function json_write_escaped(fp, s) {
  let c;
  if (!s) { fputs("", fp); return; }
  while ((c =  s++) !== '\x00') {
    if (c === '"' || c === '\\') { fputc('\\', fp); fputc(c, fp); }
    else if (c >= 0x20 && c <= 0x7e) { fputc(c, fp); }
    else { fprintf(fp, "\\u%04x", c & 0xff); }
  }
}

// Autotranslated from cmd.c:773
export function doc_extcmd_flagstr(menuwin, efp) {
  let Abuf;
  if (!efp) {
    let qbuf;
    add_menu_str(menuwin, "[A] Command autocompletes");
    Sprintf(qbuf, "[m] Command accepts '%s' prefix", visctrl(cmd_from_func(do_reqmenu)));
    add_menu_str(menuwin, qbuf);
    return  0;
  }
  else {
    let mprefix = accept_menu_prefix(efp), autocomplete = (efp.flags & AUTOCOMPLETE) !== 0;
    let p = Abuf;
    if (mprefix || autocomplete) {
       p = '[';
      if (mprefix) p = 'm';
      if (autocomplete) p = 'A';
       p = ']';
    }
     p = '\x00';
    return Abuf;
  }
}
