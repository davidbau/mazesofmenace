// pager.js -- In-terminal text pager
// Displays long text documents inside the 80x24 terminal, with scrolling.
// Modeled after NetHack's built-in text display (pager.c).

import { TERMINAL_COLS, TERMINAL_ROWS, STAIRS, LADDER, FOUNTAIN, SINK, THRONE,
         ALTAR, GRAVE, POOL, LAVAPOOL, DOOR, IRONBARS, TREE,
         VERSION_STRING } from './config.js';
import { nhgetch } from './input.js';
import { CLR_GRAY, CLR_WHITE, CLR_GREEN, CLR_CYAN } from './display.js';

// Number of usable text rows (reserve 1 for status bar at bottom)
const PAGE_ROWS = TERMINAL_ROWS - 1;
const STATUS_LINE = TERMINAL_ROWS - 1;

// Display a text file in the terminal with paging.
// Saves and restores the terminal contents.
//
// Controls:
//   Space, Enter, j, down  = scroll down one page
//   b, k, up               = scroll up one page
//   q, ESC                 = quit
//   /                      = search
//   Home, g                = go to top
//   End, G                 = go to bottom
export async function showPager(display, text, title) {
    // Split text into lines, wrapping long lines to terminal width
    const lines = wrapText(text, TERMINAL_COLS);

    // Save entire terminal state
    const canSaveRestore = !!display?.grid;
    const saved = canSaveRestore ? saveTerminal(display) : null;

    let topLine = 0;
    let searchTerm = null;

    function render() {
        // Clear and draw text
        for (let r = 0; r < PAGE_ROWS; r++) {
            const lineIdx = topLine + r;
            display.clearRow(r);
            if (lineIdx < lines.length) {
                const line = lines[lineIdx];
                if (typeof display.setCell === 'function') {
                    for (let c = 0; c < line.length && c < TERMINAL_COLS; c++) {
                        const isHighlight = searchTerm && isSearchHit(line, c, searchTerm);
                        display.setCell(c, r, line[c], isHighlight ? CLR_CYAN : CLR_GRAY);
                    }
                } else {
                    display.putstr(0, r, line.substring(0, TERMINAL_COLS), CLR_GRAY);
                }
            }
        }

        // Status bar
        display.clearRow(STATUS_LINE);
        const pct = lines.length <= PAGE_ROWS ? '(All)'
            : topLine + PAGE_ROWS >= lines.length ? '(Bot)'
            : topLine === 0 ? '(Top)'
            : `(${Math.round(topLine / (lines.length - PAGE_ROWS) * 100)}%)`;
        const titleStr = title ? title + ' ' : '';
        const status = `${titleStr}-- ${pct} -- [q:quit  space:next  b:back  /:search]`;
        display.putstr(0, STATUS_LINE, status.substring(0, TERMINAL_COLS), CLR_GREEN);
    }

    render();

    // Input loop
    while (true) {
        const ch = await nhgetch();
        const c = String.fromCharCode(ch);

        if (c === 'q' || ch === 27) {
            // Quit
            break;
        } else if (c === ' ' || ch === 13 || c === 'j' || ch === 106) {
            // Next page (space, enter, j)
            if (topLine + PAGE_ROWS < lines.length) {
                topLine = Math.min(topLine + PAGE_ROWS, lines.length - PAGE_ROWS);
                render();
            }
        } else if (c === 'b' || c === 'k') {
            // Previous page
            if (topLine > 0) {
                topLine = Math.max(topLine - PAGE_ROWS, 0);
                render();
            }
        } else if (c === 'g' || ch === 36) {
            // Home - first page (36 = Home key mapped)
            topLine = 0;
            render();
        } else if (c === 'G') {
            // End - last page
            topLine = Math.max(0, lines.length - PAGE_ROWS);
            render();
        } else if (c === '/') {
            // Search
            searchTerm = await getSearchTerm(display);
            if (searchTerm) {
                const found = findNext(lines, topLine + 1, searchTerm);
                if (found >= 0) {
                    topLine = Math.min(found, Math.max(0, lines.length - PAGE_ROWS));
                }
            }
            render();
        } else if (c === 'n' && searchTerm) {
            // Next search match
            const found = findNext(lines, topLine + 1, searchTerm);
            if (found >= 0) {
                topLine = Math.min(found, Math.max(0, lines.length - PAGE_ROWS));
            }
            render();
        }
        // Arrow keys come through as hjkl from input.js
        // h/l = 104/108 — ignore horizontal
        // Down arrow -> j (106), Up arrow -> k (107) — handled above
    }

    // Restore terminal
    if (saved) {
        restoreTerminal(display, saved);
    }
}

// Wrap text to fit terminal width
function wrapText(text, width) {
    const rawLines = text.split('\n');
    const result = [];
    for (const raw of rawLines) {
        if (raw.length <= width) {
            result.push(raw);
        } else {
            // Hard-wrap at width boundary
            for (let i = 0; i < raw.length; i += width) {
                result.push(raw.substring(i, i + width));
            }
        }
    }
    return result;
}

// Save entire terminal state
function saveTerminal(display) {
    const saved = [];
    for (let r = 0; r < TERMINAL_ROWS; r++) {
        saved[r] = [];
        for (let c = 0; c < TERMINAL_COLS; c++) {
            saved[r][c] = { ...display.grid[r][c] };
        }
    }
    return saved;
}

// Restore terminal state
function restoreTerminal(display, saved) {
    for (let r = 0; r < TERMINAL_ROWS; r++) {
        for (let c = 0; c < TERMINAL_COLS; c++) {
            const cell = saved[r][c];
            display.setCell(c, r, cell.ch, cell.color);
        }
    }
}

// Simple inline search prompt on the status line
async function getSearchTerm(display) {
    display.clearRow(STATUS_LINE);
    display.putstr(0, STATUS_LINE, '/', CLR_GREEN);

    let term = '';
    while (true) {
        const ch = await nhgetch();
        if (ch === 13 || ch === 10) {
            return term || null;
        } else if (ch === 27) {
            return null;
        } else if (ch === 8 || ch === 127) {
            if (term.length > 0) {
                term = term.slice(0, -1);
                display.clearRow(STATUS_LINE);
                display.putstr(0, STATUS_LINE, '/' + term, CLR_GREEN);
            }
        } else if (ch >= 32 && ch < 127) {
            term += String.fromCharCode(ch);
            display.putstr(0, STATUS_LINE, '/' + term, CLR_GREEN);
        }
    }
}

// Find next line containing search term (case-insensitive)
function findNext(lines, startLine, term) {
    const lower = term.toLowerCase();
    for (let i = startLine; i < lines.length; i++) {
        if (lines[i].toLowerCase().includes(lower)) {
            return i;
        }
    }
    // Wrap around
    for (let i = 0; i < startLine; i++) {
        if (lines[i].toLowerCase().includes(lower)) {
            return i;
        }
    }
    return -1;
}

// Check if position c in line is part of a search match (for highlighting)
function isSearchHit(line, c, term) {
    const lower = line.toLowerCase();
    const lowerTerm = term.toLowerCase();
    const start = c - lowerTerm.length + 1;
    for (let i = Math.max(0, start); i <= c; i++) {
        if (lower.substring(i, i + lowerTerm.length) === lowerTerm) {
            return true;
        }
    }
    return false;
}

// -----------------------------------------------------------------------
// Pager-related command handlers (moved from commands.js)
// C ref: pager.c — dolook, dowhatis, dowhatdoes, dohelp, dohistory, etc.
// -----------------------------------------------------------------------

// Handle looking at what's here
// C ref: cmd.c dolook()
export function handleLook(player, map, display) {
    const loc = map.at(player.x, player.y);
    const objs = map.objectsAt(player.x, player.y);

    let msg = '';
    if (loc) {
        // Describe terrain features - C ref: cmd.c dolook() describes current location
        if (loc.typ === STAIRS && loc.flags === 1) msg += 'There is a staircase up out of the dungeon here. ';
        else if (loc.typ === STAIRS && loc.flags === 0) msg += 'There is a staircase down here. ';
        else if (loc.typ === LADDER && loc.flags === 1) msg += 'There is a ladder up here. ';
        else if (loc.typ === LADDER && loc.flags === 0) msg += 'There is a ladder down here. ';
        else if (loc.typ === FOUNTAIN) msg += 'There is a fountain here. ';
        else if (loc.typ === SINK) msg += 'There is a sink here. ';
        else if (loc.typ === THRONE) msg += 'There is a throne here. ';
        else if (loc.typ === ALTAR) msg += 'There is an altar here. ';
        else if (loc.typ === GRAVE) msg += 'There is a grave here. ';
        else if (loc.typ === POOL) msg += 'There is a pool of water here. ';
        else if (loc.typ === LAVAPOOL) msg += 'There is molten lava here. ';
        else if (loc.typ === DOOR && loc.flags > 0) msg += 'There is an open door here. ';
        else if (loc.typ === DOOR && loc.flags === 0) msg += 'There is a closed door here. ';
        else if (loc.typ === IRONBARS) msg += 'There are iron bars here. ';
        else if (loc.typ === TREE) msg += 'There is a tree here. ';
    }

    if (objs.length > 0) {
        msg += `Things that are here: ${objs.map(o => o.name).join(', ')}`;
    }

    if (!msg) msg = 'You see no objects here.';
    display.putstr_message(msg.substring(0, 79));
    return { moved: false, tookTime: false };
}

// Handle previous messages
// C ref: cmd.c doprev_message() -> topl.c tty_doprev_message()
// Default mode 's' (single): shows one message at a time on top line
export async function handlePrevMessages(display) {
    const messages = display.messages || [];

    if (messages.length === 0) {
        display.putstr_message('No previous messages.');
        return { moved: false, tookTime: false };
    }

    // C tty mode 's': show one message each Ctrl+P press.
    // Keep an index so repeated Ctrl+P cycles backward without blocking input.
    let messageIndex = Number.isInteger(display.prevMessageCycleIndex)
        ? display.prevMessageCycleIndex
        : (messages.length - 1);
    if (messageIndex < 0 || messageIndex >= messages.length) {
        messageIndex = messages.length - 1;
    }
    display.putstr_message(messages[messageIndex]);
    display.prevMessageCycleIndex = (messageIndex - 1 + messages.length) % messages.length;

    return { moved: false, tookTime: false };
}

// View map prompt
// C ref: cmd.c dooverview()
export async function handleViewMapPrompt(game) {
    const { display, map, player, fov, flags } = game;
    const lines = [
        'View which?',
        '',
        'a * known map without monsters, objects, and traps',
        'b - known map without monsters and objects',
        'c - known map without monsters',
        '(end)',
    ];

    display.clearScreen();
    display.renderMap(map, player, fov, flags);
    if (typeof display.renderStatus === 'function') {
        display.renderStatus(player);
    }
    for (let i = 0; i < lines.length && i < display.rows; i++) {
        const text = lines[i].substring(0, Math.max(0, display.cols - 28));
        const attr = (i === 0) ? 1 : 0;
        display.putstr(28, i, ' '.repeat(Math.max(0, display.cols - 28)));
        display.putstr(28, i, text, undefined, attr);
    }

    await nhgetch();
    display.clearScreen();
    display.renderMap(map, player, fov, flags);
    if (typeof display.renderStatus === 'function') {
        display.renderStatus(player);
    }
    if (typeof display.clearRow === 'function') display.clearRow(0);
    display.topMessage = null;
    display.messageNeedsMore = false;
    return { moved: false, tookTime: false };
}

// Data file cache (same pattern as guidebook)
const dataFileCache = {};

// Fetch a data file from dat/ directory with caching
async function fetchDataFile(filename) {
    if (dataFileCache[filename]) return dataFileCache[filename];
    try {
        const resp = await fetch(filename);
        if (!resp.ok) throw new Error(`HTTP ${resp.status}`);
        const text = await resp.text();
        dataFileCache[filename] = text;
        return text;
    } catch (e) {
        return null;
    }
}

// Command descriptions for & (whatdoes)
// C ref: pager.c dowhatdoes() / dat/cmdhelp
const COMMAND_DESCRIPTIONS = {
    '?': 'Display one of several informative help texts.',
    '/': 'Tell what a map symbol represents.',
    '&': 'Tell what a command does.',
    '<': 'Go up a staircase.',
    '>': 'Go down a staircase.',
    '.': 'Rest, do nothing for one turn.',
    ',': 'Pick up things at the current location.',
    ':': 'Look at what is here.',
    ';': 'Look at what is somewhere else.',
    '\\': 'Show what types of objects have been discovered.',
    '#': 'Perform an extended command.',
    'a': 'Apply (use) a tool.',
    'c': 'Close a door.',
    'd': 'Drop an item. d7a: drop seven items of object a.',
    'e': 'Eat something.',
    'i': 'Show your inventory.',
    'o': 'Open a door.',
    'q': 'Drink (quaff) a potion.',
    'P': 'Put on a ring or other accessory.',
    's': 'Search for secret doors and traps around you.',
    'w': 'Wield a weapon. w- means wield bare hands.',
    'S': 'Save the game.',
    'T': 'Take off armor.',
    'V': 'Display the version and history of the game.',
    'W': 'Wear armor.',
};

// Symbol descriptions for / (whatis)
// C ref: dat/help symbol legend
const SYMBOL_DESCRIPTIONS = {
    '-': 'wall of a room, or an open door',
    '|': 'wall of a room, or an open door',
    '.': 'floor of a room, or a doorway',
    '#': 'a corridor, or iron bars, or a tree',
    '>': 'stairs down: a way to the next level',
    '<': 'stairs up: a way to the previous level',
    '@': 'you (usually), or another human',
    ')': 'a weapon',
    '[': 'a suit or piece of armor',
    '%': 'something edible (not necessarily healthy)',
    '/': 'a wand',
    '=': 'a ring',
    '?': 'a scroll',
    '!': 'a potion',
    '(': 'a useful item (pick-axe, key, lamp...)',
    '$': 'a pile of gold',
    '*': 'a gem or rock',
    '+': 'a closed door, or a spellbook',
    '^': 'a trap (once you detect it)',
    '"': 'an amulet, or a spider web',
    '0': 'an iron ball',
    '_': 'an altar, or an iron chain',
    '{': 'a fountain',
    '}': 'a pool of water or moat or lava',
    '\\': 'an opulent throne',
    '`': 'a boulder or statue',
    ' ': 'dark part of a room, or solid rock',
    '\u00b7': 'floor of a room (middle dot)',
};

// Handle help (?)
// C ref: pager.c dohelp() -> help_menu_items[]
export async function handleHelp(game) {
    const { display } = game;

    // Build menu lines matching C's help menu structure
    const menuLines = [
        ' Select one item:',
        '',
        ' a - About NetHack (version information).',
        ' b - Long description of the game and commands.',
        ' c - List of game commands.',
        ' d - Concise history of NetHack.',
        ' e - Info on a character in the game display.',
        ' f - Info on what a given key does.',
        ' g - Longer explanation of game options.',
        ' h - Full list of keyboard commands.',
        ' i - List of extended commands.',
        ' j - The NetHack Guidebook.',
    ];
    if (game.wizard) {
        menuLines.push(' w - List of wizard-mode commands.');
    }
    menuLines.push(' (end)');

    display.renderChargenMenu(menuLines, true);

    const ch = await nhgetch();
    const c = String.fromCharCode(ch);

    if (c === 'a') {
        // About NetHack
        display.putstr_message(`${VERSION_STRING}`);
    } else if (c === 'b') {
        // Long description
        const text = await fetchDataFile('dat/help.txt');
        if (text) {
            await showPager(display, text, 'Long Description');
        } else {
            display.putstr_message('Failed to load help text.');
        }
    } else if (c === 'c') {
        // List of game commands
        const text = await fetchDataFile('dat/hh.txt');
        if (text) {
            await showPager(display, text, 'Game Commands');
        } else {
            display.putstr_message('Failed to load command list.');
        }
    } else if (c === 'd') {
        // History
        const text = await fetchDataFile('dat/history.txt');
        if (text) {
            await showPager(display, text, 'History of NetHack');
        } else {
            display.putstr_message('Failed to load history.');
        }
    } else if (c === 'e') {
        // Whatis (same as /)
        return await handleWhatis(game);
    } else if (c === 'f') {
        // Whatdoes (same as &)
        return await handleWhatdoes(game);
    } else if (c === 'g') {
        // Game options
        const text = await fetchDataFile('dat/opthelp.txt');
        if (text) {
            await showPager(display, text, 'Game Options');
        } else {
            display.putstr_message('Failed to load options help.');
        }
    } else if (c === 'h') {
        // Full list of keyboard commands
        await showPager(display, keyHelpText, 'Key Bindings');
    } else if (c === 'i') {
        // Extended commands list
        await showPager(display, extendedCommandsText, 'Extended Commands');
    } else if (c === 'j') {
        // Guidebook
        await showGuidebook(display);
    } else if (c === 'w' && game.wizard) {
        // Wizard help
        const text = await fetchDataFile('dat/wizhelp.txt');
        if (text) {
            await showPager(display, text, 'Wizard Mode Commands');
        } else {
            display.putstr_message('Failed to load wizard help.');
        }
    }
    // ESC, q, or anything else = dismiss

    return { moved: false, tookTime: false };
}

// Inline key bindings text for help option 'h'
const keyHelpText = [
    '                    NetHack Command Reference',
    '',
    ' Movement:',
    '   y k u      Also: arrow keys, or numpad',
    '    \\|/',
    '   h-.-l      Shift + direction = run',
    '    /|\\',
    '   b j n',
    '',
    ' Actions:',
    '   .  wait/rest           s  search adjacent',
    '   ,  pick up item        d  drop item',
    '   o  open door           c  close door',
    '   >  go downstairs       <  go upstairs',
    '   e  eat food            q  quaff potion',
    '   w  wield weapon        W  wear armor',
    '   T  take off armor      i  inventory',
    '   :  look here           ;  identify position',
    '',
    ' Information:',
    '   ?    help menu',
    '   /    identify a map symbol (whatis)',
    '   &    describe what a key does (whatdoes)',
    '   \\    show discovered object types',
    '   V    version and history of the game',
    '',
    ' Other:',
    '   S    save game',
    '   #    extended command',
    '   ^P   previous messages',
    '   ^R   redraw screen',
    '   ^D   kick',
    '   ^C   quit',
    '',
    ' In pager (guidebook, help):',
    '   space/enter  next page     b  previous page',
    '   /  search    n  next match',
    '   g  first page              G  last page',
    '   q/ESC  exit',
].join('\n');

// Extended commands list text for help option 'i'
const extendedCommandsText = [
    '         Extended Commands',
    '',
    ' #force   M-f   force a locked chest with your weapon',
    ' #loot    M-l   loot a container',
    ' #name          name an object or level',
    ' #quit          quit the game without saving',
    ' #levelchange   change dungeon level (debug mode)',
    ' #map           reveal entire map (debug mode)',
    ' #teleport      teleport to coordinates (debug mode)',
    ' #genesis       create a monster by name (debug mode)',
].join('\n');

// Handle / (whatis) command
// C ref: pager.c dowhatis()
export async function handleWhatis(game) {
    const { display } = game;

    display.putstr_message('What do you want to identify? [type a symbol or ESC]');
    const ch = await nhgetch();

    if (ch === 27) {
        // ESC - cancel
        return { moved: false, tookTime: false };
    }

    const c = String.fromCharCode(ch);

    // Check for letter - could be a monster
    if ((c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z')) {
        display.putstr_message(`'${c}': a monster (or straddling the letter range).`);
    } else if (SYMBOL_DESCRIPTIONS[c]) {
        display.putstr_message(`'${c}': ${SYMBOL_DESCRIPTIONS[c]}.`);
    } else {
        display.putstr_message(`I don't know what '${c}' represents.`);
    }

    return { moved: false, tookTime: false };
}

// Handle & (whatdoes) command
// C ref: pager.c dowhatdoes()
export async function handleWhatdoes(game) {
    const { display } = game;

    display.putstr_message('What command?');
    const ch = await nhgetch();

    if (ch === 27) {
        return { moved: false, tookTime: false };
    }

    const c = String.fromCharCode(ch);
    let desc;

    // Check for control characters
    if (ch < 32) {
        const ctrlChar = '^' + String.fromCharCode(ch + 64);
        const ctrlDescs = {
            '^C': 'Quit the game.',
            '^D': 'Kick something (usually a door).',
            '^P': 'Repeat previous message (consecutive ^P\'s show earlier ones).',
            '^R': 'Redraw the screen.',
        };
        if (game.wizard) {
            ctrlDescs['^F'] = 'Map the level (wizard mode).';
            ctrlDescs['^G'] = 'Create a monster (wizard mode).';
            ctrlDescs['^I'] = 'Identify items in pack (wizard mode).';
            ctrlDescs['^T'] = 'Teleport (wizard mode).';
            ctrlDescs['^V'] = 'Level teleport (wizard mode).';
            ctrlDescs['^W'] = 'Wish (wizard mode).';
        }
        desc = ctrlDescs[ctrlChar];
        if (desc) {
            display.putstr_message(`${ctrlChar}: ${desc}`);
        } else {
            display.putstr_message(`${ctrlChar}: unknown command.`);
        }
    } else if (COMMAND_DESCRIPTIONS[c]) {
        display.putstr_message(`'${c}': ${COMMAND_DESCRIPTIONS[c]}`);
    } else {
        display.putstr_message(`'${c}': unknown command.`);
    }

    return { moved: false, tookTime: false };
}

// Handle V (history) command
// C ref: pager.c dohistory()
export async function handleHistory(game) {
    const { display } = game;
    const text = await fetchDataFile('dat/history.txt');
    if (text) {
        await showPager(display, text, 'History of NetHack');
    } else {
        display.putstr_message('Failed to load history.');
    }
    return { moved: false, tookTime: false };
}

// Guidebook text cache
let guidebookText = null;

// Fetch and display the NetHack Guidebook
async function showGuidebook(display) {
    if (!guidebookText) {
        display.putstr_message('Loading Guidebook...');
        try {
            const resp = await fetch('Guidebook.txt');
            if (!resp.ok) throw new Error(`HTTP ${resp.status}`);
            guidebookText = await resp.text();
        } catch (e) {
            display.putstr_message('Failed to load Guidebook.');
            return;
        }
    }
    await showPager(display, guidebookText, 'NetHack Guidebook');
}
