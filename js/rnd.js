// Autogenerated translator module for currently-unmapped C source outputs.
// Contents are syntax-validated emitted functions; wiring into runtime is separate.

// TRANSLATOR: AUTO (rnd.c:47)
export function rng_log_set_caller(file, line, func) {
  rng_caller_file = file;
  rng_caller_line = line;
  rng_caller_func = func;
}

// TRANSLATOR: AUTO (rnd.c:55)
export function rng_log_get_call_count() {
  return rng_call_count;
}

// TRANSLATOR: AUTO (rnd.c:61)
export function rng_log_write(func, args, result) {
  if (!rng_logfile) return;
  rng_call_count++;
  if (rng_caller_file) {
    if (rng_caller_func) {
      fprintf(rng_logfile, "%d %s(%s) = %d @ %s(%s:%d)\n", rng_call_count, func, args, result, rng_caller_func, rng_caller_file, rng_caller_line);
    }
    else {
      fprintf(rng_logfile, "%d %s(%s) = %d @ %s:%d\n", rng_call_count, func, args, result, rng_caller_file, rng_caller_line);
    }
  }
  else {
    fprintf(rng_logfile, "%d %s(%s) = %d\n", rng_call_count, func, args, result);
  }
}

// TRANSLATOR: AUTO (rnd.c:102)
export function midlog_enter(fn, file, line, caller) {
  if (!rng_logfile) return;
  if (midlog_depth < MIDLOG_STACK_SIZE) midlog_stack[midlog_depth] = rng_call_count;
  midlog_depth++;
  fprintf(rng_logfile, ">%s @ %s(%s:%d)\n", fn, caller, file, line);
}

// TRANSLATOR: AUTO (rnd.c:113)
export function midlog_exit_int(fn, result, file, line, caller) {
  if (!rng_logfile) return;
  --midlog_depth;
  let entry = (midlog_depth >= 0 && midlog_depth < MIDLOG_STACK_SIZE) ? midlog_stack[midlog_depth] : 0;
  fprintf(rng_logfile, "<%s=%d #%d-%d @ %s(%s:%d)\n", fn, result, entry + 1, rng_call_count, caller, file, line);
}

// TRANSLATOR: AUTO (rnd.c:126)
export function midlog_exit_void(fn, file, line, caller) {
  if (!rng_logfile) return;
  --midlog_depth;
  let entry = (midlog_depth >= 0 && midlog_depth < MIDLOG_STACK_SIZE) ? midlog_stack[midlog_depth] : 0;
  fprintf(rng_logfile, "<%s #%d-%d @ %s(%s:%d)\n", fn, entry + 1, rng_call_count, caller, file, line);
}

// TRANSLATOR: AUTO (rnd.c:139)
export function midlog_exit_ptr(fn, result, file, line, caller) {
  result;
  if (!rng_logfile) return;
  --midlog_depth;
  let entry = (midlog_depth >= 0 && midlog_depth < MIDLOG_STACK_SIZE) ? midlog_stack[midlog_depth] : 0;
  fprintf(rng_logfile, "<%s #%d-%d @ %s(%s:%d)\n", fn, entry + 1, rng_call_count, caller, file, line);
}

// TRANSLATOR: AUTO (rnd.c:160)
export function event_log(fmt) {
  let ap;
  if (!rng_logfile) return;
  fputc('^', rng_logfile);
  va_start(ap, fmt);
  vfprintf(rng_logfile, fmt, ap);
  va_end(ap);
  fputc('\n', rng_logfile);
}

// TRANSLATOR: AUTO (rnd.c:350)
export function rnd_on_display_rng(x) {
  return rn2_on_display_rng(x) + 1;
}

// TRANSLATOR: AUTO (rnd.c:501)
export function shuffle_int_array(indices, count) {
  let i, iswap, temp;
  for (i = count - 1; i > 0; i--) {
    if ((iswap = rn2(i + 1)) === i) {
      continue;
    }
    temp = indices[i];
    indices[i] = indices[iswap];
    indices[iswap] = temp;
  }
}

// TRANSLATOR: AUTO (rnd.c:36)
export function rng_log_init() {
  let logpath = getenv("NETHACK_RNGLOG");
  if (logpath && logpath) {
    rng_logfile = fopen(logpath, "w");
    if (rng_logfile) setvbuf(rng_logfile, null, _IOLBF, 0);
  }
}
