// weapon.js -- To-hit/damage bonuses, weapon skill system, monster weapon AI
// cf. weapon.c — hitval, dmgval, abon, dbon, skill system, select_hwep/rwep

import { objectData, WEAPON_CLASS, TOOL_CLASS, GEM_CLASS, BALL_CLASS, CHAIN_CLASS,
         CREAM_PIE, CORPSE, EGG, BOULDER,
         IRON_CHAIN, CROSSBOW_BOLT, MORNING_STAR, PARTISAN, RUNESWORD,
         ELVEN_BROADSWORD, BROADSWORD, FLAIL, RANSEUR, VOULGE,
         ACID_VENOM, HALBERD, SPETUM, BATTLE_AXE, BARDICHE, TRIDENT,
         TSURUGI, DWARVISH_MATTOCK, TWO_HANDED_SWORD,
         MACE, SILVER_MACE, WAR_HAMMER,
         BILL_GUISARME, GUISARME, LUCERN_HAMMER, LEATHER,
         KATANA, UNICORN_HORN, CRYSKNIFE, LONG_SWORD, SCIMITAR, SILVER_SABER,
         SHORT_SWORD, ELVEN_SHORT_SWORD, DWARVISH_SHORT_SWORD, ORCISH_SHORT_SWORD,
         AXE, BULLWHIP, QUARTERSTAFF, JAVELIN, AKLYS, CLUB, PICK_AXE, RUBBER_HOSE,
         SILVER_DAGGER, ELVEN_DAGGER, DAGGER, ORCISH_DAGGER, ATHAME, SCALPEL,
         KNIFE, WORM_TOOTH,
         DWARVISH_SPEAR, SILVER_SPEAR, ELVEN_SPEAR, SPEAR, ORCISH_SPEAR,
         SHURIKEN, YA, SILVER_ARROW, ELVEN_ARROW, ARROW, ORCISH_ARROW,
         DART, FLINT, ROCK, LOADSTONE, LUCKSTONE,
         GLAIVE, BEC_DE_CORBIN, FAUCHARD, LANCE, GRAPPLING_HOOK,
         BOW, ELVEN_BOW, ORCISH_BOW, YUMI, SLING, CROSSBOW,
       } from './objects.js';
import { rnd, d, rn2 } from './rng.js';
import { mon_hates_blessings, mon_hates_silver, mon_hates_light,
         thick_skinned, strongmonst, is_giant, resists_ston, likes_gems,
         is_animal, is_mindless, touch_petrifies, attacktype, x_monnam,
       } from './mondata.js';
import { MZ_LARGE, S_EEL, S_SNAKE, S_XORN, S_DRAGON, S_JABBERWOCK,
         S_NAGA, S_WORM_TAIL, S_KOP, S_GIANT,
         PM_BALROG, AT_WEAP,
       } from './monsters.js';
import { mons } from './monsters.js';
import { W_ARMS, W_ARMG, W_WEP, which_armor } from './worn.js';
import { dist2 } from './monutil.js';
import { couldsee } from './vision.js';

// ============================================================================
// Skill constants — cf. objclass.h
// ============================================================================
// Weapon sub-class constants matching objects.js sub field
const P_NONE = 0;
const P_DAGGER = 1;
const P_KNIFE = 2;
const P_AXE = 3;
const P_PICK_AXE = 4;
const P_SHORT_SWORD = 5;
const P_BROAD_SWORD = 6;
const P_LONG_SWORD = 7;
const P_TWO_HANDED_SWORD = 8;
const P_SABER = 9;
const P_CLUB = 10;
const P_MACE = 11;
const P_MORNING_STAR = 12;
const P_FLAIL = 13;
const P_HAMMER = 14;
const P_QUARTERSTAFF = 15;
const P_POLEARMS = 16;
const P_SPEAR = 17;
const P_TRIDENT = 18;
const P_LANCE = 19;
export const P_BOW = 20;
const P_SLING = 21;
const P_CROSSBOW = 22;
const P_DART = 23;
const P_SHURIKEN = 24;
const P_BOOMERANG = 25;
const P_WHIP = 26;
const P_UNICORN_HORN = 27;

// Spell skills
export const P_ATTACK_SPELL = 28;
export const P_HEALING_SPELL = 29;
export const P_DIVINATION_SPELL = 30;
export const P_ENCHANTMENT_SPELL = 31;
export const P_CLERIC_SPELL = 32;
export const P_ESCAPE_SPELL = 33;
export const P_MATTER_SPELL = 34;

// Fighting skills
export const P_BARE_HANDED_COMBAT = 35;
export const P_TWO_WEAPON_COMBAT = 36;
export const P_RIDING = 37;

export const P_FIRST_WEAPON = P_DAGGER;
export const P_LAST_WEAPON = P_UNICORN_HORN;
export const P_FIRST_SPELL = P_ATTACK_SPELL;
export const P_LAST_SPELL = P_MATTER_SPELL;
export const P_FIRST_H_TO_H = P_BARE_HANDED_COMBAT;
export const P_LAST_H_TO_H = P_RIDING;
export const P_NUM_SKILLS = 38;

// Skill levels
export const P_ISRESTRICTED = 0;
export const P_UNSKILLED = 1;
export const P_BASIC = 2;
export const P_SKILLED = 3;
export const P_EXPERT = 4;
export const P_MASTER = 5;
export const P_GRAND_MASTER = 6;

// Monster weapon_check states
export const NO_WEAPON_WANTED = 0;
export const NEED_WEAPON = 1;
export const NEED_HTH_WEAPON = 2;
export const NEED_RANGED_WEAPON = 3;
export const NEED_PICK_AXE = 4;
export const NEED_AXE = 5;
export const NEED_PICK_OR_AXE = 6;

// BOLT_LIM for distance checks
const BOLT_LIM = 8;
const AKLYS_LIM = BOLT_LIM / 2;

// Hero skill state (C: P_SKILL/P_MAX_SKILL/P_ADVANCE).
let skillSystemActive = false;
const heroSkill = new Array(P_NUM_SKILLS).fill(P_ISRESTRICTED);
const heroMaxSkill = new Array(P_NUM_SKILLS).fill(P_ISRESTRICTED);
const heroSkillAdvance = new Array(P_NUM_SKILLS).fill(0);

// ============================================================================
// hitval — cf. weapon.c:149
// ============================================================================
export function hitval(otmp, mon) {
    if (!otmp) return 0;
    let tmp = 0;
    const info = objectData[otmp.otyp];
    if (!info) return 0;
    const Is_weapon = (info.oc_class === WEAPON_CLASS || info.weptool);

    if (Is_weapon) tmp += (otmp.spe || 0);
    tmp += (info.oc1 || 0);

    if (mon) {
        const ptr = mon.type || mon.data || {};
        if (Is_weapon && otmp.blessed && mon_hates_blessings(mon))
            tmp += 2;
        const mlet = ptr.mlet;
        if (info.sub === P_SPEAR && isKebabable(mlet))
            tmp += 2;
        if (info.sub === P_TRIDENT && ptr.swim) {
            if (mlet === S_EEL || mlet === S_SNAKE)
                tmp += 2;
        }
        if (info.sub === P_PICK_AXE && ptr.passes_walls && ptr.thick_skinned)
            tmp += 2;
    }

    return tmp;
}

function isKebabable(mlet) {
    return mlet === S_XORN || mlet === S_DRAGON || mlet === S_JABBERWOCK
        || mlet === S_NAGA || mlet === S_WORM_TAIL
        || mlet === S_SNAKE;
}

// ============================================================================
// dmgval — cf. weapon.c:216
// ============================================================================
export function dmgval(otmp, mon) {
    if (!otmp) return 0;
    const otyp = otmp.otyp;
    const info = objectData[otyp];
    if (!info) return 0;
    if (otyp === CREAM_PIE) return 0;

    const ptr = mon?.type || mon?.data || {};
    const isLarge = (ptr.msize ?? 0) >= MZ_LARGE;
    let tmp = 0;

    if (isLarge) {
        if (info.ldam) tmp = rnd(info.ldam);
        switch (otyp) {
        case IRON_CHAIN: case CROSSBOW_BOLT: case MORNING_STAR:
        case PARTISAN: case RUNESWORD: case ELVEN_BROADSWORD: case BROADSWORD:
            tmp++; break;
        case FLAIL: case RANSEUR: case VOULGE:
            tmp += rnd(4); break;
        case ACID_VENOM: case HALBERD: case SPETUM:
            tmp += rnd(6); break;
        case BATTLE_AXE: case BARDICHE: case TRIDENT:
            tmp += d(2, 4); break;
        case TSURUGI: case DWARVISH_MATTOCK: case TWO_HANDED_SWORD:
            tmp += d(2, 6); break;
        }
    } else {
        if (info.sdam) tmp = rnd(info.sdam);
        switch (otyp) {
        case IRON_CHAIN: case CROSSBOW_BOLT: case MACE: case SILVER_MACE:
        case WAR_HAMMER: case FLAIL: case SPETUM: case TRIDENT:
            tmp++; break;
        case BATTLE_AXE: case BARDICHE: case BILL_GUISARME: case GUISARME:
        case LUCERN_HAMMER: case MORNING_STAR: case RANSEUR:
        case BROADSWORD: case ELVEN_BROADSWORD: case RUNESWORD: case VOULGE:
            tmp += rnd(4); break;
        case ACID_VENOM:
            tmp += rnd(6); break;
        }
    }

    const Is_weapon = (info.oc_class === WEAPON_CLASS || info.weptool);
    if (Is_weapon) {
        tmp += (otmp.spe || 0);
        if (tmp < 0) tmp = 0;
    }

    if (info.material !== undefined && info.material <= LEATHER
        && thick_skinned(ptr))
        tmp = 0;

    if (Is_weapon || info.oc_class === GEM_CLASS || info.oc_class === BALL_CLASS
        || info.oc_class === CHAIN_CLASS) {
        let bonus = 0;
        if (mon && otmp.blessed && mon_hates_blessings(mon))
            bonus += rnd(4);
        if (info.sub === P_AXE && ptr.body === 'wood')
            bonus += rnd(4);
        if (mon && info.material === 14 /* SILVER */ && mon_hates_silver(mon))
            bonus += rnd(20);
        tmp += bonus;
    }

    return Math.max(tmp, 0);
}

// C ref: weapon.c special_dmgval() — unarmed blessed/silver damage.
export function special_dmgval(mon, obj = null) {
    let bonus = 0;
    if (obj && obj.blessed && mon_hates_blessings(mon)) bonus += rnd(4);
    const mat = obj ? objectData[obj.otyp]?.material : null;
    if (mat === 14 /* SILVER */ && mon_hates_silver(mon)) bonus += rnd(20);
    return bonus;
}

// C ref: weapon.c silver_sears() — message/effect helper.
export function silver_sears(mon, display) {
    if (!mon || !display) return false;
    if (!mon_hates_silver(mon)) return false;
    display.putstr_message(`The silver sears ${x_monnam(mon)}!`);
    return true;
}

// ============================================================================
// abon — cf. weapon.c:950
// ============================================================================
export function abon(str, dex, level) {
    let sbon;
    if (str < 6) sbon = -2;
    else if (str < 8) sbon = -1;
    else if (str < 17) sbon = 0;
    else if (str <= 18) sbon = 1;
    else if (str < 22) sbon = 2;
    else sbon = 3;
    sbon += (level < 3) ? 1 : 0;
    if (dex < 4) return sbon - 3;
    if (dex < 6) return sbon - 2;
    if (dex < 8) return sbon - 1;
    if (dex < 14) return sbon;
    return sbon + dex - 14;
}

// ============================================================================
// dbon — cf. weapon.c:988
// ============================================================================
export function dbon(str) {
    if (str < 6) return -1;
    if (str < 16) return 0;
    if (str < 18) return 1;
    if (str === 18) return 2;
    if (str <= 20) return 3;
    if (str <= 22) return 4;
    if (str < 25) return 5;
    return 6;
}

// ============================================================================
// weapon_hit_bonus / weapon_dam_bonus — GATED STUBS
// ============================================================================
// These return 0 (P_BASIC equivalent) until Phase 5 activates them.
export function weapon_hit_bonus(weapon) {
    if (!skillSystemActive) return 0;
    const skill = weapon_type(weapon);
    const level = heroSkill[skill] || P_UNSKILLED;
    switch (level) {
    case P_UNSKILLED: return -4;
    case P_BASIC: return 0;
    case P_SKILLED: return 2;
    case P_EXPERT: return 3;
    case P_MASTER: return 3;
    case P_GRAND_MASTER: return 3;
    default: return 0;
    }
    return 0;
}

export function weapon_dam_bonus(weapon) {
    if (!skillSystemActive) return 0;
    const skill = weapon_type(weapon);
    const level = heroSkill[skill] || P_UNSKILLED;
    switch (level) {
    case P_UNSKILLED: return -2;
    case P_BASIC: return 0;
    case P_SKILLED: return 1;
    case P_EXPERT: return 2;
    case P_MASTER: return 3;
    case P_GRAND_MASTER: return 4;
    default: return 0;
    }
    return 0;
}

// ============================================================================
// weapon_type — cf. weapon.c:1512
// ============================================================================
// TRANSLATOR: AUTO (weapon.c:1511)
export function weapon_type(obj) {
    if (!obj) return P_BARE_HANDED_COMBAT;
    const od = objectData[obj.otyp];
    if (!od) return P_NONE;
    if (od.oc_class !== WEAPON_CLASS && od.oc_class !== TOOL_CLASS
        && od.oc_class !== GEM_CLASS)
        return P_NONE;
    const skill = od.sub || 0; // mapped from C oc_skill
    return skill < 0 ? -skill : skill;
}

// ============================================================================
// oselect — cf. weapon.c:475
// ============================================================================
// Find one item of given type in monster inventory.
function oselect(mtmp, type) {
    for (const otmp of (mtmp.minvent || [])) {
        if (otmp.otyp !== type) continue;
        // Never select non-cockatrice corpses/eggs
        if ((type === CORPSE || type === EGG)) {
            if (otmp.corpsenm === undefined || otmp.corpsenm < 0) continue;
            if (!touch_petrifies(mons[otmp.corpsenm])) continue;
        }
        return otmp;
    }
    return null;
}

// m_carrying: find object of given type in monster inventory
function m_carrying(mtmp, type) {
    for (const otmp of (mtmp.minvent || [])) {
        if (otmp.otyp === type) return otmp;
    }
    return null;
}
export { m_carrying };

// ============================================================================
// autoreturn_weapon — cf. weapon.c:520
// ============================================================================
const arwep = [
    { otyp: AKLYS, range: AKLYS_LIM * AKLYS_LIM, tethered: 1 },
];

export function autoreturn_weapon(otmp) {
    if (!otmp) return null;
    for (const arw of arwep) {
        if (otmp.otyp === arw.otyp) return arw;
    }
    return null;
}

// ============================================================================
// rwep[] — ranged weapon priority list cf. weapon.c:498
// ============================================================================
const rwep = [
    DWARVISH_SPEAR, SILVER_SPEAR, ELVEN_SPEAR, SPEAR, ORCISH_SPEAR, JAVELIN,
    SHURIKEN, YA, SILVER_ARROW, ELVEN_ARROW, ARROW, ORCISH_ARROW,
    CROSSBOW_BOLT, SILVER_DAGGER, ELVEN_DAGGER, DAGGER, ORCISH_DAGGER, KNIFE,
    FLINT, ROCK, LOADSTONE, LUCKSTONE, DART, CREAM_PIE,
];

// polearms list
const pwep = [
    HALBERD, BARDICHE, SPETUM, BILL_GUISARME, VOULGE, RANSEUR,
    GUISARME, GLAIVE, LUCERN_HAMMER, BEC_DE_CORBIN, FAUCHARD, PARTISAN, LANCE,
];

// ============================================================================
// select_rwep — cf. weapon.c:533
// ============================================================================
// Select best ranged weapon for monster. Returns {weapon, propellor} or null.
export function select_rwep(mtmp) {
    let otmp;
    let propellor = null; // null means "hands" (no launcher needed)

    const mlet = (mtmp.type || {}).mlet;

    // cockatrice eggs first
    if ((otmp = oselect(mtmp, EGG)) != null) return { weapon: otmp, propellor: null };

    // Kops prefer pies
    if (mlet === S_KOP && (otmp = oselect(mtmp, CREAM_PIE)) != null)
        return { weapon: otmp, propellor: null };

    // Giants prefer boulders
    if ((mtmp.type?.flags2 || 0) & 0x00002000 /* M2_ROCKTHROW */ &&
        (otmp = oselect(mtmp, BOULDER)) != null)
        return { weapon: otmp, propellor: null };

    // Polearms: within distance 13 and can see
    const mwep = mtmp.weapon;
    const mweponly = mwep && mwep.cursed && mtmp.weapon_check === NO_WEAPON_WANTED;

    if (dist2(mtmp.mx, mtmp.my, mtmp.mux || 0, mtmp.muy || 0) <= 13) {
        for (const pw of pwep) {
            const od = objectData[pw];
            if (!od) continue;
            if (((strongmonst(mtmp.type) && !(mtmp.misc_worn_check & W_ARMS))
                 || !od.big)
                && (od.material !== 14 /* SILVER */ || !mon_hates_silver(mtmp))) {
                if ((otmp = oselect(mtmp, pw)) != null
                    && (otmp === mwep || !mweponly)) {
                    return { weapon: otmp, propellor: otmp }; // force wield polearm
                }
            }
        }
    }

    // Throw-and-return weapons (aklys)
    for (const arw of arwep) {
        if (!is_mindless(mtmp.type || {}) && !is_animal(mtmp.type || {}) && !mweponly
            && dist2(mtmp.mx, mtmp.my, mtmp.mux || 0, mtmp.muy || 0) <= arw.range) {
            const od = objectData[arw.otyp];
            if ((!(mtmp.misc_worn_check & W_ARMS) || !(od && od.big))
                && (!(od && od.material === 14) || !mon_hates_silver(mtmp))) {
                if ((otmp = oselect(mtmp, arw.otyp)) != null
                    && (otmp === mwep || !mweponly)) {
                    return { weapon: otmp, propellor: otmp };
                }
            }
        }
    }

    // Standard ranged weapon priority list
    for (let i = 0; i < rwep.length; i++) {
        // Gem-slinging: right before darts
        if (rwep[i] === DART && likes_gems(mtmp.type || {})
            && m_carrying(mtmp, SLING)) {
            for (const invObj of (mtmp.minvent || [])) {
                if (invObj.oclass === GEM_CLASS
                    && (invObj.otyp !== LOADSTONE || !invObj.cursed)) {
                    return { weapon: invObj, propellor: m_carrying(mtmp, SLING) };
                }
            }
        }

        propellor = null; // hands
        const od = objectData[rwep[i]];
        const skill = od ? (od.sub || 0) : 0;
        if (skill < 0) {
            switch (-skill) {
            case P_BOW:
                propellor = oselect(mtmp, YUMI) || oselect(mtmp, ELVEN_BOW)
                    || oselect(mtmp, BOW) || oselect(mtmp, ORCISH_BOW);
                break;
            case P_SLING:
                propellor = oselect(mtmp, SLING);
                break;
            case P_CROSSBOW:
                propellor = oselect(mtmp, CROSSBOW);
                break;
            }
            // If wielded weapon is welded and it's not the propellor, can't use
            if (mwep && mwep.cursed && mwep !== propellor
                && mtmp.weapon_check === NO_WEAPON_WANTED)
                propellor = undefined; // needed one and didn't have one
        }

        if (propellor !== undefined) {
            if (rwep[i] !== LOADSTONE) {
                otmp = oselect(mtmp, rwep[i]);
                if (otmp && !otmp.oartifact
                    && !(otmp === mwep && mwep.cursed))
                    return { weapon: otmp, propellor };
            } else {
                for (const invObj of (mtmp.minvent || [])) {
                    if (invObj.otyp === LOADSTONE && !invObj.cursed)
                        return { weapon: invObj, propellor };
                }
            }
        }
    }

    return null;
}

// ============================================================================
// monmightthrowwep — cf. weapon.c:680
// ============================================================================
export function monmightthrowwep(obj) {
    if (!obj) return false;
    for (const r of rwep) {
        if (obj.otyp === r) return true;
    }
    return false;
}

// ============================================================================
// hwep[] — melee weapon priority list cf. weapon.c:691
// ============================================================================
const hwep = [
    CORPSE, // cockatrice corpse
    TSURUGI, RUNESWORD, DWARVISH_MATTOCK, TWO_HANDED_SWORD, BATTLE_AXE,
    KATANA, UNICORN_HORN, CRYSKNIFE, TRIDENT, LONG_SWORD, ELVEN_BROADSWORD,
    BROADSWORD, SCIMITAR, SILVER_SABER, MORNING_STAR, ELVEN_SHORT_SWORD,
    DWARVISH_SHORT_SWORD, SHORT_SWORD, ORCISH_SHORT_SWORD, SILVER_MACE, MACE,
    AXE, DWARVISH_SPEAR, SILVER_SPEAR, ELVEN_SPEAR, SPEAR, ORCISH_SPEAR, FLAIL,
    BULLWHIP, QUARTERSTAFF, JAVELIN, AKLYS, CLUB, PICK_AXE, RUBBER_HOSE,
    WAR_HAMMER, SILVER_DAGGER, ELVEN_DAGGER, DAGGER, ORCISH_DAGGER, ATHAME,
    SCALPEL, KNIFE, WORM_TOOTH,
];

// ============================================================================
// select_hwep — cf. weapon.c:705
// ============================================================================
// Select best melee weapon for monster.
export function select_hwep(mtmp) {
    const strong = strongmonst(mtmp.type || {});
    const wearing_shield = !!(mtmp.misc_worn_check & W_ARMS);

    // Prefer artifacts (simplified: skip artifact check, not implemented)

    // Giants prefer clubs
    if (is_giant(mtmp.type || {})) {
        const otmp = oselect(mtmp, CLUB);
        if (otmp) return otmp;
    }
    // Balrog prefers bullwhip
    if (mtmp.type === mons[PM_BALROG]) {
        const otmp = oselect(mtmp, BULLWHIP);
        if (otmp) return otmp;
    }

    for (const hw of hwep) {
        // Cockatrice corpse: needs gloves and stone resistance
        if (hw === CORPSE && !(mtmp.misc_worn_check & W_ARMG)
            && !resists_ston(mtmp))
            continue;

        const od = objectData[hw];
        if (!od) continue;

        // Only strong monsters can wield bimanual weapons (unless wearing shield)
        if (((strong && !wearing_shield) || !od.big)
            && (od.material !== 14 /* SILVER */ || !mon_hates_silver(mtmp))) {
            const otmp = oselect(mtmp, hw);
            if (otmp) return otmp;
        }
    }

    return null;
}

// ============================================================================
// setmnotwielded — cf. weapon.c:1809
// ============================================================================
export function setmnotwielded(mon, obj) {
    if (!obj) return;
    // artifact light handling: simplified (no artifact system)
    if (mon.weapon === obj) mon.weapon = null;
    obj.owornmask = (obj.owornmask || 0) & ~W_WEP;
}

// ============================================================================
// mwepgone — cf. weapon.c:938
// ============================================================================
export function mwepgone(mon) {
    const mwep = mon.weapon;
    if (mwep) {
        setmnotwielded(mon, mwep);
        mon.weapon_check = NEED_WEAPON;
    }
}

// ============================================================================
// possibly_unwield — cf. weapon.c:747
// ============================================================================
export function possibly_unwield(mon, _polyspot) {
    const mw_tmp = mon.weapon;
    if (!mw_tmp) return;

    // Check if weapon is still in inventory
    let found = false;
    for (const obj of (mon.minvent || [])) {
        if (obj === mw_tmp) { found = true; break; }
    }
    if (!found) {
        // Weapon was stolen or destroyed
        mon.weapon = null;
        mon.weapon_check = NEED_WEAPON;
        return;
    }

    if (!attacktype(mon.type || {}, AT_WEAP)) {
        // Monster can no longer use weapons
        setmnotwielded(mon, mw_tmp);
        mon.weapon_check = NO_WEAPON_WANTED;
        return;
    }

    // Otherwise just mark for re-evaluation
    if (!(mw_tmp.cursed && mon.weapon_check === NO_WEAPON_WANTED))
        mon.weapon_check = NEED_WEAPON;
}

// ============================================================================
// mon_wield_item — cf. weapon.c:801
// ============================================================================
// Monster wields appropriate weapon. Returns 1 if took time, 0 otherwise.
export function mon_wield_item(mon) {
    let obj;

    if (mon.weapon_check === NO_WEAPON_WANTED) return 0;

    switch (mon.weapon_check) {
    case NEED_HTH_WEAPON:
        obj = select_hwep(mon);
        break;
    case NEED_RANGED_WEAPON: {
        const result = select_rwep(mon);
        obj = result ? result.propellor : null;
        break;
    }
    case NEED_PICK_AXE:
        obj = m_carrying(mon, PICK_AXE);
        if (!obj && !which_armor(mon, W_ARMS))
            obj = m_carrying(mon, DWARVISH_MATTOCK);
        break;
    case NEED_AXE:
        obj = m_carrying(mon, BATTLE_AXE);
        if (!obj || which_armor(mon, W_ARMS))
            obj = m_carrying(mon, AXE);
        break;
    case NEED_PICK_OR_AXE:
        obj = m_carrying(mon, DWARVISH_MATTOCK);
        if (!obj) obj = m_carrying(mon, BATTLE_AXE);
        if (!obj || which_armor(mon, W_ARMS)) {
            obj = m_carrying(mon, PICK_AXE);
            if (!obj) obj = m_carrying(mon, AXE);
        }
        break;
    default:
        return 0;
    }

    if (obj) {
        const mw_tmp = mon.weapon;
        if (mw_tmp && mw_tmp.otyp === obj.otyp) {
            // Already wielding same type
            mon.weapon_check = NEED_WEAPON;
            return 0;
        }
        // Check for welded weapon
        if (mw_tmp && mw_tmp.cursed) {
            mon.weapon_check = NO_WEAPON_WANTED;
            return 1;
        }

        // Wield the new weapon
        if (mw_tmp) setmnotwielded(mon, mw_tmp);
        mon.weapon = obj;
        mon.weapon_check = NEED_WEAPON;
        obj.owornmask = (obj.owornmask || 0) | W_WEP;
        return 1;
    }
    mon.weapon_check = NEED_WEAPON;
    return 0;
}

// ============================================================================
// Towel functions — cf. weapon.c:1014-1083
// ============================================================================
export function finish_towel_change(obj, newspe) {
    newspe = Math.min(newspe, 7);
    obj.spe = Math.max(newspe, 0);
}

export function wet_a_towel(obj, amt, _verbose) {
    const newspe = (amt <= 0) ? (obj.spe || 0) - amt : amt;
    if (newspe !== (obj.spe || 0))
        finish_towel_change(obj, newspe);
}

export function dry_a_towel(obj, amt, _verbose) {
    const newspe = (amt < 0) ? (obj.spe || 0) + amt : amt;
    if (newspe !== (obj.spe || 0))
        finish_towel_change(obj, newspe);
}

// ============================================================================
// Skill level helpers — cf. weapon.c:1087-1123
// ============================================================================
export function skill_level_name(level) {
    switch (level) {
    case P_UNSKILLED: return 'Unskilled';
    case P_BASIC: return 'Basic';
    case P_SKILLED: return 'Skilled';
    case P_EXPERT: return 'Expert';
    case P_MASTER: return 'Master';
    case P_GRAND_MASTER: return 'Grand Master';
    default: return 'Unknown';
    }
}

// C ref: weapon.c weapon_descr()/skill_name() helper.
export function weapon_descr(skill) {
    return skill_name(skill);
}

export function skill_name(skill) {
    switch (skill) {
    case P_DAGGER: return 'dagger';
    case P_KNIFE: return 'knife';
    case P_AXE: return 'axe';
    case P_PICK_AXE: return 'pick-axe';
    case P_SHORT_SWORD: return 'short sword';
    case P_BROAD_SWORD: return 'broadsword';
    case P_LONG_SWORD: return 'long sword';
    case P_TWO_HANDED_SWORD: return 'two-handed sword';
    case P_SABER: return 'saber';
    case P_CLUB: return 'club';
    case P_MACE: return 'mace';
    case P_MORNING_STAR: return 'morning star';
    case P_FLAIL: return 'flail';
    case P_HAMMER: return 'hammer';
    case P_QUARTERSTAFF: return 'quarterstaff';
    case P_POLEARMS: return 'polearms';
    case P_SPEAR: return 'spear';
    case P_TRIDENT: return 'trident';
    case P_LANCE: return 'lance';
    case P_BOW: return 'bow';
    case P_SLING: return 'sling';
    case P_CROSSBOW: return 'crossbow';
    case P_DART: return 'dart';
    case P_SHURIKEN: return 'shuriken';
    case P_BOOMERANG: return 'boomerang';
    case P_WHIP: return 'whip';
    case P_UNICORN_HORN: return 'unicorn horn';
    case P_ATTACK_SPELL: return 'attack spells';
    case P_HEALING_SPELL: return 'healing spells';
    case P_DIVINATION_SPELL: return 'divination spells';
    case P_ENCHANTMENT_SPELL: return 'enchantment spells';
    case P_CLERIC_SPELL: return 'clerical spells';
    case P_ESCAPE_SPELL: return 'escape spells';
    case P_MATTER_SPELL: return 'matter spells';
    case P_BARE_HANDED_COMBAT: return 'bare-handed combat';
    case P_TWO_WEAPON_COMBAT: return 'two weapon combat';
    case P_RIDING: return 'riding';
    default: return 'unknown';
    }
}

// ============================================================================
// Skill system stubs — data structures present, activation gated
// ============================================================================
// These are placeholder implementations that establish the data structures
// but don't yet affect gameplay. Phase 5 will activate them.

export function skill_init(_class_skill) {
    for (let i = 0; i < P_NUM_SKILLS; i++) {
        heroSkill[i] = P_ISRESTRICTED;
        heroMaxSkill[i] = P_ISRESTRICTED;
        heroSkillAdvance[i] = 0;
    }
    if (!_class_skill) {
        skillSystemActive = false;
        return;
    }
    for (let i = 0; i < P_NUM_SKILLS; i++) {
        const maxSkill = _class_skill[i] ?? P_BASIC;
        heroMaxSkill[i] = maxSkill;
        heroSkill[i] = Math.min(P_BASIC, maxSkill);
    }
    skillSystemActive = true;
}

export function use_skill(skill, degree = 1) {
    if (!skillSystemActive) return;
    if (!Number.isInteger(skill) || skill < 0 || skill >= P_NUM_SKILLS) return;
    heroSkillAdvance[skill] += Math.max(0, degree | 0);
}

export function unrestrict_weapon_skill(skill) {
    if (!Number.isInteger(skill) || skill < 0 || skill >= P_NUM_SKILLS) return;
    if (heroMaxSkill[skill] === P_ISRESTRICTED) heroMaxSkill[skill] = P_BASIC;
    if (heroSkill[skill] === P_ISRESTRICTED) heroSkill[skill] = P_UNSKILLED;
}

export function add_weapon_skill(n) {
    if (!skillSystemActive) return;
    heroSkillAdvance[P_NONE] = (heroSkillAdvance[P_NONE] || 0) + Math.max(0, n | 0);
}

export function lose_weapon_skill(n) {
    if (!skillSystemActive) return;
    heroSkillAdvance[P_NONE] = Math.max(0, (heroSkillAdvance[P_NONE] || 0) - Math.max(0, n | 0));
}

export function drain_weapon_skill(n = 1) {
    if (!skillSystemActive) return;
    let tries = Math.max(1, n | 0);
    while (tries-- > 0) {
        const candidates = [];
        for (let i = 0; i < P_NUM_SKILLS; i++) {
            if (heroSkill[i] > P_UNSKILLED) candidates.push(i);
        }
        if (!candidates.length) return;
        const pick = candidates[rn2(candidates.length)];
        heroSkill[pick] = Math.max(P_UNSKILLED, heroSkill[pick] - 1);
    }
}

export function enhance_weapon_skill() {
    if (!skillSystemActive) return 0;
    for (let i = 0; i < P_NUM_SKILLS; i++) {
        if (can_advance(i)) {
            skill_advance(i);
            return 1;
        }
    }
    return 0;
}

// C ref: weapon.c slots_required().
export function slots_required(skill) {
    if (!Number.isInteger(skill) || skill < 0 || skill >= P_NUM_SKILLS) return 1;
    return Math.max(1, heroSkill[skill]);
}

// C ref: weapon.c could_advance().
export function could_advance(skill) {
    if (!skillSystemActive) return false;
    if (!Number.isInteger(skill) || skill < 0 || skill >= P_NUM_SKILLS) return false;
    if (heroSkill[skill] <= P_ISRESTRICTED) return false;
    if (heroSkill[skill] >= heroMaxSkill[skill]) return false;
    return heroSkillAdvance[skill] >= slots_required(skill);
}

// C ref: weapon.c can_advance().
export function can_advance(skill) {
    if (!could_advance(skill)) return false;
    const pool = heroSkillAdvance[P_NONE] || 0;
    return pool >= slots_required(skill);
}

// C ref: weapon.c peaked_skill().
export function peaked_skill(skill) {
    if (!Number.isInteger(skill) || skill < 0 || skill >= P_NUM_SKILLS) return true;
    return heroSkill[skill] >= heroMaxSkill[skill];
}

// C ref: weapon.c skill_advance().
export function skill_advance(skill) {
    if (!can_advance(skill)) return false;
    const cost = slots_required(skill);
    heroSkillAdvance[P_NONE] = Math.max(0, (heroSkillAdvance[P_NONE] || 0) - cost);
    heroSkill[skill] = Math.min(heroMaxSkill[skill], heroSkill[skill] + 1);
    return true;
}

// C ref: weapon.c add_skills_to_menu()/show_skills().
export function add_skills_to_menu() {
    const rows = [];
    for (let i = 0; i < P_NUM_SKILLS; i++) {
        if (heroSkill[i] <= P_ISRESTRICTED) continue;
        rows.push({
            skill: i,
            name: skill_name(i),
            level: heroSkill[i],
            levelName: skill_level_name(heroSkill[i]),
            canAdvance: can_advance(i),
        });
    }
    return rows;
}

export function show_skills() {
    return add_skills_to_menu();
}

// C ref: weapon.c give_may_advance_msg().
export function give_may_advance_msg(display = null) {
    const any = add_skills_to_menu().some((row) => row.canAdvance);
    if (any && display) {
        display.putstr_message('You feel more confident in your weapon skills.');
    }
    return any;
}

// C ref: weapon.c uwep_skill_type().
// TRANSLATOR: AUTO (weapon.c:1526)
export function uwep_skill_type(player = null) {
  if (player?.twoweap) return P_TWO_WEAPON_COMBAT;
  return weapon_type(player?.weapon || null);
}
