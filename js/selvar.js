// Autogenerated translator module for currently-unmapped C source outputs.
// Contents are syntax-validated emitted functions; wiring into runtime is separate.

// TRANSLATOR: AUTO (selvar.c:64)
export function selection_clone(sel) {
  let tmps =  alloc(sizeof *tmps);
   tmps = sel;
  tmps.map = dupstr(sel.map);
  return tmps;
}

// TRANSLATOR: AUTO (selvar.c:76)
export function selection_getbounds(sel, b) {
  if (!sel || !b) return;
  selection_recalc_bounds(sel);
  if (sel.bounds.lx >= sel.wid) {
    b.lx = 0;
    b.ly = 0;
    b.hx = COLNO - 1;
    b.hy = ROWNO - 1;
  }
  else {
    b.lx = sel.bounds.lx;
    b.ly = sel.bounds.ly;
    b.hx = sel.bounds.hx;
    b.hy = sel.bounds.hy;
  }
}

// TRANSLATOR: AUTO (selvar.c:98)
export function selection_recalc_bounds(sel) {
  let x, y, r;
  if (!sel.bounds_dirty) return;
  sel.bounds.lx = COLNO;
  sel.bounds.ly = ROWNO;
  sel.bounds.hx = sel.bounds.hy = 0;
  r.lx = r.ly = r.hx = r.hy = -1;
  for (x = 0; x < sel.wid; x++) {
    for (y = 0; y < sel.hei; y++) {
      if (selection_getpoint(x, y, sel)) { r.lx = x; break; }
    }
    if (r.lx > -1) {
      break;
    }
  }
  if (r.lx > -1) {
    for (x = sel.wid-1; x >= r.lx; x--) {
      for (y = 0; y < sel.hei; y++) {
        if (selection_getpoint(x, y, sel)) { r.hx = x; break; }
      }
      if (r.hx > -1) {
        break;
      }
    }
    for (y = 0; y < sel.hei; y++) {
      for (x = r.lx; x <= r.hx; x++) {
        if (selection_getpoint(x, y, sel)) { r.ly = y; break; }
      }
      if (r.ly > -1) {
        break;
      }
    }
    for (y = sel.hei-1; y >= r.ly; y--) {
      for (x = r.lx; x <= r.hx; x++) {
        if (selection_getpoint(x, y, sel)) { r.hy = y; break; }
      }
      if (r.hy > -1) {
        break;
      }
    }
    sel.bounds = r;
  }
  sel.bounds_dirty = false;
}

// TRANSLATOR: AUTO (selvar.c:167)
export function selection_getpoint(x, y, sel) {
  if (!sel || !sel.map) return 0;
  if (x < 0 || y < 0 || x >= sel.wid || y >= sel.hei) return 0;
  return (sel.map[sel.wid * y + x] - 1);
}

// TRANSLATOR: AUTO (selvar.c:180)
export function selection_setpoint(x, y, sel, c) {
  if (!sel || !sel.map) return;
  if (x < 0 || y < 0 || x >= sel.wid || y >= sel.hei) return;
  if (c && !sel.bounds_dirty) {
    if (sel.bounds.lx > x) sel.bounds.lx = x;
    if (sel.bounds.ly > y) sel.bounds.ly = y;
    if (sel.bounds.hx < x) sel.bounds.hx = x;
    if (sel.bounds.hy < y) sel.bounds.hy = y;
  }
  else if (sel.map[sel.wid * y + x] !== 0) { sel.bounds_dirty = true; }
  sel.map[sel.wid * y + x] =  (c + 1);
}

// TRANSLATOR: AUTO (selvar.c:378)
export function sel_flood_havepoint(x, y, xs, ys, n) {
  let xx = x, yy = y;
  while (n > 0) {
    --n;
    if (xs[n] === xx && ys[n] === yy) return true;
  }
  return false;
}

// TRANSLATOR: AUTO (selvar.c:394)
export function selection_floodfill(ov, x, y, diagonals) {
  let tmp = selection_new();
  let floodfill_stack_overrun = "floodfill stack overrun", idx = 0, dx, dy;
  if (selection_flood_check_func === null) { selection_free(tmp, true); return; }
  do {
    if (SEL_FLOOD(x, y)) {
      SEL_FLOOD(x, y);
      SEL_FLOOD(x, y);
      SEL_FLOOD(x, y);
    }
    else {
      SEL_FLOOD(x, y);
    }
  } while (SEL_FLOOD(x, y));
  do {
    idx--;
    x = dx[idx];
    y = dy[idx];
    if (isok(x, y)) { selection_setpoint(x, y, ov, 1); selection_setpoint(x, y, tmp, 1); }
    do {
      if (SEL_FLOOD_CHKDIR((x + 1), y, tmp)) {
        do {
          if (SEL_FLOOD_CHKDIR((x + 1), y, tmp)) {
            SEL_FLOOD_CHKDIR((x + 1), y, tmp);
            SEL_FLOOD_CHKDIR((x + 1), y, tmp);
            SEL_FLOOD_CHKDIR((x + 1), y, tmp);
          }
          else {
            SEL_FLOOD_CHKDIR((x + 1), y, tmp);
          }
        } while (SEL_FLOOD_CHKDIR((x + 1), y, tmp));
      }
    } while (SEL_FLOOD_CHKDIR((x + 1), y, tmp));
    do {
      if (SEL_FLOOD_CHKDIR((x - 1), y, tmp)) {
        do {
          if (SEL_FLOOD_CHKDIR((x - 1), y, tmp)) {
            SEL_FLOOD_CHKDIR((x - 1), y, tmp);
            SEL_FLOOD_CHKDIR((x - 1), y, tmp);
            SEL_FLOOD_CHKDIR((x - 1), y, tmp);
          }
          else {
            SEL_FLOOD_CHKDIR((x - 1), y, tmp);
          }
        } while (SEL_FLOOD_CHKDIR((x - 1), y, tmp));
      }
    } while (SEL_FLOOD_CHKDIR((x - 1), y, tmp));
    do {
      if (SEL_FLOOD_CHKDIR(x, (y + 1), tmp)) {
        do {
          if (SEL_FLOOD_CHKDIR(x, (y + 1), tmp)) {
            SEL_FLOOD_CHKDIR(x, (y + 1), tmp);
            SEL_FLOOD_CHKDIR(x, (y + 1), tmp);
            SEL_FLOOD_CHKDIR(x, (y + 1), tmp);
          }
          else {
            SEL_FLOOD_CHKDIR(x, (y + 1), tmp);
          }
        } while (SEL_FLOOD_CHKDIR(x, (y + 1), tmp));
      }
    } while (SEL_FLOOD_CHKDIR(x, (y + 1), tmp));
    do {
      if (SEL_FLOOD_CHKDIR(x, (y - 1), tmp)) {
        do {
          if (SEL_FLOOD_CHKDIR(x, (y - 1), tmp)) {
            SEL_FLOOD_CHKDIR(x, (y - 1), tmp);
            SEL_FLOOD_CHKDIR(x, (y - 1), tmp);
            SEL_FLOOD_CHKDIR(x, (y - 1), tmp);
          }
          else {
            SEL_FLOOD_CHKDIR(x, (y - 1), tmp);
          }
        } while (SEL_FLOOD_CHKDIR(x, (y - 1), tmp));
      }
    } while (SEL_FLOOD_CHKDIR(x, (y - 1), tmp));
    if (diagonals) {
      do {
        if (SEL_FLOOD_CHKDIR((x + 1), (y + 1), tmp)) {
          do {
            if (SEL_FLOOD_CHKDIR((x + 1), (y + 1), tmp)) {
              SEL_FLOOD_CHKDIR((x + 1), (y + 1), tmp);
              SEL_FLOOD_CHKDIR((x + 1), (y + 1), tmp);
              SEL_FLOOD_CHKDIR((x + 1), (y + 1), tmp);
            }
            else {
              SEL_FLOOD_CHKDIR((x + 1), (y + 1), tmp);
            }
          } while (SEL_FLOOD_CHKDIR((x + 1), (y + 1), tmp));
        }
      } while (SEL_FLOOD_CHKDIR((x + 1), (y + 1), tmp));
      do {
        if (SEL_FLOOD_CHKDIR((x - 1), (y - 1), tmp)) {
          do {
            if (SEL_FLOOD_CHKDIR((x - 1), (y - 1), tmp)) {
              SEL_FLOOD_CHKDIR((x - 1), (y - 1), tmp);
              SEL_FLOOD_CHKDIR((x - 1), (y - 1), tmp);
              SEL_FLOOD_CHKDIR((x - 1), (y - 1), tmp);
            }
            else {
              SEL_FLOOD_CHKDIR((x - 1), (y - 1), tmp);
            }
          } while (SEL_FLOOD_CHKDIR((x - 1), (y - 1), tmp));
        }
      } while (SEL_FLOOD_CHKDIR((x - 1), (y - 1), tmp));
      do {
        if (SEL_FLOOD_CHKDIR((x - 1), (y + 1), tmp)) {
          do {
            if (SEL_FLOOD_CHKDIR((x - 1), (y + 1), tmp)) {
              SEL_FLOOD_CHKDIR((x - 1), (y + 1), tmp);
              SEL_FLOOD_CHKDIR((x - 1), (y + 1), tmp);
              SEL_FLOOD_CHKDIR((x - 1), (y + 1), tmp);
            }
            else {
              SEL_FLOOD_CHKDIR((x - 1), (y + 1), tmp);
            }
          } while (SEL_FLOOD_CHKDIR((x - 1), (y + 1), tmp));
        }
      } while (SEL_FLOOD_CHKDIR((x - 1), (y + 1), tmp));
      do {
        if (SEL_FLOOD_CHKDIR((x + 1), (y - 1), tmp)) {
          do {
            if (SEL_FLOOD_CHKDIR((x + 1), (y - 1), tmp)) {
              SEL_FLOOD_CHKDIR((x + 1), (y - 1), tmp);
              SEL_FLOOD_CHKDIR((x + 1), (y - 1), tmp);
              SEL_FLOOD_CHKDIR((x + 1), (y - 1), tmp);
            }
            else {
              SEL_FLOOD_CHKDIR((x + 1), (y - 1), tmp);
            }
          } while (SEL_FLOOD_CHKDIR((x + 1), (y - 1), tmp));
        }
      } while (SEL_FLOOD_CHKDIR((x + 1), (y - 1), tmp));
    }
  } while (idx > 0);
  selection_free(tmp, true);
}

// TRANSLATOR: AUTO (selvar.c:455)
export function selection_do_ellipse(ov, xc, yc, a, b, filled) {
  let x = 0, y = b, a2 =  a * a, b2 =  b * b, crit1 = -(a2 / 4 + a % 2 + b2);
  let crit2 = -(b2 / 4 + b % 2 + a2), crit3 = -(b2 / 4 + b % 2), t = -a2 * y;
  let dxt = 2 * b2 * x, dyt = -2 * a2 * y, d2xt = 2 * b2, d2yt = 2 * a2;
  let width = 1, i;
  if (!ov) return;
  filled = !filled;
  if (!filled) {
    while (y >= 0 && x <= a) {
      selection_setpoint(xc + x, yc + y, ov, 1);
      if (x !== 0 || y !== 0) selection_setpoint(xc - x, yc - y, ov, 1);
      if (x !== 0 && y !== 0) {
        selection_setpoint(xc + x, yc - y, ov, 1);
        selection_setpoint(xc - x, yc + y, ov, 1);
      }
      if (t + b2 * x <= crit1   || t + a2 * y <= crit3) {
        x++;
        dxt += d2xt;
        t += dxt;
      }
      else if (t - a2 * y > crit2) {
        y--;
        dyt += d2yt;
        t += dyt;
      }
      else {
        x++;
        dxt += d2xt;
        t += dxt;
        y--;
        dyt += d2yt;
        t += dyt;
      }
    }
  }
  else {
    while (y >= 0 && x <= a) {
      if (t + b2 * x <= crit1   || t + a2 * y <= crit3) {
        x++;
        dxt += d2xt;
        t += dxt;
        width += 2;
      }
      else if (t - a2 * y > crit2) {
        for (i = 0; i < width; i++) {
          selection_setpoint(xc - x + i, yc - y, ov, 1);
        }
        if (y !== 0) {
          for (i = 0; i < width; i++) {
            selection_setpoint(xc - x + i, yc + y, ov, 1);
          }
        }
        y--;
        dyt += d2yt;
        t += dyt;
      }
      else {
        for (i = 0; i < width; i++) {
          selection_setpoint(xc - x + i, yc - y, ov, 1);
        }
        if (y !== 0) {
          for (i = 0; i < width; i++) {
            selection_setpoint(xc - x + i, yc + y, ov, 1);
          }
        }
        x++;
        dxt += d2xt;
        t += dxt;
        y--;
        dyt += d2yt;
        t += dyt;
        width += 2;
      }
    }
  }
}

// TRANSLATOR: AUTO (selvar.c:625)
export function selection_do_line(x1, y1, x2, y2, ov) {
  let d0, dx, dy, ai, bi, xi, yi;
  if (x1 < x2) { xi = 1; dx = x2 - x1; }
  else { xi = -1; dx = x1 - x2; }
  if (y1 < y2) { yi = 1; dy = y2 - y1; }
  else { yi = -1; dy = y1 - y2; }
  selection_setpoint(x1, y1, ov, 1);
  if (!dx && !dy) {
  }
  else if (dx > dy) {
    ai = (dy - dx) * 2;
    bi = dy * 2;
    d0 = bi - dx;
    do {
      if (d0 >= 0) { y1 += yi; d0 += ai; }
      else {
        d0 += bi;
      }
      x1 += xi;
      selection_setpoint(x1, y1, ov, 1);
    } while (x1 !== x2);
  }
  else {
    ai = (dx - dy) * 2;
    bi = dx * 2;
    d0 = bi - dy;
    do {
      if (d0 >= 0) { x1 += xi; d0 += ai; }
      else {
        d0 += bi;
      }
      y1 += yi;
      selection_setpoint(x1, y1, ov, 1);
    } while (y1 !== y2);
  }
}

// TRANSLATOR: AUTO (selvar.c:682)
export function selection_do_randline(x1, y1, x2, y2, rough, rec, ov) {
  let mx, my, dx, dy;
  if (rec < 1 || (x2 === x1 && y2 === y1)) return;
  if (rough > Math.max(Math.abs(x2 - x1), Math.abs(y2 - y1))) rough = Math.max(Math.abs(x2 - x1), Math.abs(y2 - y1));
  if (rough < 2) { mx = ((x1 + x2) / 2); my = ((y1 + y2) / 2); }
  else {
    do {
      dx = rn2(rough) - (rough / 2);
      dy = rn2(rough) - (rough / 2);
      mx = ((x1 + x2) / 2) + dx;
      my = ((y1 + y2) / 2) + dy;
    } while ((mx > COLNO - 1 || mx < 0 || my < 0 || my > ROWNO - 1));
  }
  if (!selection_getpoint(mx, my, ov)) { selection_setpoint(mx, my, ov, 1); }
  rough = (rough * 2) / 3;
  rec--;
  selection_do_randline(x1, y1, mx, my, rough, rec, ov);
  selection_do_randline(mx, my, x2, y2, rough, rec, ov);
  selection_setpoint(x2, y2, ov, 1);
}

// TRANSLATOR: AUTO (selvar.c:801)
export function selection_force_newsyms(sel) {
  let x, y;
  for (x = 1; x < sel.wid; x++) {
    for (y = 0; y < sel.hei; y++) {
      if (selection_getpoint(x, y, sel)) newsym_force(x, y);
    }
  }
}
