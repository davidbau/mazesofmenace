// mcastu.js -- Monster spellcasting: wizard and cleric spell dispatch
// cf. mcastu.c — castmu, buzzmu, choose_magic_spell, choose_clerical_spell,
//                cursetxt, m_cure_self, touch_of_death, death_inflicted_by,
//                cast_wizard_spell, cast_cleric_spell,
//                is_undirected_spell, spell_would_be_useless

import { rn2, rnd, d } from './rng.js';
import {
  AD_FIRE, AD_COLD, AD_ELEC, AD_MAGM, AD_SLEE, AD_DISN, AD_DRST, AD_ACID, AT_MAGC,
} from './monsters.js';
import {
  buzz, ZT_BREATH, ZT_MAGIC_MISSILE, ZT_FIRE, ZT_COLD, ZT_SLEEP,
  ZT_DEATH, ZT_LIGHTNING, ZT_POISON_GAS, ZT_ACID,
} from './zap.js';
import { canonicalizeAttackFields } from './attack_fields.js';

// Wizard spell constants (C ref: mcastu.c)
export const MGC_PSI_BOLT = 0;
export const MGC_CURE_SELF = 1;
export const MGC_HASTE_SELF = 2;
export const MGC_STUN_YOU = 3;
export const MGC_DISAPPEAR = 4;
export const MGC_WEAKEN_YOU = 5;
export const MGC_DESTRY_ARMR = 6;
export const MGC_CURSE_ITEMS = 7;
export const MGC_AGGRAVATION = 8;
export const MGC_SUMMON_MONS = 9;
export const MGC_CLONE_WIZ = 10;
export const MGC_DEATH_TOUCH = 11;

// Cleric spell constants
export const CLC_OPEN_WOUNDS = 0;
export const CLC_CURE_SELF = 1;
export const CLC_CONFUSE_YOU = 2;
export const CLC_PARALYZE = 3;
export const CLC_BLIND_YOU = 4;
export const CLC_INSECTS = 5;
export const CLC_CURSE_ITEMS = 6;
export const CLC_LIGHTNING = 7;
export const CLC_FIRE_PILLAR = 8;
export const CLC_GEYSER = 9;

// cf. mcastu.c:48 — cursetxt(mtmp, vis)
export function cursetxt(mtmp, vis) {
  // Message when monster's spell is frustrated
  // Stub — would print "The <monster> points at you, then curses."
}

// cf. mcastu.c:75 — choose_magic_spell(n)
// Maps a spell value to a wizard spell type
export function choose_magic_spell(n) {
  // C ref: mcastu.c:75-126
  // The spell value is recursively reduced: while > 24 && rn2(25), re-roll
  while (n > 24 && rn2(25)) {
    n = rn2(n);
  }

  if (n >= 24) return MGC_DEATH_TOUCH;
  if (n >= 22) return MGC_CLONE_WIZ;
  if (n >= 20) return MGC_SUMMON_MONS;
  if (n >= 16) return MGC_AGGRAVATION;
  if (n >= 14) return MGC_CURSE_ITEMS;
  if (n >= 12) return MGC_DESTRY_ARMR;
  if (n >= 10) return MGC_WEAKEN_YOU;
  if (n >= 8) return MGC_DISAPPEAR;
  if (n >= 6) return MGC_STUN_YOU;
  if (n >= 4) return MGC_HASTE_SELF;
  if (n >= 2) return MGC_CURE_SELF;
  return MGC_PSI_BOLT;
}

// cf. mcastu.c:129 — choose_clerical_spell(n)
export function choose_clerical_spell(n) {
  while (n > 24 && rn2(25)) {
    n = rn2(n);
  }

  if (n >= 22) return CLC_GEYSER;
  if (n >= 20) return CLC_FIRE_PILLAR;
  if (n >= 16) return CLC_LIGHTNING;
  if (n >= 14) return CLC_CURSE_ITEMS;
  if (n >= 12) return CLC_INSECTS;
  if (n >= 10) return CLC_BLIND_YOU;
  if (n >= 8) return CLC_PARALYZE;
  if (n >= 6) return CLC_CONFUSE_YOU;
  if (n >= 4) return CLC_OPEN_WOUNDS;
  if (n >= 2) return CLC_CURE_SELF;
  return CLC_OPEN_WOUNDS;
}

// cf. mcastu.c:359 — m_cure_self(mtmp, dmg)
export function m_cure_self(mtmp, dmg) {
  const heal = d(3, 6);
  if (mtmp.mhp < mtmp.mhpmax) {
    mtmp.mhp = Math.min(mtmp.mhpmax, mtmp.mhp + heal);
  }
  return Math.max(0, dmg - heal);
}

// cf. mcastu.c:374 — touch_of_death(mtmp)
export function touch_of_death(mtmp, player) {
  // Stub — instant kill or massive damage to player
  // Full implementation requires player death handling
  if (!player) return;
  const dmg = 50 + d(8, 6);
  // Would check for Antimagic, magic resistance, etc.
  // For now this is a stub
}

// cf. mcastu.c:409 — death_inflicted_by(who, mtmp)
export function death_inflicted_by(who, mtmp) {
  // Format death message for spell-induced deaths
  return `killed by a spell cast by ${who}`;
}

// cf. mcastu.c:448 — cast_wizard_spell(mtmp, dmg, spellid)
export function cast_wizard_spell(mtmp, dmg, spellid, player, map) {
  switch (spellid) {
    case MGC_DEATH_TOUCH:
      // Touch of death
      touch_of_death(mtmp, player);
      break;
    case MGC_CLONE_WIZ:
      // Clone wizard — stub
      break;
    case MGC_SUMMON_MONS:
      // Summon nasties — stub
      break;
    case MGC_AGGRAVATION:
      // Aggravate monsters
      aggravation(map);
      break;
    case MGC_CURSE_ITEMS:
      // Curse hero items
      curse_objects(player);
      break;
    case MGC_DESTRY_ARMR:
      // Destroy armor — stub
      break;
    case MGC_WEAKEN_YOU:
      // Weaken (drain STR)
      if (player && dmg > 0) {
        // Would drain rnd(dmg) STR
      }
      break;
    case MGC_DISAPPEAR:
      // Monster goes invisible
      if (mtmp) mtmp.minvis = true;
      break;
    case MGC_STUN_YOU:
      // Stun hero — stub
      break;
    case MGC_HASTE_SELF:
      // Monster hastes itself
      if (mtmp) mtmp.mspeed = 2; // fast
      break;
    case MGC_CURE_SELF:
      m_cure_self(mtmp, 0);
      break;
    case MGC_PSI_BOLT:
      // Psi bolt: dmg to player
      if (player) {
        // Would apply dmg with Antimagic halving
      }
      break;
  }
}

// cf. mcastu.c:631 — cast_cleric_spell(mtmp, dmg, spellid)
export function cast_cleric_spell(mtmp, dmg, spellid, player, map) {
  switch (spellid) {
    case CLC_GEYSER:
      // Geyser: d(8, 6) physical damage
      if (player) {
        const gdam = d(8, 6);
        // Would apply physical damage
      }
      break;
    case CLC_FIRE_PILLAR:
      // Fire pillar: d(8, 6) fire damage
      if (player) {
        const fdam = d(8, 6);
        // Would apply fire damage + burnarmor
      }
      break;
    case CLC_LIGHTNING:
      // Lightning: d(8, 6) electrical damage
      if (player) {
        const edam = d(8, 6);
        // Would apply electrical damage + blind via flashburn(rnd(100))
        rnd(100); // blind duration RNG consumed
      }
      break;
    case CLC_INSECTS:
      // Summon insects
      if (mtmp) {
        const mlev = mtmp.m_lev || mtmp.mlevel || 1;
        let quan = (mlev < 2) ? 1 : rnd(Math.floor(mlev / 2));
        if (quan < 3) quan = 3;
        // Would spawn quan insects
      }
      break;
    case CLC_CURSE_ITEMS:
      curse_objects(player);
      break;
    case CLC_BLIND_YOU:
      // Blind hero — stub
      break;
    case CLC_PARALYZE:
      // Paralyze hero — stub
      break;
    case CLC_CONFUSE_YOU:
      // Confuse hero — stub
      break;
    case CLC_OPEN_WOUNDS:
      // Open wounds: direct damage
      if (player) {
        // Would apply dmg
      }
      break;
    case CLC_CURE_SELF:
      m_cure_self(mtmp, 0);
      break;
  }
}

// cf. mcastu.c:176 — castmu(mtmp, mattk, vis, thrown)
// Monster casts a spell at the hero
// Returns 1 if spell was cast, 0 if failed
export async function castmu(mtmp, mattk, vis, thrown, player, map) {
  if (!mtmp || !mattk) return 0;
  canonicalizeAttackFields(mattk);

  const ml = mtmp.m_lev || mtmp.mlevel || 1;
  const aatyp = mattk.aatyp || mattk.at || mattk.type || 0;

  // Spell fumble check
  if (rn2(ml * 10) < (mtmp.mconf ? 100 : 20)) {
    if (vis) cursetxt(mtmp, vis);
    return 1; // spell fumbled but turn consumed
  }

  // Select spell
  let spellnum = rn2(ml);
  let dmg;
  if (mattk.damd) {
    dmg = d(Math.floor(ml / 2) + (mattk.damn || 0), mattk.damd);
  } else {
    dmg = d(Math.floor(ml / 2) + 1, 6);
  }

  // Determine spell type (wizard vs cleric)
  const isWizard = (aatyp === AT_MAGC);
  // In C, AT_MAGC = wizard spells; AT_CLER would be cleric
  // For simplicity, check monster data for caster type

  if (isWizard) {
    const spell = choose_magic_spell(spellnum);
    if (spell_would_be_useless(mtmp, aatyp, spell)) return 0;
    cast_wizard_spell(mtmp, dmg, spell, player, map);
  } else {
    const spell = choose_clerical_spell(spellnum);
    if (spell_would_be_useless(mtmp, aatyp, spell)) return 0;
    cast_cleric_spell(mtmp, dmg, spell, player, map);
  }

  return 1;
}

// cf. mcastu.c:884 — is_undirected_spell(aatyp, spellid)
export function is_undirected_spell(aatyp, spellid) {
  if (aatyp === AT_MAGC) {
    switch (spellid) {
      case MGC_CLONE_WIZ:
      case MGC_SUMMON_MONS:
      case MGC_AGGRAVATION:
      case MGC_DISAPPEAR:
      case MGC_HASTE_SELF:
      case MGC_CURE_SELF:
        return true;
    }
  } else {
    switch (spellid) {
      case CLC_INSECTS:
      case CLC_CURE_SELF:
        return true;
    }
  }
  return false;
}

// cf. mcastu.c:912 — spell_would_be_useless(mtmp, aatyp, spellid)
export function spell_would_be_useless(mtmp, aatyp, spellid) {
  if (aatyp === AT_MAGC) {
    switch (spellid) {
      case MGC_HASTE_SELF:
        return mtmp.mspeed >= 2; // already fast
      case MGC_CURE_SELF:
        return mtmp.mhp >= mtmp.mhpmax; // already at full HP
      case MGC_DISAPPEAR:
        return !!mtmp.minvis; // already invisible
      default:
        return false;
    }
  } else {
    switch (spellid) {
      case CLC_CURE_SELF:
        return mtmp.mhp >= mtmp.mhpmax;
      default:
        return false;
    }
  }
}

// cf. mcastu.c:980 — buzzmu(mtmp, mattk)
// Monster fires a directed beam at hero
export async function buzzmu(mtmp, mattk, player, map) {
  if (!mtmp || !mattk || !player || !map) return 0;
  canonicalizeAttackFields(mattk);

  const adtyp = mattk.adtyp || mattk.ad || mattk.damage || AD_MAGM;
  const nd = Math.max(1, mattk.damn || mattk.dice || 6);
  const dx = Math.sign((player.x || 0) - (mtmp.mx || 0));
  const dy = Math.sign((player.y || 0) - (mtmp.my || 0));
  if (dx === 0 && dy === 0) return 0;

  let ztyp = ZT_MAGIC_MISSILE;
  switch (adtyp) {
  case AD_FIRE: ztyp = ZT_FIRE; break;
  case AD_COLD: ztyp = ZT_COLD; break;
  case AD_SLEE: ztyp = ZT_SLEEP; break;
  case AD_DISN: ztyp = ZT_DEATH; break;
  case AD_ELEC: ztyp = ZT_LIGHTNING; break;
  case AD_DRST: ztyp = ZT_POISON_GAS; break;
  case AD_ACID: ztyp = ZT_ACID; break;
  case AD_MAGM:
  default:
    ztyp = ZT_MAGIC_MISSILE;
    break;
  }

  await buzz(ZT_BREATH(ztyp), nd, mtmp.mx, mtmp.my, dx, dy, map, player);
  return 1;
}

// ── Helper functions ──

// cf. mcastu.c aggravation — wake all monsters
export function aggravation(map) {
  if (!map) return;
  // Would iterate all monsters and set msleeping = false
}

// cf. mcastu.c curse_objects — curse hero inventory items
export function curse_objects(player) {
  if (!player) return;
  // Would iterate inventory and curse random items
}
