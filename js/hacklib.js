// hacklib.js — C ref: hacklib.c xcrypt() trivial text encryption
// Self-inverse XOR cipher used by makedefs to encrypt data files.

// xcrypt: XOR each char that has bit 5 or 6 set with a rotating bitmask
// (1,2,4,8,16). C ref: hacklib.c lines 398-415.
export function xcrypt(str) {
    let result = '';
    let bitmask = 1;
    for (let i = 0; i < str.length; i++) {
        let ch = str.charCodeAt(i);
        if (ch & (32 | 64)) ch ^= bitmask;
        if ((bitmask <<= 1) >= 32) bitmask = 1;
        result += String.fromCharCode(ch);
    }
    return result;
}

// Strip trailing underscores added by makedefs padding.
// C ref: rumors.c unpadline() — strips trailing '_' characters.
export function unpadline(str) {
    return str.replace(/_+$/, '');
}

// Parse a makedefs-compiled encrypted data file (epitaph, engrave, etc.).
// Format: 1 header line (skipped) + N encrypted+padded data lines.
// Returns { texts: string[], lineBytes: number[], chunksize: number }
export function parseEncryptedDataFile(fileText) {
    const allLines = fileText.split('\n');
    // Skip header line ("# This data file is generated by makedefs...")
    // and trailing empty string from final newline
    const dataLines = allLines.slice(1).filter(l => l.length > 0);
    const texts = [];
    const lineBytes = [];
    for (const line of dataLines) {
        const decrypted = unpadline(xcrypt(line));
        texts.push(decrypted);
        lineBytes.push(line.length + 1); // +1 for newline byte in file
    }
    const chunksize = lineBytes.reduce((a, b) => a + b, 0);
    return { texts, lineBytes, chunksize };
}

// Parse the makedefs-compiled rumors file which has two sections (true + false).
// Format: header line, index line, then true rumors followed by false rumors.
// Index line: "%04d,%06ld,%06lx;%04d,%06ld,%06lx;0,0,%06lx"
//   = trueCount(dec), trueSize(dec), trueOffset(hex);
//     falseCount(dec), falseSize(dec), falseOffset(hex); 0,0,eofOffset(hex)
// Returns { trueTexts, trueLineBytes, trueSize, falseTexts, falseLineBytes, falseSize }
export function parseRumorsFile(fileText) {
    const allLines = fileText.split('\n');
    // Line 0: "# This data file..." header (skipped)
    // Line 1: index line with section sizes and offsets
    const indexLine = allLines[1];
    const [truePart, falsePart] = indexLine.split(';');
    const trueParts = truePart.split(',');
    const falseParts = falsePart.split(',');
    const trueSize = parseInt(trueParts[1], 10);
    const falseSize = parseInt(falseParts[1], 10);

    // Data lines start at line 2
    const dataLines = allLines.slice(2).filter(l => l.length > 0);

    const trueTexts = [];
    const trueLineBytes = [];
    const falseTexts = [];
    const falseLineBytes = [];
    let cumBytes = 0;

    for (const line of dataLines) {
        const bytes = line.length + 1; // +1 for newline
        const decrypted = unpadline(xcrypt(line));
        if (cumBytes < trueSize) {
            trueTexts.push(decrypted);
            trueLineBytes.push(bytes);
        } else {
            falseTexts.push(decrypted);
            falseLineBytes.push(bytes);
        }
        cumBytes += bytes;
    }

    return { trueTexts, trueLineBytes, trueSize, falseTexts, falseLineBytes, falseSize };
}
