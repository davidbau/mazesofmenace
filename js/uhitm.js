// uhitm.js -- Hero-vs-monster combat
// cf. uhitm.c — attack validation, to-hit/damage, damage-type handlers,
// engulfment, passive defense, mimic discovery, light attacks

import { rn2, rnd, d, c_d } from './rng.js';
import { exercise } from './attrib_exercise.js';
import { corpse_chance } from './mon.js';
import {
    A_STR, A_DEX, PM_MONK,
    FIRE_RES, COLD_RES, SHOCK_RES, ACID_RES, FREE_ACTION,
} from './config.js';
import { spec_abon, spec_dbon } from './artifact.js';
import {
    G_FREQ, G_NOCORPSE, MZ_TINY, MZ_HUMAN, MZ_LARGE, M2_COLLECT,
    S_ZOMBIE, S_MUMMY, S_VAMPIRE, S_WRAITH, S_LICH, S_GHOST, S_DEMON, S_KOP,
    S_LIGHT, S_MIMIC, S_NYMPH, S_GOLEM,
    PM_SHADE, PM_FLOATING_EYE, PM_GREMLIN,
    PM_BLACK_PUDDING, PM_BROWN_PUDDING, PM_IRON_GOLEM,
    AD_PHYS, AD_MAGM, AD_FIRE, AD_COLD, AD_SLEE, AD_DISN, AD_ELEC,
    AD_DRST, AD_ACID, AD_BLND, AD_STUN, AD_SLOW, AD_PLYS, AD_DRLI,
    AD_DREN, AD_LEGS, AD_STON, AD_STCK, AD_SGLD, AD_SITM, AD_SEDU,
    AD_TLPT, AD_RUST, AD_CONF, AD_DGST, AD_HEAL, AD_WRAP, AD_WERE,
    AD_DRDX, AD_DRCO, AD_DRIN, AD_DISE, AD_DCAY, AD_SSEX, AD_HALU,
    AD_DETH, AD_PEST, AD_FAMN, AD_SLIM, AD_ENCH, AD_CORR, AD_POLY,
    AD_SAMU, AD_CURS,
    AT_NONE, AT_WEAP, AT_CLAW, AT_KICK, AT_BITE, AT_TUCH, AT_BUTT, AT_STNG,
    AT_HUGS, AT_TENT, AT_ENGL, AT_EXPL, AT_BREA, AT_SPIT, AT_GAZE,
    AT_BOOM, AT_MAGC,
} from './monsters.js';
import {
    CORPSE, FIGURINE, FOOD_CLASS, objectData,
    POTION_CLASS, POT_HEALING, POT_EXTRA_HEALING, POT_FULL_HEALING,
    POT_RESTORE_ABILITY, POT_GAIN_ABILITY,
    BOULDER, HEAVY_IRON_BALL, IRON_CHAIN, MIRROR, CLOVE_OF_GARLIC,
    SILVER, IRON, METAL, VEGGY, PAPER,
    WEAPON_CLASS, GEM_CLASS, SPBOOK_CLASS, COIN_CLASS,
} from './objects.js';
import { mkobj, mkcorpstat, RANDOM_CLASS, next_ident, xname } from './mkobj.js';
import { hitval as weapon_hitval, dmgval, abon, dbon, weapon_hit_bonus, weapon_dam_bonus } from './weapon.js';
import {
    nonliving, x_monnam, y_monnam, is_undead, is_demon,
    magic_negation,
    resists_fire, resists_cold, resists_elec, resists_acid,
    resists_poison, resists_sleep, resists_ston,
    thick_skinned, mon_hates_silver, mon_hates_light,
    noncorporeal, amorphous, unsolid, haseyes, dmgtype, is_orc,
} from './mondata.js';
import { obj_resists } from './objdata.js';
import { newexplevel } from './exper.js';
import { applyMonflee } from './mhitu.js';
import { mondead } from './monutil.js';
import { placeFloorObject } from './floor_objects.js';
import { uwepgone, uswapwepgone, uqwepgone } from './wield.js';
import { find_mac } from './worn.js';
import { make_stunned } from './potion.js';
import {
    erode_obj, ERODE_BURN, ERODE_RUST, ERODE_ROT, ERODE_CORRODE,
    EF_GREASE, EF_VERBOSE,
} from './trap.js';
import { tmp_at, nh_delay_output, DISP_ALWAYS, DISP_END } from './animation.js';
import { canonicalizeAttackFields } from './attack_fields.js';


// ============================================================================
// 1. Magic negation and attack result constants
// ============================================================================

// C ref: monattk.h — monster-to-monster attack result bitmask
export const M_ATTK_MISS = 0x0;
export const M_ATTK_HIT = 0x1;
export const M_ATTK_DEF_DIED = 0x2;
export const M_ATTK_AGR_DIED = 0x4;
export const M_ATTK_AGR_DONE = 0x8;

// cf. uhitm.c:74 — mhitm_mgc_atk_negated(magr, mdef, verbosely):
//   Check if a magical attack is negated by target's magic cancellation.
//   Consumes rn2(10) — RNG-critical.
//   Returns true if attack is negated.
export function mhitm_mgc_atk_negated(magr, mdef) {
    if (magr.mcan) return true;
    const armpro = magic_negation(mdef);
    const negated = !(rn2(10) >= 3 * armpro);
    return negated;
}


// ============================================================================
// 2. Attack validation
// ============================================================================

// cf. uhitm.c:103 — dynamic_multi_reason(mon, verb, by_gaze):
//   Build reason string for multi-turn delay after special attacks.
//   In JS, multi_reason is not used for the same purpose. Stub for parity.
export function dynamic_multi_reason(mon, verb, by_gaze) {
    // C builds a formatted string like "frozen by a <monster>'s gaze"
    // for use with nomul(). In JS we don't use multi_reason strings.
    const name = x_monnam(mon);
    const reason = by_gaze
        ? `${verb} by ${name}'s gaze`
        : `${verb} by ${name}`;
    return reason;
}

// cf. uhitm.c:125 — erode_armor(mdef, hurt):
//   Erode target's armor from acid/rust/fire damage.
//   C loops rn2(5) until it finds a valid armor slot to erode.
//   In JS, armor erosion is not fully modeled; consume rn2(5) for RNG parity.
export function erode_armor(mdef, hurt) {
    // C: while(1) { switch(rn2(5)) { ... break; } break; }
    // The loop always consumes exactly one rn2(5) in practice (it loops
    // only if the chosen slot has no armor or armor is already fully eroded,
    // which we can't check without full armor tracking). Consume one call.
    rn2(5);
}

// cf. uhitm.c:188 — attack_checks(mtmp, wep):
//   Pre-attack validation: peaceful/tame checks, displacement, invisibility.
//   Returns true if the attack should be aborted.
//   In JS, attack validation is handled upstream in the move system.
//   This stub always returns false (OK to attack).
export function attack_checks(mtmp, wep, opts = {}) {
    const player = opts.player || null;
    const display = opts.display || null;
    const context = opts.context || null;
    const pets_too = !!opts.pets_too;
    const forcefight = !!(context && context.forcefight);
    // C: alerts waiting monster, checks forcefight, invisible, mimic, peaceful
    if (mtmp.mstrategy) mtmp.mstrategy &= ~0x08000000; // ~STRAT_WAITMASK
    if (!mtmp) return true;
    if (mtmp.msleeping) mtmp.msleeping = 0;

    // C-style safety gates: don't auto-attack tame/peaceful unless forced.
    if (!forcefight) {
        if (mtmp.tame && !pets_too) {
            if (display) display.putstr_message('You stop. Your pet is in the way!');
            return true;
        }
        if (mtmp.peaceful && !pets_too) {
            if (display) display.putstr_message(`Really attack ${x_monnam(mtmp)}?`);
            return true;
        }
    }

    // Mimic/undetected reveal side effect.
    if (mtmp.mundetected) mtmp.mundetected = false;
    if (player && mtmp.mx === player.x && mtmp.my === player.y) {
        // Displaced/invisible confusion guard: don't attack own square.
        return true;
    }
    return false;
}

// cf. uhitm.c:330 — check_caitiff(mtmp):
//   Alignment penalty for attacking a fleeing or helpless monster.
//   Knight attacking defenseless = "You caitiff!" + alignment -1
//   Samurai attacking peaceful = "You dishonorably attack!" + alignment -1
export function check_caitiff(mtmp) {
    // In JS, role-specific alignment penalties are not yet tracked.
    // Stub: no effect.
}

// cf. uhitm.c:350 — mon_maybe_unparalyze(mtmp):
//   Wake up paralyzed monster on being attacked.
function mon_maybe_unparalyze(mon) {
    if (mon.mcanmove === false) {
        if (!rn2(10)) {
            mon.mcanmove = true;
            mon.mfrozen = 0;
        }
    }
}

// cf. uhitm.c:364 — find_roll_to_hit(mtmp, aatyp, weapon, attk_count, role_roll_penalty)
//   Compute to-hit modifier for hero attacking monster.
//   Returns tmp where hit = (tmp > rnd(20)).
function find_roll_to_hit(player, mtmp, aatyp, weapon) {
    // cf. uhitm.c:375 — base formula:
    //   tmp = 1 + abon() + find_mac(mtmp) + u.uhitinc
    //         + Luck_bonus + u.ulevel
    const str = player.attributes?.[A_STR] ?? 10;
    const dex = player.attributes?.[A_DEX] ?? 10;
    let tmp = 1 + abon(str, dex, player.ulevel)
        + find_mac(mtmp)
        + (player.uhitinc || 0) // rings of increase accuracy etc.
        + luckBonus(player.luck || 0)
        + player.ulevel;

    // cf. uhitm.c:386-393 — monster state adjustments
    if (mtmp.stunned || mtmp.mstun) tmp += 2;
    if (mtmp.flee || mtmp.mflee) tmp += 2;
    if (mtmp.sleeping || mtmp.msleeping) tmp += 2;
    if (mtmp.mcanmove === false) tmp += 4;

    // cf. uhitm.c:396-404 — role/race adjustments
    // Monk: bonus when unarmed; heavy penalty if armored.
    if ((player.roleIndex === PM_MONK) && !weapon) {
        tmp += Math.floor((player.ulevel || 1) / 3) + 2;
        const armored = !!(player.armor || player.suit || player.cloak
            || player.helmet || player.gloves || player.boots || player.shield);
        if (armored) tmp -= 20;
    }
    // Elf hero bonus vs orcs.
    const isElfHero = player.race === 'elf' || player.raceName === 'elf' || player.raceIndex === 1;
    if (isElfHero && is_orc(mtmp?.type || {})) tmp += 1;

    // cf. uhitm.c:407-410 — encumbrance and trap penalties
    // In JS, current encumbrance level is tracked in player.wc (0..5).
    if (Number.isInteger(player.wc) && player.wc > 0) tmp -= player.wc;
    if (player.utrap) tmp -= 3;

    // cf. uhitm.c:417-423 — weapon bonuses
    if (aatyp === AT_WEAP || aatyp === AT_CLAW) {
        if (weapon) tmp += weapon_hitval(weapon, mtmp);
        else tmp += weaponEnchantment(weapon); // fallback for bare-handed
        tmp += weapon_hit_bonus(weapon); // skill-based (stub: returns 0)
        // cf. uhitm.c:423 — artifact to-hit bonus
        if (weapon && weapon.oartifact) tmp += spec_abon(weapon, mtmp);
    }

    return tmp;
}

// cf. uhitm.c:431 — force_attack(mtmp, pets_too):
//   Force attack on a monster in the way (e.g. 'F' prefix).
//   Temporarily sets forcefight flag, calls do_attack, restores flag.
export function force_attack(mtmp, pets_too, player = null, display = null, map = null, context = null) {
    if (!mtmp || !player) return false;
    const ctx = context || {};
    const save = !!ctx.forcefight;
    ctx.forcefight = true;
    const attacked = !!do_attack(player, mtmp, display, map, { context: ctx, pets_too });
    ctx.forcefight = save;
    return attacked;
}

// cf. uhitm.c:447 — do_attack(mtmp):
//   Top-level attack dispatcher: checks, weapon selection, special cases.
//   Partially implemented via hmon() below.
//   Full implementation would handle: attack_checks, capacity, poly attacks,
//   leprechaun dodge, hitum/hmonas dispatch, invisible monster mapping.
export function do_attack(player, mtmp, display, map, opts = {}) {
    if (!player || !mtmp) return false;
    const context = opts.context || null;
    const pets_too = !!opts.pets_too;
    const game = opts.game || null;
    if (attack_checks(mtmp, player.weapon || null, {
        player, display, map, context, pets_too,
    })) {
        return false;
    }
    // Delegate to hmon for the normal case
    return do_attack_core(player, mtmp, display, map, game);
}


// ============================================================================
// 3. Core hit mechanics
// ============================================================================

// HMON_xxx thrown constants (cf. hack.h)
const HMON_MELEE = 0;
const HMON_THROWN = 1;
const HMON_KICKED = 2;
const HMON_APPLIED = 3;

// cf. uhitm.c:586 — known_hitum(mon, weapon, mhit, rollneeded, armorpenalty, uattk, dieroll):
//   Handle known-hit path: exercise, cleave, flee check after hit.
//   Returns true if monster survives, false if dead.
function known_hitum(player, mon, weapon, mhit, rollneeded, armorpenalty, uattk, dieroll, display, map) {
    let malive = true;

    if (!mhit) {
        // Miss path
        missum_internal(player, mon, uattk, (rollneeded + armorpenalty > dieroll), display);
    } else {
        const oldhp = mon.mhp;
        // Hit: call hmon
        malive = hmon(player, mon, weapon, HMON_MELEE, dieroll, display, map);
        if (malive) {
            // cf. uhitm.c:624-628 — 1/25 flee check
            if (!rn2(25) && mon.mhp < Math.floor((mon.mhpmax || 1) / 2)) {
                const fleetime = !rn2(3) ? rnd(100) : 0;
                applyMonflee(mon, fleetime, false);
            }
            // Vorpal Blade: hit converted to miss if hp unchanged
            if (mon.mhp === oldhp) {
                mhit = 0;
            }
        }
    }
    return malive;
}

// cf. uhitm.c:650 — hitum_cleave(target, uattk):
//   Cleaving attack: hit adjacent monsters with two-handed weapon.
//   In JS, cleaving is not yet supported (requires Cleaver artifact).
//   Stub: returns true (target survived).
function hitum_cleave(target, uattk) {
    return true;
}

// cf. uhitm.c:735 — double_punch():
//   Check for martial arts double punch chance.
//   Requires unarmed, no shield, skilled+ in bare-handed combat.
//   In JS, skill levels are not yet tracked. Always returns false.
function double_punch() {
    // C: if (!uwep && !uarms && P_SKILL(P_BARE_HANDED_COMBAT) > P_BASIC)
    //       return (skl_lvl - P_BASIC) > rn2(5);
    return false;
}

// cf. uhitm.c:757 — hitum(mon, uattk):
//   Main melee hit routine: roll to-hit, call known_hitum or miss.
//   Returns true if monster survives.
function hitum(player, mon, uattk, display, map, game = null) {
    const weapon = player.weapon;
    // cf. uhitm.c:775 — twohits: double punch or two-weapon
    // const twohits = (weapon ? !!player.twoweap : double_punch()) ? 1 : 0;

    const tmp = find_roll_to_hit(player, mon, uattk?.type ?? AT_WEAP, weapon);
    mon_maybe_unparalyze(mon);
    const dieroll = rnd(20);
    const mhit = (tmp > dieroll);
    if (tmp > dieroll) exercise(player, A_DEX, true);

    const malive = known_hitum(player, mon, weapon, mhit, tmp, 0, uattk, dieroll, display, map);
    passive(mon, weapon, mhit, malive, uattk?.type ?? AT_WEAP, false, {
        player, display, map, game,
    });

    // TODO: second attack for two-weapon or double punch
    return malive;
}

// cf. uhitm.c:818 — hmon(mon, obj, thrown, dieroll):
//   Wrapper for hmon_hitmon: applies object damage to monster.
//   Returns true if monster survives.
export function hmon(player, mon, obj, thrown, dieroll, display, map) {
    return hmon_hitmon(player, mon, obj, thrown, dieroll, display, map);
}

// cf. uhitm.c:837 — hmon_hitmon_barehands(hmd, mon):
//   Bare-handed damage: martial arts gives 1d4, otherwise 1d2.
//   Also checks blessed gloves and silver rings for bonus.
function hmon_hitmon_barehands(hmd, mon) {
    if ((mon.mndx ?? -1) === PM_SHADE) {
        hmd.dmg = 0;
    } else {
        // C: rnd(!martial_bonus() ? 2 : 4) — martial arts not tracked in JS
        hmd.dmg = rnd(2);
        hmd.use_weapon_skill = true;
        hmd.train_weapon_skill = (hmd.dmg > 1);
    }
    // C: silver ring / blessed glove bonuses — simplified, no ring system
    hmd.barehand_silver_rings = 0;
}

// cf. uhitm.c:884 — hmon_hitmon_weapon_ranged(hmd, mon, obj):
//   Ranged weapon used in melee: rnd(2) base damage.
function hmon_hitmon_weapon_ranged(hmd, mon, obj) {
    if ((mon.mndx ?? -1) === PM_SHADE) {
        hmd.dmg = 0;
    } else {
        hmd.dmg = rnd(2);
    }
    const material = objectData[obj.otyp]?.material;
    if (material === SILVER && mon_hates_silver(mon)) {
        hmd.silvermsg = true;
        hmd.silverobj = true;
        hmd.dmg += rnd(hmd.dmg ? 20 : 10);
    }
}

// cf. uhitm.c:919 — hmon_hitmon_weapon_melee(hmd, mon, obj):
//   Melee weapon damage: dmgval, enchantment, blessed vs undead, silver, etc.
function hmon_hitmon_weapon_melee(hmd, mon, obj) {
    hmd.use_weapon_skill = true;
    hmd.dmg = dmgval(obj, mon);
    hmd.train_weapon_skill = (hmd.dmg > 1);

    // cf. uhitm.c:993-1011 — artifact hit
    // artifact_hit() not yet ported; skip

    const material = objectData[obj.otyp]?.material;
    if (material === SILVER && mon_hates_silver(mon)) {
        hmd.silvermsg = true;
        hmd.silverobj = true;
    }
    if (obj.lamplit && mon_hates_light(mon)) {
        hmd.lightobj = true;
    }
    // cf. uhitm.c:1039-1044 — poison from thrown/wielded poisoned weapon
    if (obj.opoisoned && hmd.dieroll <= 5) {
        hmd.ispoisoned = true;
    }
}

// cf. uhitm.c:1048 — hmon_hitmon_weapon(hmd, mon, obj):
//   Dispatch weapon hit to ranged or melee sub-handler.
function hmon_hitmon_weapon(hmd, mon, obj) {
    if (usesRangedMeleeDamage(obj)) {
        hmon_hitmon_weapon_ranged(hmd, mon, obj);
    } else {
        hmon_hitmon_weapon_melee(hmd, mon, obj);
    }
}

// cf. uhitm.c:1073 — hmon_hitmon_potion(hmd, mon, obj):
//   Potion used as melee weapon: potionhit() then 1 damage (0 vs shade).
function hmon_hitmon_potion(hmd, mon, obj, player, display) {
    // Use existing hitMonsterWithPotion for the potion effect
    hitMonsterWithPotion(player, mon, display, obj);
    hmd.hittxt = true;
    hmd.dmg = (mon.mndx ?? -1) === PM_SHADE ? 0 : 1;
}

// cf. uhitm.c:1097 — hmon_hitmon_misc_obj(hmd, mon, obj):
//   Miscellaneous object as weapon: cockatrice corpse, cream pie, etc.
function hmon_hitmon_misc_obj(hmd, mon, obj) {
    switch (obj.otyp) {
    case BOULDER:
    case HEAVY_IRON_BALL:
    case IRON_CHAIN:
        hmd.dmg = dmgval(obj, mon);
        break;
    case MIRROR:
        hmd.dmg = 1;
        break;
    case CORPSE:
        // cf. uhitm.c:1152 — corpse damage = msize + 1
        hmd.dmg = ((obj.corpsenm != null && objectData[obj.otyp]) ? 1 : 0) + 1;
        break;
    case CLOVE_OF_GARLIC:
        // cf. uhitm.c:1238 — garlic vs undead: flee
        if (is_undead(mon.type || {})) {
            applyMonflee(mon, d(2, 4), false);
        }
        hmd.dmg = 1;
        break;
    default: {
        // cf. uhitm.c:1320-1360 — generic non-weapon: weight-based damage
        const material = objectData[obj.otyp]?.material;
        if ((material === VEGGY || material === PAPER)
            && (obj.oclass !== SPBOOK_CLASS)) {
            hmd.dmg = 0;
            hmd.get_dmg_bonus = false;
            break;
        }
        hmd.dmg = Math.floor((obj.owt || 0) + 99) / 100;
        hmd.dmg = Math.floor(hmd.dmg);
        hmd.dmg = (hmd.dmg <= 1) ? 1 : rnd(hmd.dmg);
        if (hmd.dmg > 6) hmd.dmg = 6;
        if (material === SILVER && mon_hates_silver(mon)) {
            hmd.dmg += rnd(20);
            hmd.silvermsg = true;
            hmd.silverobj = true;
        }
        break;
    }
    }
}

// cf. uhitm.c:1365 — hmon_hitmon_do_hit(hmd, mon, obj):
//   Top-level dispatch: bare hands or object (weapon/potion/misc).
function hmon_hitmon_do_hit(hmd, mon, obj, player, display) {
    if (!obj) {
        hmon_hitmon_barehands(hmd, mon);
    } else {
        const oclass = obj.oclass ?? objectData[obj.otyp]?.oclass;
        if (oclass === WEAPON_CLASS || oclass === GEM_CLASS) {
            hmon_hitmon_weapon(hmd, mon, obj);
        } else if (oclass === POTION_CLASS) {
            hmon_hitmon_potion(hmd, mon, obj, player, display);
        } else {
            if ((mon.mndx ?? -1) === PM_SHADE && !shade_aware(obj)) {
                hmd.dmg = 0;
            } else {
                hmon_hitmon_misc_obj(hmd, mon, obj);
            }
        }
    }
}

// cf. uhitm.c:1414 — hmon_hitmon_dmg_recalc(hmd, obj):
//   Recalculate damage after enchantment/bonus adjustments.
//   Adds strength bonus (dbon) and weapon skill bonus.
function hmon_hitmon_dmg_recalc(hmd, obj, player) {
    let dmgbonus = 0;
    if (hmd.get_dmg_bonus) {
        // Strength bonus
        dmgbonus += dbon(player.attributes?.[A_STR] ?? 10);
        // udaminc (ring of increase damage) — not yet tracked
        dmgbonus += (player.udaminc || 0);
    }
    if (hmd.use_weapon_skill) {
        dmgbonus += weapon_dam_bonus(obj);
    }
    hmd.dmg += dmgbonus;
    if (hmd.dmg < 1) hmd.dmg = 1;
}

// cf. uhitm.c:1488 — hmon_hitmon_poison(hmd, mon, obj):
//   Apply poison from poisoned weapon to monster.
function hmon_hitmon_poison(hmd, mon, obj) {
    // C: nopoison = max(2, 10 - owt/10); if !rn2(nopoison) remove poison
    const nopoison = Math.max(2, 10 - Math.floor((obj.owt || 0) / 10));
    if (!rn2(nopoison)) {
        obj.opoisoned = false;
        hmd.unpoisonmsg = true;
    }
    if (resists_poison(mon)) {
        hmd.needpoismsg = true;
    } else if (rn2(10)) {
        hmd.dmg += rnd(6);
    } else {
        hmd.poiskilled = true;
    }
}

// cf. uhitm.c:1519 — hmon_hitmon_jousting(hmd, mon, obj):
//   Jousting bonus damage with lance while riding.
//   In JS, riding/jousting is not yet implemented.
function hmon_hitmon_jousting(hmd, mon, obj) {
    hmd.dmg += d(2, 10);
    hmd.hittxt = true;
}

// cf. uhitm.c:1548 — hmon_hitmon_stagger(hmd, mon, obj):
//   VERY small chance of stunning opponent if unarmed.
//   Consumes rnd(100) for RNG parity.
function hmon_hitmon_stagger(hmd, mon, obj) {
    // C: if (rnd(100) < P_SKILL(P_BARE_HANDED_COMBAT) && !bigmonst && !thick_skinned)
    // In JS, skill levels not tracked, so just consume the RNG
    rnd(100);
}

// cf. uhitm.c:1566 — hmon_hitmon_pet(hmd, mon, obj):
//   Adjust behavior when hitting a pet.
function hmon_hitmon_pet(hmd, mon, obj) {
    if (mon.mtame && hmd.dmg > 0) {
        // C: abuse_dog(mon) — reduces tameness
        if (mon.mtame > 0) mon.mtame--;
        // C: monflee if still tame and not destroyed
        if (mon.mtame && !hmd.destroyed) {
            applyMonflee(mon, 10 * rnd(hmd.dmg), false);
        }
    }
}

// cf. uhitm.c:1582 — hmon_hitmon_splitmon(hmd, mon, obj):
//   Handle pudding splitting on hit with iron/metal weapon.
//   In JS, clone_mon is not yet implemented. Stub: no splitting.
function hmon_hitmon_splitmon(hmd, mon, obj) {
    // C: black/brown pudding splits when hit with iron weapon
    // Requires clone_mon() which is not yet available in JS.
}

// cf. uhitm.c:1615 — hmon_hitmon_msg_hit(hmd, mon, obj):
//   Generate "You hit the <monster>" message.
function hmon_hitmon_msg_hit(hmd, mon, obj, display) {
    if (!hmd.hittxt && !hmd.destroyed) {
        const name = x_monnam(mon);
        display.putstr_message(`You hit the ${name}.`);
    }
}

// cf. uhitm.c:1641 — hmon_hitmon_msg_silver(hmd, mon, obj):
//   "The silver sears <monster>!" message.
function hmon_hitmon_msg_silver(hmd, mon, obj, display) {
    const name = x_monnam(mon);
    const ptr = mon.type || {};
    let whom = name;
    if (!noncorporeal(ptr) && !amorphous(ptr)) {
        whom = `${name}'s flesh`;
    }
    if (hmd.silverobj && obj) {
        const oname = xname(obj);
        display.putstr_message(`Your ${oname} sears ${whom}!`);
    } else if (hmd.barehand_silver_rings > 0) {
        display.putstr_message(`Your silver ring sears ${whom}!`);
    } else {
        display.putstr_message(`The silver sears ${whom}!`);
    }
}

// cf. uhitm.c:1680 — hmon_hitmon_msg_lightobj(hmd, mon, obj):
//   Light-source weapon message (burning undead, etc).
function hmon_hitmon_msg_lightobj(hmd, mon, obj, display) {
    const name = x_monnam(mon);
    const ptr = mon.type || {};
    let whom = name;
    if (!noncorporeal(ptr) && !amorphous(ptr)) {
        whom = `${name}'s flesh`;
    }
    display.putstr_message(`The light sears ${whom}!`);
}

// cf. uhitm.c:1732 — hmon_hitmon(mon, obj, thrown, dieroll):
//   Core hit-monster dispatcher.
//   Returns true if monster survives, false if dead.
function hmon_hitmon(player, mon, obj, thrown, dieroll, display, map) {
    const hmd = {
        dmg: 0,
        thrown: thrown,
        twohits: 0,
        dieroll: dieroll,
        mdat: mon.type || {},
        use_weapon_skill: false,
        train_weapon_skill: false,
        barehand_silver_rings: 0,
        silvermsg: false,
        silverobj: false,
        lightobj: false,
        jousting: 0,
        hittxt: false,
        get_dmg_bonus: true,
        unarmed: !player.weapon && !player.armor && !player.shield,
        hand_to_hand: (thrown === HMON_MELEE),
        ispoisoned: false,
        unpoisonmsg: false,
        needpoismsg: false,
        poiskilled: false,
        already_killed: false,
        offmap: false,
        destroyed: false,
        dryit: false,
        doreturn: false,
        retval: false,
        saved_oname: '',
    };

    // Phase 1: compute base damage
    hmon_hitmon_do_hit(hmd, mon, obj, player, display);
    if (hmd.doreturn) return hmd.retval;

    // Phase 2: add bonuses
    if (hmd.dmg > 0) {
        hmon_hitmon_dmg_recalc(hmd, obj, player);
    }

    // Phase 3: poison
    if (hmd.ispoisoned && obj) {
        hmon_hitmon_poison(hmd, mon, obj);
    }

    // Phase 4: minimum damage / shade handling
    if (hmd.dmg < 1) {
        const monIsShade = (mon.mndx ?? -1) === PM_SHADE;
        hmd.dmg = (hmd.get_dmg_bonus && !monIsShade) ? 1 : 0;
    }

    // Phase 5: jousting / stagger / knockback
    if (hmd.jousting) {
        hmon_hitmon_jousting(hmd, mon, obj);
    } else if (hmd.unarmed && hmd.dmg > 1 && !thrown) {
        hmon_hitmon_stagger(hmd, mon, obj);
    }
    // knockback for armed melee is handled in hmon

    // Phase 6: apply damage
    if (!hmd.already_killed) {
        // Artifact damage bonus
        if (obj && obj.oartifact && !usesRangedMeleeDamage(obj)) {
            const [bonus] = spec_dbon(obj, mon, hmd.dmg);
            hmd.dmg += bonus;
        }
        mon.mhp -= hmd.dmg;
    }
    if (mon.mhp > (mon.mhpmax || mon.mhp))
        mon.mhp = mon.mhpmax || mon.mhp;

    if (mon.mhp <= 0) hmd.destroyed = true;

    // Phase 7: pet handling
    hmon_hitmon_pet(hmd, mon, obj);

    // Phase 8: pudding splitting
    hmon_hitmon_splitmon(hmd, mon, obj);

    // Phase 9: messages
    if (display) {
        hmon_hitmon_msg_hit(hmd, mon, obj, display);
        if (hmd.silvermsg) hmon_hitmon_msg_silver(hmd, mon, obj, display);
        if (hmd.lightobj) hmon_hitmon_msg_lightobj(hmd, mon, obj, display);
    }

    // Phase 10: poison kill / normal kill
    if (hmd.poiskilled) {
        if (!hmd.already_killed && mon.mhp > 0) {
            mon.mhp = 0;
        }
        hmd.destroyed = true;
    }
    if (hmd.destroyed && !hmd.already_killed) {
        // Kill handled by caller (hmon)
    }

    return hmd.destroyed ? false : true;
}


// ============================================================================
// 4. Special hit mechanics
// ============================================================================

// cf. uhitm.c:1920 — mhurtle_to_doom(mon, tmp, mptr):
//   Joust or martial arts knockback that might kill 'mon' via trap.
//   Only hurtles if pending damage won't already kill mon.
//   Returns true if mon dies from the hurtle.
function mhurtle_to_doom(mon, tmp, mptr) {
    // C: if (tmp < mon->mhp) mhurtle(mon, u.dx, u.dy, 1);
    // In JS, mhurtle (movement into traps) is not yet ported.
    // Stub: no hurtle, mon doesn't die from it.
    return false;
}

// cf. uhitm.c:1941 — first_weapon_hit(weapon):
//   Gamelog message for breaking never-hit-with-wielded-weapon conduct.
//   In JS, conducts and livelog are not tracked. Stub: no-op.
function first_weapon_hit(weapon) {
    // C: livelog_printf(LL_CONDUCT, "hit with a wielded weapon (%s) for the first time", buf);
}

// cf. uhitm.c:1970 — shade_aware(obj):
//   Check if object can affect a shade (silver, blessed, artifact).
//   Objects in this list either affect shades or are handled specially.
// TRANSLATOR: AUTO
export function shade_aware(obj) {
    if (!obj) return false;
    if (obj.otyp === BOULDER
        || obj.otyp === HEAVY_IRON_BALL
        || obj.otyp === IRON_CHAIN
        || obj.otyp === MIRROR
        || obj.otyp === CLOVE_OF_GARLIC)
        return true;
    const material = objectData[obj.otyp]?.material;
    if (material === SILVER) return true;
    return false;
}

// cf. uhitm.c:1994 — shade_miss(magr, mdef, obj, thrown, verbose):
//   Miss message when attacking shade with non-effective weapon.
//   Returns true if the attack passes harmlessly through the shade.
export function shade_miss(magr, mdef, obj, thrown, verbose) {
    // Check if mdef is a shade and obj can't damage it
    if ((mdef.mndx ?? -1) !== PM_SHADE) return false;
    if (obj && dmgval(obj, mdef)) return false;

    if (verbose) {
        const what = (!obj || shade_aware(obj)) ? 'attack' : xname(obj);
        const target = x_monnam(mdef);
        if (!thrown) {
            // "Your <what> passes harmlessly through <target>."
        } else {
            // "The <what> passes harmlessly through <target>."
        }
    }
    return true;
}

// cf. uhitm.c:2034 — m_slips_free(mdef, mattk):
//   Check if slippery clothing (greased/oilskin) protects from grab/wrap.
//   In JS, greased armor is not fully modeled. Stub: always returns false.
function m_slips_free(mdef, mattk) {
    return false;
}

// cf. uhitm.c:2076 — joust(mon, obj):
//   Jousting check: lance + riding + skill = bonus damage or lance break.
//   Returns: 1 = successful joust, 0 = no joust, -1 = joust but lance breaks.
//   In JS, riding/jousting is not yet implemented. Always returns 0.
function joust(mon, obj) {
    // C: requires mounted (u.usteed), lance weapon, not fumbling/stunned
    return 0;
}

// cf. uhitm.c:2111 — demonpet():
//   Demon summoning when hero is a demon and attacks.
//   Summons a demon pet. In JS, demon summoning is not yet ported.
function demonpet() {
    // C: pline("Some hell-p has arrived!"); makemon(demon, u.ux, u.uy); tamedog()
    // Stub: no demon summoning
}

// cf. uhitm.c:2126 — theft_petrifies(otmp):
//   Check if stealing a corpse would petrify the thief.
//   Returns true if the theft would cause petrification.
function theft_petrifies(otmp) {
    // C: checks uarmg, corpse type, touch_petrifies, Stone_resistance
    // Simplified: always safe (petrification system not fully ported)
    return false;
}

// cf. uhitm.c:2152 — steal_it(mdef, mattk):
//   Hero steal-attack (nymph polymorph form, etc).
//   Takes items from monster's inventory.
//   In JS, polymorphed hero attacks are not yet fully supported.
function steal_it(mdef, mattk) {
    // C: iterates mdef->minvent, extracts items to hero inventory
    // Stub: no stealing
}


// ============================================================================
// 5. Damage-type handlers (mhitm_ad_*)
// ============================================================================
// These handlers implement the m-vs-m (monster-vs-monster) combat path.
// Each takes (magr, mattk, mdef, mhm) where mhm is:
//   { damage, hitflags, done, permdmg, specialdmg, dieroll }
// The uhitm (u-vs-m) and mhitu (m-vs-u) paths remain in hmon()
// and mattacku() respectively.

// cf. uhitm.c:3959 — physical damage handler
// m-vs-m branch: uhitm.c:4106-4177
export function mhitm_ad_phys(magr, mattk, mdef, mhm) {
    const pd = mdef.type || {};
    if (mattk.aatyp === AT_KICK && thick_skinned(pd)) {
        mhm.damage = 0;
    }
}

// cf. uhitm.c:2499 — fire damage handler
// m-vs-m branch: uhitm.c:2565-2600
export function mhitm_ad_fire(magr, mattk, mdef, mhm) {
    if (mhitm_mgc_atk_negated(magr, mdef)) {
        mhm.damage = 0;
        return;
    }
    if (resists_fire(mdef)) {
        mhm.damage = 0;
    }
}

// cf. uhitm.c:2604 — cold damage handler
// m-vs-m branch: uhitm.c:2642-2658
export function mhitm_ad_cold(magr, mattk, mdef, mhm) {
    if (mhitm_mgc_atk_negated(magr, mdef)) {
        mhm.damage = 0;
        return;
    }
    if (resists_cold(mdef)) {
        mhm.damage = 0;
    }
}

// cf. uhitm.c:2662 — electric damage handler
// m-vs-m branch: uhitm.c:2698-2716
export function mhitm_ad_elec(magr, mattk, mdef, mhm) {
    if (mhitm_mgc_atk_negated(magr, mdef)) {
        mhm.damage = 0;
        return;
    }
    if (resists_elec(mdef)) {
        mhm.damage = 0;
    }
}

// cf. uhitm.c:2720 — acid damage handler
// m-vs-m branch: uhitm.c:2744-2763
export function mhitm_ad_acid(magr, mattk, mdef, mhm) {
    if (magr.mcan) {
        mhm.damage = 0;
        return;
    }
    if (resists_acid(mdef)) {
        mhm.damage = 0;
    }
    // C ref: !rn2(30) erode_armor, !rn2(6) acid_damage — omitted (no armor system)
    rn2(30);
    rn2(6);
}

// cf. uhitm.c:3082 — apply actual poison effects (m-vs-m)
function mhitm_really_poison(magr, mattk, mdef, mhm) {
    if (resists_poison(mdef)) {
        // C ref: if resists, "unaffected" — no damage
        mhm.damage = 0;
        return;
    }
    // C ref: mhitm.c:3094 — m_lev > 0 ? lose a level : take 2d6 damage
    if ((mdef.m_lev || 0) > 0) {
        const mlev = mdef.m_lev || 0;
        mhm.damage = d(2, 6);
        if (mdef.mhpmax > (mlev + 1)) {
            mdef.mhpmax -= mhm.damage;
            if (mdef.mhpmax < (mlev + 1)) mdef.mhpmax = mlev + 1;
        }
    } else {
        mhm.damage = mdef.mhp;
    }
}

// cf. uhitm.c:3100 — poison (AD_DRST/AD_DRDX/AD_DRCO) handler
// m-vs-m branch: uhitm.c:3137-3142
export function mhitm_ad_drst(magr, mattk, mdef, mhm) {
    const negated = mhitm_mgc_atk_negated(magr, mdef);
    if (!negated && !rn2(8)) {
        mhitm_really_poison(magr, mattk, mdef, mhm);
    }
}

// cf. uhitm.c:4366 — stun handler
// m-vs-m branch: uhitm.c:4388-4399
export function mhitm_ad_stun(magr, mattk, mdef, mhm) {
    if (magr.mcan) return;
    mdef.mstun = 1;
    mhitm_ad_phys(magr, mattk, mdef, mhm);
}

// cf. uhitm.c:3668 — confusion handler
// m-vs-m branch: uhitm.c:3691-3703
export function mhitm_ad_conf(magr, mattk, mdef, mhm) {
    if (!magr.mcan && !mdef.mconf && !magr.mspec_used) {
        mdef.mconf = 1;
    }
}

// cf. uhitm.c:2936 — blinding handler
// m-vs-m branch: uhitm.c:2964-2989
export function mhitm_ad_blnd(magr, mattk, mdef, mhm) {
    // C ref: can_blnd check omitted for simplicity; uses damage dice for duration
    let rnd_tmp = d(mattk.damn || 0, mattk.damd || 0);
    rnd_tmp += (mdef.mblinded || 0);
    if (rnd_tmp > 127) rnd_tmp = 127;
    mdef.mblinded = rnd_tmp;
    mdef.mcansee = 0;
    if (mhm) mhm.damage = 0;
}

// cf. uhitm.c:3457 — sleep handler
// m-vs-m branch: uhitm.c:3486-3500
export function mhitm_ad_slee(magr, mattk, mdef, mhm) {
    if (!mdef.msleeping && !resists_sleep(mdef)) {
        const amt = rnd(10);
        if (mdef.mcanmove !== false) {
            mdef.mcanmove = false;
            mdef.mfrozen = Math.min((mdef.mfrozen || 0) + amt, 127);
        }
    }
}

// cf. uhitm.c:3409 — paralysis handler
// m-vs-m branch: uhitm.c:3441-3453
export function mhitm_ad_plys(magr, mattk, mdef, mhm) {
    if (mdef.mcanmove !== false && !rn2(3)
        && !mhitm_mgc_atk_negated(magr, mdef)) {
        const amt = rnd(10);
        mdef.mcanmove = false;
        mdef.mfrozen = Math.min(amt, 127);
    }
}

// cf. uhitm.c:3284 — sticking handler
// m-vs-m branch: uhitm.c:3307-3311
export function mhitm_ad_stck(magr, mattk, mdef, mhm) {
    const negated = mhitm_mgc_atk_negated(magr, mdef);
    if (negated) mhm.damage = 0;
}

// cf. uhitm.c:3315 — wrap handler
// m-vs-m branch: uhitm.c:3396-3406
export function mhitm_ad_wrap(magr, mattk, mdef, mhm) {
    if (magr.mcan) mhm.damage = 0;
}

// cf. uhitm.c:2423 — level drain handler
// m-vs-m branch: uhitm.c:2467-2495
export function mhitm_ad_drli(magr, mattk, mdef, mhm) {
    if (!rn2(3) && !resists_ston(mdef) /* resists_drli in C, using ston as proxy */
        && !mhitm_mgc_atk_negated(magr, mdef)) {
        mhm.damage = d(2, 6);
        const mlev = mdef.m_lev || 0;
        if (mdef.mhpmax - mhm.damage > mlev) {
            mdef.mhpmax -= mhm.damage;
        } else if (mdef.mhpmax > mlev) {
            mdef.mhpmax = mlev + 1;
        }
        if (mlev === 0) {
            mhm.damage = mdef.mhp;
        } else {
            if (mdef.m_lev !== undefined) mdef.m_lev--;
        }
    }
}

// cf. uhitm.c:3630 — slow handler
// m-vs-m branch: uhitm.c:3654-3664
export function mhitm_ad_slow(magr, mattk, mdef, mhm) {
    const negated = mhitm_mgc_atk_negated(magr, mdef);
    if (!negated) {
        mdef.mslow = 1;
    }
}

// cf. uhitm.c:2396 — energy drain handler
// m-vs-m branch: simplified
export function mhitm_ad_dren(magr, mattk, mdef, mhm) {
    const negated = mhitm_mgc_atk_negated(magr, mdef);
    if (negated) mhm.damage = 0;
    // C ref: xdrainenergym — increases mspec_used
    if (!negated && (mdef.mspec_used || 0) < 20) {
        mdef.mspec_used = (mdef.mspec_used || 0) + d(2, 2);
    }
}

// cf. uhitm.c:3146 — brain drain (mind flayer)
// m-vs-m: uhitm.c:3241-3280
export function mhitm_ad_drin(magr, mattk, mdef, mhm) {
    const pd = mdef.type || {};
    if (!pd.flags1 || (pd.flags1 & 0x00040000 /* M1_NOHEAD */)) {
        // Can't drain brain from headless monster
        mhm.damage = 0;
        return;
    }
    // C ref: intelligence drain — reduces m_lev and mhpmax
    const mlev = mdef.m_lev || 0;
    if (mlev > 0) {
        if (mdef.m_lev !== undefined) mdef.m_lev--;
        mhm.damage = d(2, 6);
        if (mdef.mhpmax > (mlev + 1)) {
            mdef.mhpmax -= mhm.damage;
            if (mdef.mhpmax < (mlev)) mdef.mhpmax = mlev;
        }
    } else {
        mhm.damage = mdef.mhp;
    }
}

// --- Remaining AD_* handlers: simplified stubs for rare/complex effects ---

// cf. uhitm.c:2259 — rust handler (m-vs-m: damages equipment)
export function mhitm_ad_rust(magr, mattk, mdef, mhm) { mhm.damage = 0; }

// cf. uhitm.c:2316 — corrosion handler
export function mhitm_ad_corr(magr, mattk, mdef, mhm) { mhm.damage = 0; }

// cf. uhitm.c:2341 — decay handler
export function mhitm_ad_dcay(magr, mattk, mdef, mhm) { mhm.damage = 0; }

// cf. uhitm.c:2768 — steal gold (m-vs-m: no effect)
export function mhitm_ad_sgld(magr, mattk, mdef, mhm) { mhm.damage = 0; }

// cf. uhitm.c:2837 — teleport (m-vs-m: TODO)
export function mhitm_ad_tlpt(magr, mattk, mdef, mhm) { mhm.damage = 0; }

// cf. uhitm.c:2993 — curse items (m-vs-m: no effect)
export function mhitm_ad_curs(magr, mattk, mdef, mhm) { mhm.damage = 0; }

// cf. uhitm.c:3504 — slime (TODO: needs newcham)
export function mhitm_ad_slim(magr, mattk, mdef, mhm) { mhm.damage = 0; }

// cf. uhitm.c:3581 — enchantment drain (TODO)
export function mhitm_ad_ench(magr, mattk, mdef, mhm) { mhm.damage = 0; }

// cf. uhitm.c:3707 — polymorph (TODO: needs newcham)
export function mhitm_ad_poly(magr, mattk, mdef, mhm) { mhm.damage = 0; }

// cf. uhitm.c:4181 — stoning (TODO: needs petrification system)
export function mhitm_ad_ston(magr, mattk, mdef, mhm) { mhm.damage = 0; }

// cf. uhitm.c:4243 — lycanthropy (m-vs-m: no effect)
export function mhitm_ad_were(magr, mattk, mdef, mhm) { /* no effect m-vs-m */ }

// cf. uhitm.c:4274 — nurse healing (m-vs-m: heals defender)
export function mhitm_ad_heal(magr, mattk, mdef, mhm) {
    mdef.mhp = Math.min((mdef.mhp || 0) + mhm.damage, mdef.mhpmax || mdef.mhp);
    mhm.damage = 0;
}

// cf. uhitm.c:4403 — leg wound (m-vs-m: physical damage)
export function mhitm_ad_legs(magr, mattk, mdef, mhm) {
    mhitm_ad_phys(magr, mattk, mdef, mhm);
}

// cf. uhitm.c:4470 — digestion (engulf)
export function mhitm_ad_dgst(magr, mattk, mdef, mhm) {
    // C ref: full digestion damage = d(6,6) if mhm.damage == 0
    // Simplified: just use the rolled damage
}

// cf. uhitm.c:4548 — steal amulet (m-vs-m: no effect)
export function mhitm_ad_samu(magr, mattk, mdef, mhm) { mhm.damage = 0; }

// cf. uhitm.c:4571 — disease (m-vs-m: no effect)
export function mhitm_ad_dise(magr, mattk, mdef, mhm) { mhm.damage = 0; }

// cf. uhitm.c:4601 — seduction (m-vs-m: no effect)
export function mhitm_ad_sedu(magr, mattk, mdef, mhm) { mhm.damage = 0; }

// cf. uhitm.c:4729 — succubus seduction (m-vs-m: no effect)
export function mhitm_ad_ssex(magr, mattk, mdef, mhm) { mhm.damage = 0; }

// cf. uhitm.c:3815 — death touch (Rider attack)
export function mhitm_ad_deth(magr, mattk, mdef, mhm) {
    // C ref: redirects to mhitm_ad_drli for m-vs-m
    mhitm_ad_drli(magr, mattk, mdef, mhm);
}

// cf. uhitm.c:3786 — pestilence (Rider attack)
export function mhitm_ad_pest(magr, mattk, mdef, mhm) {
    /* m-vs-m: just physical damage */
}

// cf. uhitm.c:3755 — famine (Rider attack)
export function mhitm_ad_famn(magr, mattk, mdef, mhm) {
    /* m-vs-m: just physical damage */
}

// cf. uhitm.c:3875 — hallucination (m-vs-m: no effect)
export function mhitm_ad_halu(magr, mattk, mdef, mhm) { mhm.damage = 0; }

// cf. uhitm.c:3902 — do_stone_u (TODO: needs petrification system)
// cf. uhitm.c:3923 — do_stone_mon (TODO: needs petrification system)

// ============================================================================
// 5b. Central AD_* dispatcher
// ============================================================================

// cf. uhitm.c:4760 — mhitm_adtyping(magr, mattk, mdef, mhm):
//   Dispatch to specific mhitm_ad_* handler based on attack damage type.
//   mattk.adtyp is the JS equivalent of mattk->adtyp.
export function mhitm_adtyping(magr, mattk, mdef, mhm) {
    canonicalizeAttackFields(mattk);
    switch (mattk.adtyp) {
    case AD_PHYS: mhitm_ad_phys(magr, mattk, mdef, mhm); break;
    case AD_FIRE: mhitm_ad_fire(magr, mattk, mdef, mhm); break;
    case AD_COLD: mhitm_ad_cold(magr, mattk, mdef, mhm); break;
    case AD_ELEC: mhitm_ad_elec(magr, mattk, mdef, mhm); break;
    case AD_ACID: mhitm_ad_acid(magr, mattk, mdef, mhm); break;
    case AD_STUN: mhitm_ad_stun(magr, mattk, mdef, mhm); break;
    case AD_LEGS: mhitm_ad_legs(magr, mattk, mdef, mhm); break;
    case AD_WERE: mhitm_ad_were(magr, mattk, mdef, mhm); break;
    case AD_HEAL: mhitm_ad_heal(magr, mattk, mdef, mhm); break;
    case AD_SGLD: mhitm_ad_sgld(magr, mattk, mdef, mhm); break;
    case AD_TLPT: mhitm_ad_tlpt(magr, mattk, mdef, mhm); break;
    case AD_BLND: mhitm_ad_blnd(magr, mattk, mdef, mhm); break;
    case AD_CURS: mhitm_ad_curs(magr, mattk, mdef, mhm); break;
    case AD_DRLI: mhitm_ad_drli(magr, mattk, mdef, mhm); break;
    case AD_RUST: mhitm_ad_rust(magr, mattk, mdef, mhm); break;
    case AD_CORR: mhitm_ad_corr(magr, mattk, mdef, mhm); break;
    case AD_DCAY: mhitm_ad_dcay(magr, mattk, mdef, mhm); break;
    case AD_DREN: mhitm_ad_dren(magr, mattk, mdef, mhm); break;
    case AD_DRST:
    case AD_DRDX:
    case AD_DRCO: mhitm_ad_drst(magr, mattk, mdef, mhm); break;
    case AD_DRIN: mhitm_ad_drin(magr, mattk, mdef, mhm); break;
    case AD_STCK: mhitm_ad_stck(magr, mattk, mdef, mhm); break;
    case AD_WRAP: mhitm_ad_wrap(magr, mattk, mdef, mhm); break;
    case AD_PLYS: mhitm_ad_plys(magr, mattk, mdef, mhm); break;
    case AD_SLEE: mhitm_ad_slee(magr, mattk, mdef, mhm); break;
    case AD_SLIM: mhitm_ad_slim(magr, mattk, mdef, mhm); break;
    case AD_ENCH: mhitm_ad_ench(magr, mattk, mdef, mhm); break;
    case AD_SLOW: mhitm_ad_slow(magr, mattk, mdef, mhm); break;
    case AD_CONF: mhitm_ad_conf(magr, mattk, mdef, mhm); break;
    case AD_POLY: mhitm_ad_poly(magr, mattk, mdef, mhm); break;
    case AD_DISE: mhitm_ad_dise(magr, mattk, mdef, mhm); break;
    case AD_SAMU: mhitm_ad_samu(magr, mattk, mdef, mhm); break;
    case AD_DETH: mhitm_ad_deth(magr, mattk, mdef, mhm); break;
    case AD_PEST: mhitm_ad_pest(magr, mattk, mdef, mhm); break;
    case AD_FAMN: mhitm_ad_famn(magr, mattk, mdef, mhm); break;
    case AD_DGST: mhitm_ad_dgst(magr, mattk, mdef, mhm); break;
    case AD_HALU: mhitm_ad_halu(magr, mattk, mdef, mhm); break;
    case AD_SSEX: mhitm_ad_ssex(magr, mattk, mdef, mhm); break;
    case AD_SEDU:
    case AD_SITM: mhitm_ad_sedu(magr, mattk, mdef, mhm); break;
    default:
        mhm.damage = 0;
        break;
    }
}


// ============================================================================
// 6. Engulfment
// ============================================================================

// cf. uhitm.c:4813 — damageum(mdef, mattk, specialdmg):
//   Apply hero's attack damage to monster (used by polymorphed hero attacks).
//   Rolls d(mattk.damn, mattk.damd), dispatches through mhitm_adtyping.
//   Returns M_ATTK_DEF_DIED if monster dies, M_ATTK_HIT otherwise.
export function damageum(mdef, mattk, specialdmg) {
    canonicalizeAttackFields(mattk);
    const mhm = {
        damage: d(mattk.damn || 0, mattk.damd || 0),
        hitflags: M_ATTK_MISS,
        permdmg: 0,
        specialdmg: specialdmg || 0,
        done: false,
    };

    // C: demon summoning check (1/13 chance, unarmed, demon form)
    // Not applicable in JS (hero polymorph not tracked)

    mhitm_adtyping({ type: {}, mcan: false }, mattk, mdef, mhm);

    if (mhm.done) return mhm.hitflags;

    mdef.mhp -= mhm.damage;
    if (mdef.mhp <= 0) {
        return M_ATTK_DEF_DIED;
    }
    return M_ATTK_HIT;
}

// cf. uhitm.c:4869 — explum(mdef, mattk):
//   Exploding attack (hero polymorphed into exploding monster).
//   Returns M_ATTK_DEF_DIED or M_ATTK_HIT.
export function explum(mdef, mattk) {
    canonicalizeAttackFields(mattk);
    const tmp = d(mattk.damn || 0, mattk.damd || 0);
    // C: various cases (AD_BLND, AD_HALU, AD_COLD/FIRE/ELEC → explode())
    // Simplified: just apply damage for elemental types
    if (mdef) {
        mdef.mhp -= tmp;
        if (mdef.mhp <= 0) return M_ATTK_DEF_DIED;
    }
    return M_ATTK_HIT;
}

// cf. uhitm.c:4909 — start_engulf(mdef):
//   Start engulfing animation/state. Display-only in C.
async function start_engulf(mdef) {
    if (!mdef || !Number.isInteger(mdef.mx) || !Number.isInteger(mdef.my)) return;
    // C uses mon_to_glyph(&youmonst); JS keeps a stable hero marker here.
    tmp_at(DISP_ALWAYS, { ch: '@', color: 15 });
    tmp_at(mdef.mx, mdef.my);
    await nh_delay_output();
    await nh_delay_output();
}

// cf. uhitm.c:4927 — end_engulf():
//   End engulfing animation/state. Display-only in C.
function end_engulf() {
    tmp_at(DISP_END, 0);
}

// cf. uhitm.c:4936 — gulpum(mdef, mattk):
//   Hero engulf attack (polymorphed into engulfer).
//   Very complex function involving digestion, enfolding, swallowing.
//   Returns M_ATTK_MISS or M_ATTK_DEF_DIED.
//   In JS, engulfment is not yet supported. Stub returns miss.
export async function gulpum(mdef, mattk) {
    canonicalizeAttackFields(mattk);
    if (mdef) {
        await start_engulf(mdef);
        end_engulf();
    }
    return M_ATTK_MISS;
}


// ============================================================================
// 7. Miss / defense / knockback
// ============================================================================

// cf. uhitm.c:5176 — missum(mdef, uattk, wouldhavehit):
//   Hero misses monster: print miss message.
//   'wouldhavehit' is true if monk missed only due to armor penalty.
export function missum(mdef, uattk, wouldhavehit) {
    const display = arguments[3] || null;
    if (!display) return;
    if (wouldhavehit) {
        display.putstr_message('Your armor is rather cumbersome...');
    }
    display.putstr_message(`You miss ${y_monnam(mdef)}.`);
}

// Internal version of missum used by known_hitum
function missum_internal(player, mon, uattk, wouldhavehit, display) {
    missum(mon, uattk, wouldhavehit, display);
}

// cf. uhitm.c:5196 — m_is_steadfast(mtmp):
//   Check if monster resists knockback.
//   Returns true if monster can't be knocked back.
export function m_is_steadfast(mtmp) {
    // C: checks Flying/Levitation, Giantslayer artifact, loadstone
    // Simplified: check for flying/floating
    const ptr = mtmp.type || {};
    if (ptr.flags1 && (ptr.flags1 & 0x00000004)) return false; // M1_FLY — not steadfast
    // loadstone check would require inventory search
    return false;
}

// cf. uhitm.c:5225 — mhitm_knockback(magr, mdef, mattk, hitflags, weapon_used):
//   Knockback effect: push monster back on strong hit.
//   Returns true if knockback occurred.
//   Consumes rn2(3), rn2(chance), and possibly rn2(2)*2 for message.
export function mhitm_knockback(magr, mdef, mattk, hitflags, weapon_used) {
    canonicalizeAttackFields(mattk);
    const knockdistance = rn2(3) ? 1 : 2;
    const chance = 6;
    if (rn2(chance)) return false;

    // Only AD_PHYS with AT_CLAW/AT_KICK/AT_BUTT/AT_WEAP qualifies
    if (!mattk) return false;
    const adtyp = mattk.adtyp ?? AD_PHYS;
    const aatyp = mattk.aatyp ?? AT_WEAP;
    if (adtyp !== AD_PHYS) return false;
    if (aatyp !== AT_CLAW && aatyp !== AT_KICK && aatyp !== AT_BUTT && aatyp !== AT_WEAP)
        return false;

    // Attacker must be much larger than defender
    const agrSize = (magr.type || magr.data || {}).msize ?? MZ_HUMAN;
    const defSize = (mdef.type || mdef.data || {}).msize ?? MZ_HUMAN;
    if (!(agrSize > defSize + 1)) return false;

    // Unsolid attacker can't knock back
    const agrPtr = magr.type || magr.data || {};
    if (agrPtr.flags1 && (agrPtr.flags1 & 0x00200000 /* M1_UNSOLID */)) return false;

    // Generate message
    rn2(2); // "forceful" vs "powerful"
    rn2(2); // "blow" vs "strike"

    return true;
}


// ============================================================================
// 8. Polymorphed hero attacks
// ============================================================================

// cf. uhitm.c:5402 — hmonas(mon):
//   Hero attacks as polymorphed monster (use monster attack list).
//   Very complex function: iterates monster's attack list, handles
//   AT_WEAP, AT_CLAW, AT_TUCH, AT_KICK, AT_BITE, AT_STNG, AT_BUTT,
//   AT_TENT, AT_HUGS, AT_EXPL, AT_ENGL, AT_MAGC attacks.
//   In JS, polymorph attacks are not yet supported. Returns true (mon survives).
export function hmonas(player, mon, display, map) {
    // Full implementation would iterate the hero's polymorphed form attack list
    // and dispatch each attack type. For now, delegate to normal melee.
    return true;
}


// ============================================================================
// 9. Passive defense
// ============================================================================

// cf. uhitm.c:5843 — passive(mon, mhit, malive, AT_type, wep_was_destroyed):
//   Monster's passive defense: damage hero on contact (acid blob, etc).
//   rn2(3) gate consumed for RNG parity.
//   Full C function also handles AD_FIRE/RUST/CORR/STON/MAGM/ENCH weapon erosion,
//   AD_PLYS (floating eye gaze), AD_COLD/FIRE/ELEC/STUN passive damage.
//   The implementation below handles the RNG-critical paths.

// cf. uhitm.c:6105 — passive_obj(mon, obj, mattk):
//   Passive defense damages hero's weapon/armor.
//   Called for AD_FIRE, AD_ACID, AD_RUST, AD_CORR, AD_ENCH when hero hits
//   a monster with those passive attack types.
export function passive_obj(mon, obj, mattk) {
    canonicalizeAttackFields(mattk);
    if (!obj) return;
    const ptr = mon.type || {};
    const adtyp = mattk ? (mattk.adtyp ?? AD_PHYS) : AD_PHYS;

    switch (adtyp) {
    case AD_FIRE:
        // C: if (!rn2(6) && !mon->mcan) erode_obj(obj, ERODE_BURN)
        if (!rn2(6) && !mon.mcan) {
            erode_obj(obj, null, ERODE_BURN, EF_GREASE | EF_VERBOSE);
        }
        break;
    case AD_ACID:
        // C: if (!rn2(6)) erode_obj(obj, ERODE_CORRODE)
        if (!rn2(6)) {
            erode_obj(obj, null, ERODE_CORRODE, EF_GREASE | EF_VERBOSE);
        }
        break;
    case AD_RUST:
        // C: if (!mon->mcan) erode_obj(obj, ERODE_RUST)
        if (!mon.mcan) {
            erode_obj(obj, null, ERODE_RUST, EF_GREASE | EF_VERBOSE);
        }
        break;
    case AD_CORR:
        // C: if (!mon->mcan) erode_obj(obj, ERODE_CORRODE)
        if (!mon.mcan) {
            erode_obj(obj, null, ERODE_CORRODE, EF_GREASE | EF_VERBOSE);
        }
        break;
    case AD_DCAY:
        if (!mon.mcan) {
            erode_obj(obj, null, ERODE_ROT, EF_GREASE | EF_VERBOSE);
        }
        break;
    case AD_ENCH:
        // C: if (!mon->mcan) drain_item(obj)
        if (!mon.mcan) {
            if (obj.enchantment !== undefined) obj.enchantment = Math.max(-7, (obj.enchantment || 0) - 1);
            else if (obj.spe !== undefined) obj.spe = Math.max(-7, (obj.spe || 0) - 1);
        }
        break;
    default:
        break;
    }
}


// ============================================================================
// 10. Mimic discovery
// ============================================================================

// cf. uhitm.c:6179 — that_is_a_mimic(mtmp, mimic_flags):
//   Reveal that a hidden monster is actually a mimic.
//   Prints "Wait! That's a <monster>!" and optionally reveals it.
export function that_is_a_mimic(mtmp, mimic_flags) {
    const MIM_REVEAL = 0x1;
    const reveal_it = (mimic_flags || 0) & MIM_REVEAL;

    // C: complex message formatting based on glyph, blind, hallucination
    // Simplified: just reveal the mimic
    if (reveal_it && mtmp.m_ap_type) {
        mtmp.m_ap_type = 0; // M_AP_NOTHING
        mtmp.mundetected = false;
    }
}

// cf. uhitm.c:6260 — stumble_onto_mimic(mtmp):
//   Hero stumbles onto a hidden mimic while moving.
//   Calls that_is_a_mimic(MIM_REVEAL), may set ustuck, wakes mimic.
export function stumble_onto_mimic(mtmp) {
    that_is_a_mimic(mtmp, 0x1 /* MIM_REVEAL */);

    // C: if (!u.ustuck && !mtmp->mflee && dmgtype(mtmp->data, AD_STCK))
    //       set_ustuck(mtmp);
    // Sticking is not modeled in JS yet.

    // Wake the mimic
    mtmp.msleeping = 0;
    if (mtmp.m_ap_type) {
        mtmp.m_ap_type = 0;
    }
}

// cf. uhitm.c:6278 — disguised_as_non_mon(mtmp):
//   Check if monster is disguised as a non-monster object/feature.
//   Returns true if mtmp is disguised as something other than a monster.
export function disguised_as_non_mon(mtmp) {
    // C: M_AP_TYPE(mtmp) && M_AP_TYPE(mtmp) != M_AP_MONSTER
    const M_AP_NOTHING = 0;
    const M_AP_MONSTER = 2;
    const ap = mtmp.m_ap_type || M_AP_NOTHING;
    return ap !== M_AP_NOTHING && ap !== M_AP_MONSTER;
}

// cf. uhitm.c:6286 — disguised_as_mon(mtmp):
//   Check if monster is disguised as another monster.
//   Returns true if mtmp's appearance type is M_AP_MONSTER.
export function disguised_as_mon(mtmp) {
    const M_AP_MONSTER = 2;
    return (mtmp.m_ap_type || 0) === M_AP_MONSTER;
}


// ============================================================================
// 11. Light attacks
// ============================================================================

// cf. uhitm.c:6293 — nohandglow(mon):
//   Reduce hero's umconf counter (hand-glow for confusion touch).
//   Called after a hand-to-hand hit when umconf > 0 and mon is not confused.
function nohandglow(mon) {
    // C: if (!u.umconf || mon->mconf) return;
    //    decrements u.umconf, prints message about hands stopping glowing.
    // In JS, u.umconf is not tracked. Stub: no-op.
}

// cf. uhitm.c:6319 — flash_hits_mon(mtmp, otmp):
//   Flash of light hits a monster (camera, wand of light, etc).
//   Returns 1 if flash had a noticeable effect, 0 otherwise.
//   Wakes sleeping monsters, blinds non-resistant ones, damages gremlins.
export function flash_hits_mon(mtmp, otmp) {
    const ptr = mtmp.type || {};
    let res = 0;

    // Wake mimics — simplified, no M_AP_TYPE tracking
    if (mtmp.msleeping && haseyes(ptr)) {
        mtmp.msleeping = 0;
        res = 1;
    } else if (ptr.mlet !== S_LIGHT) {
        // Blind non-resistant monsters
        // C: if (!resists_blnd(mtmp)) — simplified check
        const isBlindRes = ptr.mlet === S_LIGHT; // already checked above
        if (!isBlindRes) {
            // C: distance-based blinding
            if ((mtmp.mndx ?? -1) === PM_GREMLIN) {
                // Rule #1: Keep them out of the light
                const amt = otmp ? rnd(4) : rnd(Math.min(mtmp.mhp || 4, 4));
                light_hits_gremlin(mtmp, amt);
            }
            if (mtmp.mhp > 0) {
                mtmp.mcansee = 0;
                mtmp.mblinded = rnd(50);
                // C: monflee chance
                if (rn2(4)) {
                    const fleetime = rn2(4) ? rnd(100) : 0;
                    applyMonflee(mtmp, fleetime, false);
                }
            }
            res = 1;
        }
    }
    return res;
}

// cf. uhitm.c:6403 — light_hits_gremlin(mon, dmg):
//   Light damage specifically to gremlins.
//   Deals damage and wakes nearby monsters.
export function light_hits_gremlin(mon, dmg) {
    // C: pline message based on distance and severity
    mon.mhp -= dmg;
    if (mon.mhp <= 0) {
        // Gremlin killed by light — handled by caller
    }
}


// ============================================================================
// Implemented functions (moved from mhitu.js)
// ============================================================================

// cf. uhitm.c find_roll_to_hit() — luck component (partial)
function isUndeadOrDemon(monsterType) {
    if (!monsterType) return false;
    const sym = monsterType.mlet;
    return sym === S_ZOMBIE
        || sym === S_MUMMY
        || sym === S_VAMPIRE
        || sym === S_WRAITH
        || sym === S_LICH
        || sym === S_GHOST
        || sym === S_DEMON;
}

export function weaponEnchantment(weapon) {
    return (weapon && (weapon.enchantment ?? weapon.spe)) || 0;
}

// hitval now in weapon.js — includes spe, oc_hitbon, blessed/silver/type bonuses

export function weaponDamageSides(weapon, monster) {
    if (!weapon) return 0;
    if (weapon.wsdam) return weapon.wsdam;
    const info = objectData[weapon.otyp];
    if (!info) return 0;
    const isLarge = (monster?.type?.msize ?? MZ_TINY) >= MZ_LARGE;
    return isLarge ? (info.ldam || 0) : (info.sdam || 0);
}

// cf. uhitm.c hmon_hitmon_weapon() — ranged weapon used in melee check
function usesRangedMeleeDamage(weapon) {
    if (!weapon) return false;
    const sub = objectData[weapon.otyp]?.sub;
    if (!Number.isInteger(sub)) return false;
    const isLauncher = sub >= 20 && sub <= 22;      // P_BOW..P_CROSSBOW
    const isAmmoOrMissile = sub <= -20 && sub >= -24; // -P_BOW..-P_SHURIKEN
    return isLauncher || isAmmoOrMissile;
}

// cf. uhitm.c find_roll_to_hit() — Luck component.
// sgn(Luck) * ((abs(Luck) + 2) / 3)  (integer division)
function luckBonus(luck) {
    if (!luck) return 0;
    return Math.sign(luck) * Math.floor((Math.abs(luck) + 2) / 3);
}

// cf. weapon.c abon() — now fully ported as abon() in weapon.js

// cf. uhitm.c hmon_hitmon_potion() -> potion.c potionhit()
function consumeMeleePotion(player, weapon) {
    const potion = { ...weapon, quan: 1 };
    if ((weapon.quan || 1) > 1) {
        weapon.quan = (weapon.quan || 1) - 1;
        potion.o_id = next_ident();
    } else {
        player.removeFromInventory(weapon);
        if (player.weapon === weapon) uwepgone(player);
        if (player.swapWeapon === weapon) uswapwepgone(player);
        if (player.quiver === weapon) uqwepgone(player);
    }
    return potion;
}

function potionHealsMonster(potion) {
    if (!potion) return false;
    return potion.otyp === POT_HEALING
        || potion.otyp === POT_EXTRA_HEALING
        || potion.otyp === POT_FULL_HEALING
        || potion.otyp === POT_RESTORE_ABILITY
        || potion.otyp === POT_GAIN_ABILITY;
}

// cf. uhitm.c hmon_hitmon_potion() -> potion.c potionhit()
function hitMonsterWithPotion(player, monster, display, weapon) {
    const potion = consumeMeleePotion(player, weapon);
    const bottleChoices = player?.hallucinating ? 24 : 7;
    rn2(bottleChoices); // bottlename()

    // cf. potion.c:1671
    if (rn2(5) && monster.mhp > 1) {
        monster.mhp--;
    }

    if (potionHealsMonster(potion) && monster.mhp < (monster.mhpmax || monster.mhp)) {
        monster.mhp = monster.mhpmax || monster.mhp;
        display.putstr_message(`The ${x_monnam(monster)} looks sound and hale again.`);
    }

    // cf. potion.c:1893 — distance<3 && !rn2((1+DEX)/2) gate for potionbreathe()
    const dex = player.attributes?.[A_DEX] ?? 10;
    const breatheDenom = Math.max(1, Math.floor((1 + dex) / 2));
    rn2(breatheDenom);
}

// cf. mon.c xkilled() — monster death handling.
// Co-located here with its primary caller hmon().
// TODO: future mon.js codematch should migrate this to mon.js.
function handleMonsterKilled(player, monster, display, map) {
    // cf. uhitm.c -> mon.c mondead() -> killed() -> xkilled()
    const mdat = monster.type || {};
    const killVerb = nonliving(mdat) ? 'destroy' : 'kill';
    display.putstr_message(`You ${killVerb} the ${x_monnam(monster)}!`);
    mondead(monster, map, player);

    // cf. exper.c experience() -- roughly monster level * level
    const exp = ((monster.m_lev || 0) + 1) * ((monster.m_lev || 0) + 1);
    player.exp += exp;
    player.score += exp;
    newexplevel(player, display);

    // cf. mon.c:3581-3609 xkilled() — "illogical but traditional" treasure drop.
    const treasureRoll = rn2(6);
    const canDropTreasure = treasureRoll === 0
        && !((mdat.geno || 0) & G_NOCORPSE)
        && !monster.mcloned
        && (monster.mx !== player.x || monster.my !== player.y)
        && mdat.mlet !== S_KOP;
    if (canDropTreasure && map) {
        const otmp = mkobj(RANDOM_CLASS, true, false);
        const flags2 = mdat.flags2 || 0;
        const isSmallMonster = (mdat.msize || 0) < MZ_HUMAN;
        const isPermaFood = otmp && otmp.oclass === FOOD_CLASS && !otmp.oartifact;
        const dropTooBig = isSmallMonster && !!otmp
            && otmp.otyp !== FIGURINE
            && ((otmp.owt || 0) > 30 || !!objectData[otmp.otyp]?.oc_big);
        if (isPermaFood && !(flags2 & M2_COLLECT)) {
            obj_resists(otmp, 0, 0);
        } else if (dropTooBig) {
            obj_resists(otmp, 0, 0);
        } else {
            otmp.ox = monster.mx;
            otmp.oy = monster.my;
            placeFloorObject(map, otmp);
        }
    }

    // C ref: mon.c:3178-3252 corpse_chance()
    const createCorpse = corpse_chance(monster);

    if (createCorpse) {
        const corpse = mkcorpstat(CORPSE, monster.mndx || 0, true,
            map ? monster.mx : 0, map ? monster.my : 0, map);
        corpse.age = Math.max((player?.turns || 0) + 1, 1);
    }

    return true;
}

// cf. uhitm.c:5843 — passive(mon, weapon, mhitb, maliveb, aatyp, wep_was_destroyed):
//   Handle monster's passive counterattack when hero attacks it.
//   Only consumes RNG if the monster has an AT_NONE attack slot.
const NATTK = 6;

function playerHasProp(player, prop) {
    return !!(player && typeof player.hasProp === 'function' && player.hasProp(prop));
}

function passive(mon, weapon, mhit, malive, aatyp = AT_WEAP, wep_was_destroyed = false, ctx = {}) {
    const player = ctx.player || null;
    const display = ctx.display || null;
    const game = ctx.game || null;
    const ptr = mon.type || {};
    const attacks = ptr.attacks || [];

    // Find the AT_NONE (passive) attack slot
    // C ref: uhitm.c:5856-5861 — scan attacks for AT_NONE
    // JS attacks arrays are compact; synthesize if needed (like passivemm)
    let passiveAttk = null;
    for (let i = 0; i < attacks.length; i++) {
        if (i >= NATTK) return; // no passive attacks
        const attack = canonicalizeAttackFields(attacks[i]);
        if (attack.aatyp === AT_NONE) {
            passiveAttk = attack;
            break;
        }
    }
    if (!passiveAttk) {
        if (attacks.length >= NATTK) return; // no room for passive
        // Synthesize NO_ATTK: C would find AT_NONE/AD_NONE(=AD_PHYS)/0/0
        passiveAttk = { aatyp: AT_NONE, adtyp: AD_PHYS, damn: 0, damd: 0 };
    }
    canonicalizeAttackFields(passiveAttk);

    const adtyp = passiveAttk.adtyp;

    // C ref: uhitm.c:5862-5868 — calculate tmp (damage dice)
    // tmp = d(damn, damd) or d(mlev+1, damd) or 0
    let tmp = 0;
    if (passiveAttk.damn) {
        tmp = d(passiveAttk.damn, passiveAttk.damd || 0);
    } else if (passiveAttk.damd) {
        const mlev = mon.m_lev ?? (ptr.mlevel || 0);
        tmp = d(mlev + 1, passiveAttk.damd);
    }

    // C ref: uhitm.c:5872-5993 — first switch: effects that work even if dead
    switch (adtyp) {
    case AD_ACID:
        if (mhit && !rn2(2)) {
            if (playerHasProp(player, ACID_RES)) {
                tmp = 0;
            }
            rn2(30); // erosion check path
            rn2(6);  // acid item-damage check path
            if (player) exercise(player, A_STR, false);
        } else {
            tmp = 0;
        }
        break;
    case AD_ENCH:
        if (!weapon || wep_was_destroyed || aatyp !== AT_WEAP) {
            tmp = 0;
            break;
        }
        if ((weapon.enchantment ?? weapon.spe ?? 0) > -7) {
            if (weapon.enchantment !== undefined) weapon.enchantment -= 1;
            else if (weapon.spe !== undefined) weapon.spe -= 1;
        }
        tmp = 0;
        break;
    default:
        break;
    }

    if (mhit && weapon && !wep_was_destroyed && aatyp === AT_WEAP) {
        passive_obj(mon, weapon, passiveAttk);
    }

    if (tmp > 0 && player) {
        player.uhp = Math.max(0, (player.uhp || 0) - tmp);
    }

    // C ref: uhitm.c:5997 — if (malive && !mon->mcan && rn2(3)) return;
    if (!malive || mon.mcan || rn2(3)) {
        return;
    }

    // Effects that only work if monster still alive.
    switch (adtyp) {
    case AD_PLYS:
        if ((mon.mndx ?? -1) === PM_FLOATING_EYE) {
            if (tmp > 127) tmp = 127;
            if (!rn2(4)) tmp = 127;
            if (!playerHasProp(player, FREE_ACTION) && tmp > 0) {
                if (game) game.multi = Math.max(game.multi || 0, tmp);
                if (display) display.putstr_message(`You are frozen by ${y_monnam(mon)}!`);
            }
        } else {
            tmp = 0;
        }
        break;
    case AD_COLD:
        if (playerHasProp(player, COLD_RES)) tmp = 0;
        break;
    case AD_FIRE:
        if (playerHasProp(player, FIRE_RES)) tmp = 0;
        break;
    case AD_ELEC:
        if (playerHasProp(player, SHOCK_RES)) tmp = 0;
        break;
    case AD_STUN:
        if (player) {
            const oldTimeout = player.getPropTimeout ? (player.getPropTimeout('stunned') || 0) : 0;
            make_stunned(player, oldTimeout + Math.max(1, tmp), true);
        }
        tmp = 0;
        break;
    default:
        tmp = 0;
        break;
    }

    if (tmp > 0 && player) {
        player.uhp = Math.max(0, (player.uhp || 0) - tmp);
    }
}


// cf. uhitm.c do_attack() / hitum() / known_hitum() — hero attacks monster
export function do_attack_core(player, monster, display, map, game = null) {
    // C ref: uhitm.c:538-549 — first attack while wielding a non-weapon
    // emits "You begin bashing monsters with <item>."
    const wielded = player.weapon;
    const wieldedOd = wielded ? objectData[wielded.otyp] : null;
    let bashPrefix = null;
    const improvisedWield = !!wielded
        && wieldedOd?.oc_class !== WEAPON_CLASS
        && !wieldedOd?.weptool;
    if (improvisedWield) {
        if (player._bashmsgWepObj !== wielded) {
            bashPrefix = `You begin bashing monsters with your ${xname(wielded)}.`;
        }
        player._bashmsgWepObj = wielded;
    } else {
        player._bashmsgWepObj = null;
    }

    // cf. uhitm.c:777 — find_roll_to_hit, mon_maybe_unparalyze, rnd(20)
    const toHit = find_roll_to_hit(player, monster, AT_WEAP, player.weapon);
    mon_maybe_unparalyze(monster);
    const dieRoll = rnd(20);
    const mhit = (toHit > dieRoll);

    // cf. uhitm.c:781-782 — exercise A_DEX before known_hitum if hit
    if (mhit) exercise(player, A_DEX, true);

    if (!mhit) {
        // cf. uhitm.c:608 — known_hitum miss path → missum()
        if (bashPrefix) {
            display.putstr_message(`${bashPrefix}  You miss ${y_monnam(monster)}.`);
        } else {
            display.putstr_message(`You miss ${y_monnam(monster)}.`);
        }
        // cf. uhitm.c:788 passive() after miss
        passive(monster, player.weapon || null, false, true, AT_WEAP, false, {
            player, display, map, game,
        });
        return false;
    }

    if (bashPrefix) {
        display.putstr_message(bashPrefix);
    }

    if (player.weapon && player.weapon.oclass === POTION_CLASS) {
        hitMonsterWithPotion(player, monster, display, player.weapon);
        // cf. uhitm.c hmon_hitmon_potion() sets base damage to 1 (or 0 vs shade)
        // after potionhit(), then proceeds through normal kill/flee/passive handling.
        if ((monster.mndx ?? -1) !== PM_SHADE) {
            monster.mhp -= 1;
        }
        if (monster.mhp <= 0) {
            return handleMonsterKilled(player, monster, display, map);
        }
        // cf. uhitm.c:624-628 known_hitum() — 1/25 morale/flee check on surviving hit
        if (!rn2(25) && monster.mhp < Math.floor((monster.mhpmax || 1) / 2)) {
            // cf. monflee(mon, !rn2(3) ? rnd(100) : 0, ...) — flee timer
            const fleetime = !rn2(3) ? rnd(100) : 0;
            applyMonflee(monster, fleetime, false);
        }
        // cf. uhitm.c:788 passive() after potion hit
        passive(monster, player.weapon || null, true, true, AT_WEAP, false, {
            player, display, map, game,
        });
        return false;
    }

    // Hit! Calculate damage
    // cf. uhitm.c hmon_hitmon() → hmon_hitmon_weapon_melee() / weapon_ranged / barehands
    let damage = 0;
    const rangedMelee = usesRangedMeleeDamage(player.weapon);
    if (player.weapon && rangedMelee) {
        // cf. uhitm.c:884 hmon_hitmon_weapon_ranged() — rnd(2) base
        damage = rnd(2);
    } else if (player.weapon) {
        // cf. uhitm.c:919 hmon_hitmon_weapon_melee() → dmgval()
        damage = dmgval(player.weapon, monster);
    } else {
        // Bare-handed combat
        // cf. uhitm.c:837 hmon_hitmon_barehands() — 1d2 base + martial arts
        damage = rnd(2);
    }

    // cf. uhitm.c:1414 hmon_hitmon_dmg_recalc() — add strength and skill bonuses
    if (!rangedMelee) {
        damage += dbon(player.attributes?.[A_STR] ?? 10);
        damage += weapon_dam_bonus(player.weapon); // skill-based (stub: returns 0)
        // cf. uhitm.c — artifact damage bonus
        if (player.weapon && player.weapon.oartifact) {
            const [bonus] = spec_dbon(player.weapon, monster, damage);
            damage += bonus;
        }
    }

    // Minimum 1 damage on a hit
    if (damage < 1) damage = 1;

    // Apply damage
    // cf. uhitm.c -- "You hit the <monster>!"
    monster.mhp -= damage;

    if (monster.mhp <= 0) {
        // cf. uhitm.c:788 passive() called even when monster dies (malive=false)
        // The "alive-only" effects (rn2(3) gate) are skipped.
        const killed = handleMonsterKilled(player, monster, display, map);
        passive(monster, player.weapon || null, true, false, AT_WEAP, false, {
            player, display, map, game,
        });
        return killed;
    } else {
        // cf. uhitm.c -- various hit messages
        if (dieRoll >= 18) {
            display.putstr_message(`You smite the ${x_monnam(monster)}!`);
        } else {
            display.putstr_message(`You hit the ${x_monnam(monster)}.`);
        }
        // cf. uhitm.c hmon_hitmon_core():
        // For armed melee hits with damage > 1: mhitm_knockback().
        // For unarmed hits with damage > 1: hmon_hitmon_stagger() → rnd(100).
        if (player.weapon && damage > 1 && !player.twoweap) {
            // cf. uhitm.c:5225 mhitm_knockback — hero attacks monster
            // RNG: rn2(3) always, rn2(6) always, then eligibility + rn2(2)*2 if qualifies
            const knockdist = rn2(3); // 67% 1-step, 33% 2-step
            if (!rn2(6)) {
                // Passed 1/6 chance gate. Check eligibility:
                // AD_PHYS + AT_WEAP: passes for armed hero (mattk is hero's attack)
                // Size: hero (MZ_HUMAN) must be > mdef.msize + 1
                const msize = monster.type?.msize ?? MZ_HUMAN;
                if (msize + 1 < MZ_HUMAN) {
                    // cf. uhitm.c:5350-5352 — knockback message
                    const adj = rn2(2) ? 'forceful' : 'powerful';
                    const noun = rn2(2) ? 'blow' : 'strike';
                    display.putstr_message(
                        `You knock the ${x_monnam(monster)} back with a ${adj} ${noun}!`
                    );
                }
            }
        } else if (!player.weapon && damage > 1) {
            // cf. uhitm.c:1554 hmon_hitmon_stagger — rnd(100) stun chance check
            rnd(100);
        }
        // cf. uhitm.c:624-628 known_hitum() — 1/25 morale/flee check on surviving hit
        if (!rn2(25) && monster.mhp < Math.floor((monster.mhpmax || 1) / 2)) {
            // cf. monflee(mon, !rn2(3) ? rnd(100) : 0, ...) — flee timer
            const fleetime = !rn2(3) ? rnd(100) : 0;
            applyMonflee(monster, fleetime, false);
        }
        // cf. uhitm.c:788 passive() after surviving hit
        passive(monster, player.weapon || null, true, true, AT_WEAP, false, {
            player, display, map, game,
        });
        return false;
    }
}
