// getpos.js -- Position selection UI and highlight plumbing
// cf. getpos.c -- getpos_sethilite(), getpos_toggle_hilite_state(),
// getpos_refresh(), getpos() lifecycle.

import { MAP_ROW_START, COLNO, ROWNO, DOOR, ROOM, CORR, isok } from './config.js';
import { nhgetch } from './input.js';
import {
    NHW_MENU,
    PICK_ONE,
    ATR_NONE,
    create_nhwindow,
    start_menu,
    add_menu,
    end_menu,
    select_menu,
    destroy_nhwindow,
} from './windows.js';

const HiliteNormalMap = 0;
const HiliteGoodposSymbol = 1;
const HiliteBackground = 2;
const HiliteStateCount = 3;

let getpos_hilitefunc = null;
let getpos_getvalid = null;
let getpos_hilite_state = HiliteGoodposSymbol;
let defaultHiliteState = HiliteGoodposSymbol;
let hiliteOn = false;
let getposContext = {
    map: null,
    display: null,
    flags: null,
    goalPrompt: null,
    player: null,
};

function callHilite(on) {
    if (typeof getpos_hilitefunc !== 'function') return;
    getpos_hilitefunc(!!on);
    hiliteOn = !!on;
}

function clearHiliteIfNeeded() {
    if (!hiliteOn) return;
    callHilite(false);
}

function applyHiliteForCurrentState() {
    if (!getpos_hilitefunc) return;
    if (getpos_hilite_state === HiliteGoodposSymbol) {
        callHilite(true);
    }
}

// cf. getpos.c:41
// TRANSLATOR: AUTO
export function getpos_sethilite(gp_hilitef, gp_getvalidf) {
    clearHiliteIfNeeded();
    getpos_hilitefunc = (typeof gp_hilitef === 'function') ? gp_hilitef : null;
    getpos_getvalid = (typeof gp_getvalidf === 'function') ? gp_getvalidf : null;
    getpos_hilite_state = defaultHiliteState;
    applyHiliteForCurrentState();
}

// cf. getpos.c:72
export function getpos_toggle_hilite_state() {
    if (!getpos_hilitefunc) return;
    clearHiliteIfNeeded();
    getpos_hilite_state = (getpos_hilite_state + 1) % HiliteStateCount;
    applyHiliteForCurrentState();
}

// cf. getpos.c:94
export function mapxy_valid(x, y) {
    if (typeof getpos_getvalid !== 'function') return true;
    return !!getpos_getvalid(x, y);
}

// cf. getpos.c:753
export function getpos_refresh() {
    clearHiliteIfNeeded();
    getpos_hilite_state = defaultHiliteState;
    applyHiliteForCurrentState();
}

function screenPosForMap(display, x, y) {
    const mapOffset = display?.flags?.msg_window ? 3 : MAP_ROW_START;
    return { col: x - 1, row: y + mapOffset };
}

function getCell(display, col, row) {
    const cell = display?.grid?.[row]?.[col];
    if (!cell) return { ch: ' ', color: 7, attr: 0 };
    return { ch: cell.ch, color: cell.color, attr: cell.attr || 0 };
}

function putCursor(display, x, y) {
    const { col, row } = screenPosForMap(display, x, y);
    const prev = getCell(display, col, row);
    if (typeof display?.setCell === 'function') display.setCell(col, row, 'X', 14, 0);
    if (typeof display?.flush === 'function') display.flush();
    return { col, row, prev };
}

function restoreCursor(display, cursorState) {
    if (!cursorState) return;
    if (typeof display?.setCell === 'function') {
        display.setCell(
            cursorState.col,
            cursorState.row,
            cursorState.prev.ch,
            cursorState.prev.color,
            cursorState.prev.attr || 0
        );
    }
    if (typeof display?.flush === 'function') display.flush();
}

function moveDeltaForChar(c) {
    switch (c) {
    case 'h': return [-1, 0];
    case 'j': return [0, 1];
    case 'k': return [0, -1];
    case 'l': return [1, 0];
    case 'y': return [-1, -1];
    case 'u': return [1, -1];
    case 'b': return [-1, 1];
    case 'n': return [1, 1];
    default: return null;
    }
}

function clampMove(cx, cy, dx, dy) {
    const nx = Math.min(COLNO - 1, Math.max(1, cx + dx));
    const ny = Math.min(ROWNO - 1, Math.max(0, cy + dy));
    return [nx, ny];
}

function cursorDesc(display, x, y) {
    const { col, row } = screenPosForMap(display, x, y);
    const info = display?.cellInfo?.[row]?.[col];
    return info?.name || '';
}

const TARGET_FILTERS = ['all', 'monster', 'object', 'valid'];
const GLOC_ALL = 'all';
const GLOC_MONS = 'monster';
const GLOC_OBJS = 'object';
const GLOC_DOOR = 'door';
const GLOC_EXPLORE = 'explore';
const GLOC_INTERESTING = 'interesting';
const GLOC_VALID = 'valid';

function targetFilterLabel(filter) {
    switch (filter) {
    case 'monster': return 'monsters';
    case 'object': return 'objects';
    case 'valid': return 'valid squares';
    default: return 'all map squares';
    }
}

function glocLabel(gloc) {
    switch (gloc) {
    case GLOC_MONS: return 'monsters';
    case GLOC_OBJS: return 'objects';
    case GLOC_DOOR: return 'doors';
    case GLOC_EXPLORE: return 'unexplored locations';
    case GLOC_VALID: return 'valid locations';
    case GLOC_INTERESTING: return 'interesting locations';
    default: return 'locations';
    }
}

function hasUnexploredNeighbor(map, x, y) {
    const steps = [[1, 0], [-1, 0], [0, 1], [0, -1]];
    for (const [dx, dy] of steps) {
        const nx = x + dx;
        const ny = y + dy;
        if (!isok(nx, ny)) continue;
        const nloc = map?.at ? map.at(nx, ny) : null;
        if (!nloc) continue;
        if (!nloc.seenv) return true;
    }
    return false;
}

function gather_locs_interesting(map, x, y, gloc) {
    if (!map || !isok(x, y)) return false;
    const loc = map.at ? map.at(x, y) : null;
    if (!loc) return false;
    switch (gloc) {
    case GLOC_MONS:
        return !!(map.monsterAt && map.monsterAt(x, y));
    case GLOC_OBJS: {
        const objs = map.objectsAt ? map.objectsAt(x, y) : [];
        return Array.isArray(objs) && objs.length > 0;
    }
    case GLOC_DOOR:
        return loc.typ === DOOR;
    case GLOC_EXPLORE:
        return (loc.typ === DOOR || loc.typ === ROOM || loc.typ === CORR) && hasUnexploredNeighbor(map, x, y);
    case GLOC_VALID:
        return mapxy_valid(x, y);
    case GLOC_INTERESTING: {
        const trap = map.trapAt ? map.trapAt(x, y) : null;
        if (trap && trap.tseen) return true;
        if (gather_locs_interesting(map, x, y, GLOC_MONS)) return true;
        if (gather_locs_interesting(map, x, y, GLOC_OBJS)) return true;
        if (gather_locs_interesting(map, x, y, GLOC_DOOR)) return true;
        if (gather_locs_interesting(map, x, y, GLOC_EXPLORE)) return true;
        // Plain room/corridor is generally not "interesting".
        return loc.typ !== ROOM && loc.typ !== CORR;
    }
    case GLOC_ALL:
    default:
        return true;
    }
}

function isSeenCell(map, x, y) {
    const loc = map?.at ? map.at(x, y) : null;
    return !!loc?.seenv;
}

function getFilterMode(flags) {
    const f = flags?.getloc_filter;
    if (f === 1 || f === 'view') return 'view';
    if (f === 2 || f === 'area') return 'area';
    return 'none';
}

function gloc_filter_allows(map, x, y) {
    const mode = getFilterMode(getposContext.flags);
    if (mode === 'none') return true;
    if (!isSeenCell(map, x, y)) return false;
    if (mode === 'view') return true;
    const player = getposContext.player;
    if (!player || !Number.isInteger(player.x) || !Number.isInteger(player.y)) return true;
    const here = map?.at ? map.at(x, y) : null;
    const base = map?.at ? map.at(player.x, player.y) : null;
    if (!here || !base) return true;
    if (!Number.isInteger(here.roomno) || !Number.isInteger(base.roomno)) return true;
    return here.roomno === base.roomno;
}

export function getpos_getvalids_selection(validf = mapxy_valid) {
    const out = [];
    if (typeof validf !== 'function') return out;
    for (let x = 1; x < COLNO; x++) {
        for (let y = 0; y < ROWNO; y++) {
            if (validf(x, y)) out.push({ x, y });
        }
    }
    return out;
}

function collectTargets(map, filter) {
    if (!map) return [];
    const targets = [];
    const seen = new Set();
    const add = (x, y) => {
        if (!isok(x, y)) return;
        const k = `${x},${y}`;
        if (seen.has(k)) return;
        seen.add(k);
        targets.push({ x, y });
    };

    if (filter === 'monster' || filter === 'all') {
        const mons = Array.isArray(map.monsters) ? map.monsters : [];
        for (const mon of mons) {
            if (!mon || mon.dead) continue;
            add(mon.mx, mon.my);
        }
        if (filter === 'monster') {
            targets.sort((a, b) => (a.y - b.y) || (a.x - b.x));
            return targets;
        }
    }

    for (let y = 0; y < ROWNO; y++) {
        for (let x = 1; x < COLNO; x++) {
            if (!gloc_filter_allows(map, x, y)) continue;
            if (filter === 'object') {
                const objs = map.objectsAt ? map.objectsAt(x, y) : [];
                if (Array.isArray(objs) && objs.length > 0) add(x, y);
            } else if (filter === 'valid') {
                if (mapxy_valid(x, y)) add(x, y);
            } else if (filter === 'all') {
                add(x, y);
            }
        }
    }
    targets.sort((a, b) => (a.y - b.y) || (a.x - b.x));
    return targets;
}

function collectTargetsForGloc(map, gloc) {
    if (gloc === GLOC_VALID) {
        return getpos_getvalids_selection((x, y) => mapxy_valid(x, y) && gloc_filter_allows(map, x, y));
    }
    const targets = [];
    if (!map) return targets;
    for (let y = 0; y < ROWNO; y++) {
        for (let x = 1; x < COLNO; x++) {
            if (!gloc_filter_allows(map, x, y)) continue;
            if (gather_locs_interesting(map, x, y, gloc)) targets.push({ x, y });
        }
    }
    targets.sort((a, b) => (a.y - b.y) || (a.x - b.x));
    return targets;
}

function findTargetIndex(targets, cx, cy) {
    if (!targets.length) return -1;
    let idx = targets.findIndex(t => t.x === cx && t.y === cy);
    if (idx >= 0) return idx;
    idx = targets.findIndex(t => (t.y > cy) || (t.y === cy && t.x > cx));
    return idx >= 0 ? idx : 0;
}

function selectTargetFromMenu(display, targets, filter) {
    if (!targets.length) return null;
    if (typeof display?.putstr_message === 'function') {
        const count = Math.min(targets.length, 9);
        const opts = [];
        for (let i = 0; i < count; i++) {
            opts.push(`${i + 1}:${targets[i].x},${targets[i].y}`);
        }
        display.putstr_message(`Targets (${targetFilterLabel(filter)}): ${opts.join(' ')} (1-9)`);
    }
    return 'pending';
}

function getpos_filter_text(flags) {
    const filter = flags?.getloc_filter;
    if (filter === 'view' || filter === 1) return ' in view';
    if (filter === 'area' || filter === 2) return ' in this area';
    return '';
}

export function getpos_help_keyxhelp(display, k1, k2, gloc, moveCursorTo = 'move the cursor to ') {
    if (typeof display?.putstr_message !== 'function') return;
    const filtertxt = getpos_filter_text(getposContext.flags);
    display.putstr_message(
        `Use '${k1}'/'${k2}' to ${moveCursorTo}${glocLabel(gloc)}${filtertxt}.`
    );
}

function getpos_help(force, goal, display) {
    if (typeof display?.putstr_message !== 'function') return;
    const g = goal || 'desired location';
    display.putstr_message(
        `Use 'h', 'j', 'k', 'l' to move the cursor to ${g}.`
    );
    display.putstr_message("Use 'H', 'J', 'K', 'L' to fast-move the cursor.");
    display.putstr_message("Use '@' to move the cursor onto yourself.");
    display.putstr_message("Or enter a background symbol (example '<').");
    getpos_help_keyxhelp(display, 'm', 'M', GLOC_MONS);
    getpos_help_keyxhelp(display, 'o', 'O', GLOC_OBJS);
    getpos_help_keyxhelp(display, 'd', 'D', GLOC_DOOR);
    getpos_help_keyxhelp(display, 'x', 'X', GLOC_EXPLORE, 'move the cursor next to ');
    getpos_help_keyxhelp(display, 'i', 'I', GLOC_INTERESTING);
    getpos_help_keyxhelp(display, 'v', 'V', GLOC_VALID);
    display.putstr_message("Use '^' to toggle marking of valid locations.");
    display.putstr_message("Use '=' for a menu listing of possible targets.");
    if (!force) {
        display.putstr_message('Space can also finish selection.');
    }
}

function targetMenuLine(display, map, x, y) {
    const desc = cursorDesc(display, x, y);
    if (desc) return `${desc} [${x},${y}]`;
    const mon = map?.monsterAt ? map.monsterAt(x, y) : null;
    if (mon && !mon.dead) return `${mon.name || 'monster'} [${x},${y}]`;
    const objs = map?.objectsAt ? map.objectsAt(x, y) : [];
    if (Array.isArray(objs) && objs.length > 0) return `object [${x},${y}]`;
    return `location [${x},${y}]`;
}

async function getpos_menu(display, map, gloc) {
    const targets = collectTargetsForGloc(map, gloc);
    const player = getposContext.player;
    const menuTargets = (player && Number.isInteger(player.x) && Number.isInteger(player.y))
        ? targets.filter((t) => !(t.x === player.x && t.y === player.y))
        : targets;
    const candidates = menuTargets.length > 0 ? menuTargets : targets;

    if (!candidates.length) {
        if (typeof display?.putstr_message === 'function') {
            display.putstr_message(`No ${glocLabel(gloc)}.`);
        }
        return null;
    }

    const tmpwin = create_nhwindow(NHW_MENU);
    try {
        start_menu(tmpwin, 0);
        for (let i = 0; i < candidates.length; i++) {
            add_menu(tmpwin, null, i, 0, 0, ATR_NONE, 0,
                targetMenuLine(display, map, candidates[i].x, candidates[i].y), 0);
        }
        end_menu(tmpwin, `Pick ${glocLabel(gloc)}`);
        const picks = await select_menu(tmpwin, PICK_ONE);
        if (!Array.isArray(picks) || picks.length === 0) return null;
        const idx = picks[0].identifier;
        if (!Number.isInteger(idx) || idx < 0 || idx >= candidates.length) return null;
        return candidates[idx];
    } finally {
        destroy_nhwindow(tmpwin);
    }
}

function findNextMatchingMapChar(display, map, cx, cy, needle) {
    if (!display || !needle) return null;
    for (let pass = 0; pass <= 1; pass++) {
        const yStart = pass === 0 ? cy : 0;
        const yEnd = pass === 0 ? (ROWNO - 1) : cy;
        for (let y = yStart; y <= yEnd; y++) {
            const xStart = (pass === 0 && y === yStart) ? (cx + 1) : 1;
            const xEnd = (pass === 1 && y === yEnd) ? cx : (COLNO - 1);
            for (let x = xStart; x <= xEnd; x++) {
                if (!isok(x, y)) continue;
                if (!gloc_filter_allows(map, x, y)) continue;
                const { col, row } = screenPosForMap(display, x, y);
                const cell = getCell(display, col, row);
                if (cell.ch === needle) return { x, y };
            }
        }
    }
    return null;
}

function findPrevMatchingMapChar(display, map, cx, cy, needle) {
    if (!display || !needle) return null;
    for (let pass = 0; pass <= 1; pass++) {
        const yStart = pass === 0 ? cy : (ROWNO - 1);
        const yEnd = pass === 0 ? 0 : cy;
        for (let y = yStart; y >= yEnd; y--) {
            const xStart = (pass === 0 && y === yStart) ? (cx - 1) : (COLNO - 1);
            const xEnd = (pass === 1 && y === yEnd) ? cx : 1;
            for (let x = xStart; x >= xEnd; x--) {
                if (!isok(x, y)) continue;
                if (!gloc_filter_allows(map, x, y)) continue;
                const { col, row } = screenPosForMap(display, x, y);
                const cell = getCell(display, col, row);
                if (cell.ch === needle) return { x, y };
            }
        }
    }
    return null;
}

function findMatchingMapChar(display, map, cx, cy, needle, forward) {
    return forward
        ? findNextMatchingMapChar(display, map, cx, cy, needle)
        : findPrevMatchingMapChar(display, map, cx, cy, needle);
}

function isPrintable(ch) {
    return ch >= 32 && ch <= 126;
}

function isShiftedPrintable(c, ch) {
    return isPrintable(ch) && c >= 'A' && c <= 'Z';
}

function isUnshiftedPrintable(c, ch) {
    return isPrintable(ch) && (c < 'A' || c > 'Z');
}

export function getpos_gloc_from_filter(filter) {
    switch (filter) {
    case GLOC_MONS:
    case GLOC_OBJS:
    case GLOC_VALID:
        return filter;
    default:
        return GLOC_INTERESTING;
    }
}

function getpos_cycle_target(display, map, gloc, cx, cy, dir) {
    const targets = collectTargetsForGloc(map, gloc);
    if (!targets.length) {
        if (typeof display?.putstr_message === 'function') {
            display.putstr_message(`Cannot detect ${glocLabel(gloc)}.`);
        }
        return null;
    }
    const idx = findTargetIndex(targets, cx, cy);
    return targets[(idx + dir + targets.length) % targets.length];
}

export function set_getpos_context(ctx = {}) {
    getposContext = {
        ...getposContext,
        ...ctx,
    };
}

// cf. getpos.c:771
export async function getpos_async(ccp, force = true, goal = '') {
    const display = getposContext.display;
    if (!ccp || typeof ccp !== 'object') return -1;

    let cx = Number.isInteger(ccp.x) ? ccp.x : 1;
    let cy = Number.isInteger(ccp.y) ? ccp.y : 0;
    if (!isok(cx, cy)) {
        cx = 1;
        cy = 0;
    }

    if (typeof display?.putstr_message === 'function') {
        const promptGoal = goal || getposContext.goalPrompt || 'desired location';
        display.putstr_message(`Move cursor to ${promptGoal}:`);
    }
    if (getpos_hilitefunc && getpos_hilite_state === HiliteGoodposSymbol && !hiliteOn) {
        callHilite(true);
    }

    let cursorState = putCursor(display, cx, cy);
    const homeX = cx;
    const homeY = cy;
    let targetFilter = 'all';
    try {
        for (;;) {
            const ch = await nhgetch();
            const c = String.fromCharCode(ch);

            if (ch === 27) {
                ccp.x = -10;
                ccp.y = -10;
                return -1;
            }
            if (c === '.' || c === ',' || c === ';' || c === ':' || ch === 13 || ch === 10) {
                ccp.x = cx;
                ccp.y = cy;
                if (c === ',') return 1;
                if (c === ';') return 2;
                if (c === ':') return 3;
                return 0;
            }
            if (c === '?') {
                getpos_help(force, goal || getposContext.goalPrompt, display);
                continue;
            }
            if (c === '^') {
                restoreCursor(display, cursorState);
                getpos_toggle_hilite_state();
                cursorState = putCursor(display, cx, cy);
                continue;
            }
            if (c === '@') {
                restoreCursor(display, cursorState);
                cx = homeX;
                cy = homeY;
                cursorState = putCursor(display, cx, cy);
                continue;
            }
            const glocKeys = {
                m: [GLOC_MONS, 1],
                M: [GLOC_MONS, -1],
                o: [GLOC_OBJS, 1],
                O: [GLOC_OBJS, -1],
                d: [GLOC_DOOR, 1],
                D: [GLOC_DOOR, -1],
                x: [GLOC_EXPLORE, 1],
                X: [GLOC_EXPLORE, -1],
                i: [GLOC_INTERESTING, 1],
                I: [GLOC_INTERESTING, -1],
                v: [GLOC_VALID, 1],
                V: [GLOC_VALID, -1],
            };
            if (glocKeys[c]) {
                const [gloc, dir] = glocKeys[c];
                const next = getpos_cycle_target(display, getposContext.map, gloc, cx, cy, dir);
                if (!next) continue;
                restoreCursor(display, cursorState);
                cx = next.x;
                cy = next.y;
                cursorState = putCursor(display, cx, cy);
                continue;
            }

            if (c === 'f') {
                const cur = TARGET_FILTERS.indexOf(targetFilter);
                targetFilter = TARGET_FILTERS[(cur + 1) % TARGET_FILTERS.length];
                if (typeof display?.putstr_message === 'function') {
                    display.putstr_message(`Target filter: ${targetFilterLabel(targetFilter)}.`);
                }
                continue;
            }
            if (c === '[' || c === ']') {
                const targets = collectTargets(getposContext.map, targetFilter);
                if (!targets.length) {
                    if (typeof display?.putstr_message === 'function') {
                        display.putstr_message(`No ${targetFilterLabel(targetFilter)} targets.`);
                    }
                    continue;
                }
                const idx = findTargetIndex(targets, cx, cy);
                const delta = c === ']' ? 1 : -1;
                const next = targets[(idx + delta + targets.length) % targets.length];
                restoreCursor(display, cursorState);
                cx = next.x;
                cy = next.y;
                cursorState = putCursor(display, cx, cy);
                continue;
            }
            if (c === '=') {
                const currentGloc = getpos_gloc_from_filter(targetFilter);
                const target = await getpos_menu(display, getposContext.map, currentGloc);
                if (!target) continue;
                restoreCursor(display, cursorState);
                cx = target.x;
                cy = target.y;
                cursorState = putCursor(display, cx, cy);
                continue;
            }
            if (ch === 18) { // ^R
                restoreCursor(display, cursorState);
                getpos_refresh();
                cursorState = putCursor(display, cx, cy);
                continue;
            }

            const lower = c.toLowerCase();
            const delta = moveDeltaForChar(lower);
            if (delta) {
                const steps = (c !== lower) ? 8 : 1;
                let nx = cx;
                let ny = cy;
                for (let i = 0; i < steps; i++) {
                    const moved = clampMove(nx, ny, delta[0], delta[1]);
                    nx = moved[0];
                    ny = moved[1];
                }
                if (nx !== cx || ny !== cy) {
                    restoreCursor(display, cursorState);
                    cx = nx;
                    cy = ny;
                    cursorState = putCursor(display, cx, cy);
                    const desc = cursorDesc(display, cx, cy);
                    if (desc && typeof display?.putstr_message === 'function') {
                        display.putstr_message(desc);
                    }
                }
                continue;
            }

            if (isShiftedPrintable(c, ch) || isUnshiftedPrintable(c, ch)) {
                const found = findMatchingMapChar(display, getposContext.map, cx, cy, c, !isShiftedPrintable(c, ch));
                if (found) {
                    restoreCursor(display, cursorState);
                    cx = found.x;
                    cy = found.y;
                    cursorState = putCursor(display, cx, cy);
                    continue;
                }
                if (typeof display?.putstr_message === 'function') {
                    display.putstr_message(`Can't find dungeon feature '${c}'.`);
                }
                continue;
            }

            if (!force) {
                ccp.x = cx;
                ccp.y = cy;
                return 0;
            }
        }
    } finally {
        restoreCursor(display, cursorState);
        clearHiliteIfNeeded();
        getpos_hilitefunc = null;
        getpos_getvalid = null;
    }
}

export function getpos_clear_hilite() {
    clearHiliteIfNeeded();
    getpos_sethilite(null, null);
}

export {
    HiliteNormalMap,
    HiliteGoodposSymbol,
    HiliteBackground,
};
