// Autogenerated translator module for currently-unmapped C source outputs.
// Contents are syntax-validated emitted functions; wiring into runtime is separate.

// TRANSLATOR: AUTO (nhlsel.c:57)
export function l_selection_check(L, index) {
  let sel;
  luaL_checktype(L, index, LUA_TUSERDATA);
  sel =  luaL_checkudata(L, index, "selection");
  if (!sel) nhl_error(L, "Selection error");
  return sel;
}

// TRANSLATOR: AUTO (nhlsel.c:69)
export function l_selection_gc(L) {
  let sel = l_selection_check(L, 1);
  if (sel) selection_free(sel, false);
  return 0;
}

// TRANSLATOR: AUTO (nhlsel.c:93)
export function l_selection_push_new(L) {
  let tmp = selection_new(), sel =  lua_newuserdata(L, sizeof );
  luaL_getmetatable(L, "selection");
  lua_setmetatable(L, -2);
   sel = tmp;
  sel.map = dupstr(tmp.map);
  selection_free(tmp, true);
  return sel;
}

// TRANSLATOR: AUTO (nhlsel.c:111)
export function l_selection_push_copy(L, tmp) {
  let sel =  lua_newuserdata(L, sizeof );
  luaL_getmetatable(L, "selection");
  lua_setmetatable(L, -2);
   sel = tmp;
  sel.map = dupstr(tmp.map);
}

// TRANSLATOR: AUTO (nhlsel.c:126)
export function l_selection_new(L) {
  l_selection_push_new(L);
  return 1;
}

// TRANSLATOR: AUTO (nhlsel.c:135)
export function l_selection_clone(L) {
  let sel = l_selection_check(L, 1), tmp;
  l_selection_new(L);
  tmp = l_selection_check(L, 2);
  if (tmp.map) (tmp.map, 0);
   tmp = sel;
  tmp.map = dupstr(sel.map);
  return 1;
}

// TRANSLATOR: AUTO (nhlsel.c:388)
export function l_selection_filter_percent(L) {
  let argc = lua_gettop(L), sel = l_selection_check(L, 1);
  let p =  luaL_checkinteger(L, 2), tmp;
  tmp = selection_filter_percent(sel, p);
  lua_pop(L, argc);
  l_selection_push_copy(L, tmp);
  selection_free(tmp, true);
  return 1;
}

// TRANSLATOR: AUTO (nhlsel.c:630)
export function l_selection_grow(L) {
  let growdirs = [ "all", "random", "north", "west", "east", "south", null ];
  let growdirs2i = [ W_ANY, W_RANDOM, W_NORTH, W_WEST, W_EAST, W_SOUTH, 0 ];
  let sel, dir, argc = lua_gettop(L);
  l_selection_check(L, 1);
  dir = growdirs2i[luaL_checkoption(L, 2, "all", growdirs)];
  if (argc === 2) lua_pop(L, 1);
  l_selection_clone(L);
  sel = l_selection_check(L, 2);
  selection_do_grow(sel, dir);
  return 1;
}

// TRANSLATOR: AUTO (nhlsel.c:656)
export function l_selection_filter_mapchar(L) {
  let argc = lua_gettop(L), sel = l_selection_check(L, 1);
  let mapchr = dupstr(luaL_checkstring(L, 2)), typ = check_mapchr(mapchr);
  let lit =  luaL_optinteger(L, 3, -2), tmp;
  if (typ === INVALID_TYPE) nhl_error(L, "Erroneous map char");
  tmp = selection_filter_mapchar(sel, typ, lit);
  lua_pop(L, argc);
  l_selection_push_copy(L, tmp);
  selection_free(tmp, true);
  if (mapchr) (mapchr, 0);
  return 1;
}

// TRANSLATOR: AUTO (nhlsel.c:681)
export function l_selection_match(L) {
  let argc = lua_gettop(L), sel =  0, mf =  0, x, y;
  if (argc === 1) {
    let err, mapstr = dupstr(luaL_checkstring(L, 1));
    lua_pop(L, 1);
    l_selection_new(L);
    sel = l_selection_check(L, 1);
    mf = mapfrag_fromstr(mapstr);
    (mapstr, 0);
    if ((err = mapfrag_error(mf)) !== null) { nhl_error(L, err); }
  }
  else { nhl_error(L, "wrong parameters"); }
  for (y = 0; y <= sel.hei; y++) {
    for (x = 1; x < sel.wid; x++) {
      selection_setpoint(x, y, sel, mapfrag_match(mf, x,y) ? 1 : 0);
    }
  }
  selection_recalc_bounds(sel);
  mapfrag_free( mf);
  return 1;
}

// TRANSLATOR: AUTO (nhlsel.c:861)
export function l_selection_gradient(L) {
  let argc = lua_gettop(L), sel =  0, x = 0, y = 0, x2 = -1, y2 = -1;
  let mindist = 0, maxdist = 0, type = 0;
  let gradtypes = [ "radial", "square", null ];
  let gradtypes2i = [ SEL_GRADIENT_RADIAL, SEL_GRADIENT_SQUARE, -1 ];
  if (argc === 1 && lua_type(L, 1) === LUA_TTABLE) {
    lcheck_param_table(L);
    type = gradtypes2i[get_table_option(L, "type", "radial", gradtypes)];
    x =  get_table_int(L, "x");
    y =  get_table_int(L, "y");
    x2 =  get_table_int_opt(L, "x2", -1);
    y2 =  get_table_int_opt(L, "y2", -1);
    cvt_to_abscoord( x, y);
    cvt_to_abscoord( x2, y2);
    maxdist = get_table_int(L, "maxdist");
    mindist = get_table_int_opt(L, "mindist", 0);
    lua_pop(L, 1);
    l_selection_new(L);
    sel = l_selection_check(L, 1);
  }
  else {
    nhl_error(L, "selection.gradient requires table argument");
  }
  if (x2 === -1 && y2 === -1) { x2 = x; y2 = y; }
  selection_do_gradient(sel, x, y, x2, y2, type, mindist, maxdist);
  lua_settop(L, 1);
  return 1;
}

// TRANSLATOR: AUTO (nhlsel.c:961)
export function l_selection_size_description(L) {
  let argc = lua_gettop(L);
  if (argc === 1) {
    let sel = l_selection_check(L, 1), buf;
    lua_pushstring(L, selection_size_description(sel, buf));
    return 1;
  }
  else { nhl_error(L, "wrong parameters"); }
  return 0;
}
