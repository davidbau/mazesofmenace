// Autogenerated translator module for currently-unmapped C source outputs.
// Contents are syntax-validated emitted functions; wiring into runtime is separate.

// TRANSLATOR: AUTO (nhlua.c:275)
export function nhl_get_timertype(L, idx) {
  let timerstr = [ "rot-organic", "rot-corpse", "revive-mon", "zombify-mon", "burn-obj", "hatch-egg", "fig-transform", "shrink-glob", "melt-ice", null ];
  let ret = luaL_checkoption(L, idx, null, timerstr);
  if (ret < 0 || ret >= NUM_TIME_FUNCS) nhl_error(L, "Unknown timer type");
  return ret;
}

// TRANSLATOR: AUTO (nhlua.c:302)
export function nhl_add_table_entry_char(L, name, value) {
  let buf;
  Sprintf(buf, "%c", value);
  lua_pushstring(L, name);
  lua_pushstring(L, buf);
  lua_rawset(L, -3);
}

// TRANSLATOR: AUTO (nhlua.c:312)
export function nhl_add_table_entry_str(L, name, value) {
  lua_pushstring(L, name);
  lua_pushstring(L, value);
  lua_rawset(L, -3);
}

// TRANSLATOR: AUTO (nhlua.c:319)
export function nhl_add_table_entry_bool(L, name, value) {
  lua_pushstring(L, name);
  lua_pushboolean(L, value);
  lua_rawset(L, -3);
}

// TRANSLATOR: AUTO (nhlua.c:327)
export function nhl_add_table_entry_region(L, name, x1, y1, x2, y2) {
  lua_pushstring(L, name);
  lua_newtable(L);
  nhl_add_table_entry_int(L, "x1", x1);
  nhl_add_table_entry_int(L, "y1", y1);
  nhl_add_table_entry_int(L, "x2", x2);
  nhl_add_table_entry_int(L, "y2", y2);
  lua_rawset(L, -3);
}

// TRANSLATOR: AUTO (nhlua.c:394)
export function check_mapchr(s) {
  if (s && strlen(s) === 1) return splev_chr2typ(s[0]);
  return INVALID_TYPE;
}

// TRANSLATOR: AUTO (nhlua.c:402)
export function splev_typ2chr(typ) {
  let i;
  for (i = 0; char2typ[i].typ < MAX_TYPE; i++) {
    if (typ === char2typ[i].typ) return char2typ[i].ch;
  }
  return 'x';
}

// TRANSLATOR: AUTO (nhlua.c:472)
export function nhl_deltrap(L) {
  let lx, ly, x, y;
  if (!nhl_get_xy_params(L, lx, ly)) { nhl_error(L, "Incorrect arguments"); return 0; }
  x =  lx;
  y =  ly;
  cvt_to_abscoord( x, y);
  if (isok(x, y)) { let ttmp = t_at(x, y); if (ttmp) deltrap(ttmp); }
  return 0;
}

// TRANSLATOR: AUTO (nhlua.c:621)
export function nhl_impossible(L) {
  let argc = lua_gettop(L);
  if (argc === 1) impossible("%s", luaL_checkstring(L, 1));
  else {
    nhl_error(L, "Wrong args");
  }
  return 0;
}

// TRANSLATOR: AUTO (nhlua.c:635)
export async function nhl_pline(L) {
  let argc = lua_gettop(L);
  if (argc === 1 || argc === 2) {
    pline("%s", luaL_checkstring(L, 1));
    if (lua_toboolean(L, 2)) await display_nhwindow(WIN_MESSAGE, true);
  }
  else {
    nhl_error(L, "Wrong args");
  }
  return 0;
}

// TRANSLATOR: AUTO (nhlua.c:651)
export function nhl_verbalize(L) {
  let argc = lua_gettop(L);
  if (argc === 1) verbalize("%s", luaL_checkstring(L, 1));
  else {
    nhl_error(L, "Wrong args");
  }
  return 0;
}

// TRANSLATOR: AUTO (nhlua.c:665)
export function nhl_parse_config(L) {
  let argc = lua_gettop(L);
  if (argc === 1) parse_conf_str(luaL_checkstring(L, 1), parse_config_line);
  else {
    nhl_error(L, "Wrong args");
  }
  return 0;
}

// TRANSLATOR: AUTO (nhlua.c:679)
export function nhl_get_config(L) {
  let argc = lua_gettop(L);
  if (argc === 1) {
    lua_pushstring(L, get_option_value(luaL_checkstring(L, 1), true));
    return 1;
  }
  else {
    nhl_error(L, "Wrong args");
  }
  return 0;
}

// TRANSLATOR: AUTO (nhlua.c:696)
export async function nhl_getlin(L) {
  let argc = lua_gettop(L);
  if (argc === 1) {
    let prompt = luaL_checkstring(L, 1), buf;
    await getlin(prompt, buf);
    lua_pushstring(L, buf);
    return 1;
  }
  nhl_error(L, "Wrong args");
  return 0;
}

// TRANSLATOR: AUTO (nhlua.c:856)
export function nhl_makeplural(L) {
  let argc = lua_gettop(L);
  if (argc === 1) lua_pushstring(L, makeplural(luaL_checkstring(L, 1)));
  else {
    nhl_error(L, "Wrong args");
  }
  return 1;
}

// TRANSLATOR: AUTO (nhlua.c:870)
export function nhl_makesingular(L) {
  let argc = lua_gettop(L);
  if (argc === 1) lua_pushstring(L, makesingular(luaL_checkstring(L, 1)));
  else {
    nhl_error(L, "Wrong args");
  }
  return 1;
}

// TRANSLATOR: AUTO (nhlua.c:884)
export function nhl_s_suffix(L) {
  let argc = lua_gettop(L);
  if (argc === 1) lua_pushstring(L, s_suffix(luaL_checkstring(L, 1)));
  else {
    nhl_error(L, "Wrong args");
  }
  return 1;
}

// TRANSLATOR: AUTO (nhlua.c:898)
export function nhl_ing_suffix(L) {
  let argc = lua_gettop(L);
  if (argc === 1) lua_pushstring(L, ing_suffix(luaL_checkstring(L, 1)));
  else {
    nhl_error(L, "Wrong args");
  }
  return 1;
}

// TRANSLATOR: AUTO (nhlua.c:912)
export function nhl_an(L) {
  let argc = lua_gettop(L);
  if (argc === 1) lua_pushstring(L, an(luaL_checkstring(L, 1)));
  else {
    nhl_error(L, "Wrong args");
  }
  return 1;
}

// TRANSLATOR: AUTO (nhlua.c:1067)
export function nhl_rn2(L) {
  let argc = lua_gettop(L);
  if (argc === 1) {
    let range =  luaL_checkinteger(L, 1);
    nhl_rnglog_set_lua_caller(L, "nh.rn2");
    lua_pushinteger(L, (rn2)(range));
  }
  else {
    nhl_error(L, "Wrong args");
  }
  return 1;
}

// TRANSLATOR: AUTO (nhlua.c:1085)
export function nhl_random(L) {
  let argc = lua_gettop(L);
  if (argc === 1) {
    let range =  luaL_checkinteger(L, 1);
    nhl_rnglog_set_lua_caller(L, "nh.random");
    lua_pushinteger(L, (rn2)(range));
  }
  else if (argc === 2) {
    let base =  luaL_checkinteger(L, 1), range =  luaL_checkinteger(L, 2);
    nhl_rnglog_set_lua_caller(L, "nh.random");
    lua_pushinteger(L, base + (rn2)(range));
  }
  else {
    nhl_error(L, "Wrong args");
  }
  return 1;
}

// TRANSLATOR: AUTO (nhlua.c:1107)
export function nhl_level_difficulty(L) {
  let argc = lua_gettop(L);
  if (argc === 0) { lua_pushinteger(L, level_difficulty()); }
  else {
    nhl_error(L, "level_difficulty should not have any args");
  }
  return 1;
}

// TRANSLATOR: AUTO (nhlua.c:1120)
export function nhl_is_genocided(L, game) {
  let argc = lua_gettop(L);
  if (argc === 1) {
    let paramstr = luaL_checkstring(L, 1), mgend;
    let i = name_to_mon(paramstr, mgend);
    lua_pushboolean(L, (i !== NON_PM) && (game.mvitals[i].mvflags & G_GENOD) ? true : false);
  }
  else { nhl_error(L, "Wrong args"); }
  return 1;
}

// TRANSLATOR: AUTO (nhlua.c:1143)
export function nhl_get_debug_themerm_name(L) {
  let argc = lua_gettop(L);
  if (argc === 1) {
    let dbg_themerm =  0, is_fill = lua_toboolean(L, 1);
    lua_pop(L, 1);
    if (wizard) dbg_themerm = getenv(is_fill ? "THEMERMFILL" : "THEMERM");
    if (!dbg_themerm || !dbg_themerm) { lua_pushnil(L); }
    else { lua_pushstring(L, dbg_themerm); }
  }
  else {
    nhl_error(L, "debug_themerm should have 1 boolean arg");
  }
  return 1;
}

// TRANSLATOR: AUTO (nhlua.c:1179)
export function get_table_int_opt(L, name, defval) {
  let ret = defval;
  lua_getfield(L, -1, name);
  if (!lua_isnil(L, -1)) { ret =  luaL_checkinteger(L, -1); }
  lua_pop(L, 1);
  return ret;
}

// TRANSLATOR: AUTO (nhlua.c:1192)
export function get_table_str(L, name) {
  let ret;
  lua_getfield(L, -1, name);
  ret = dupstr(luaL_checkstring(L, -1));
  lua_pop(L, 1);
  return ret;
}

// TRANSLATOR: AUTO (nhlua.c:1229)
export function get_table_boolean(L, name) {
  let boolstr = [ "true", "false", "yes", "no", null ], ltyp, ret = -1;
  lua_getfield(L, -1, name);
  ltyp = lua_type(L, -1);
  if (ltyp === LUA_TSTRING) { ret = luaL_checkoption(L, -1, null, boolstr); }
  else if (ltyp === LUA_TBOOLEAN) { ret = lua_toboolean(L, -1); }
  else if (ltyp === LUA_TNUMBER) { ret =  luaL_checkinteger(L, -1); if (ret < 0 || ret > 1) ret = -1; }
  lua_pop(L, 1);
  if (ret === -1) nhl_error(L, "Expected a boolean");
  return ret;
}

// TRANSLATOR: AUTO (nhlua.c:1257)
export function get_table_boolean_opt(L, name, defval) {
  let ret = defval;
  lua_getfield(L, -1, name);
  if (lua_type(L, -1) !== LUA_TNIL) { lua_pop(L, 1); return get_table_boolean(L, name); }
  lua_pop(L, 1);
  return ret;
}

// TRANSLATOR: AUTO (nhlua.c:1272)
export function get_table_option(L, name, defval, opts) {
  let ret;
  lua_getfield(L, -1, name);
  ret = luaL_checkoption(L, -1, defval, opts);
  lua_pop(L, 1);
  return ret;
}

// TRANSLATOR: AUTO (nhlua.c:1478)
export function save_luadata(nhfp) {
  let lua_data_len, lua_data = get_nh_lua_variables();
  if (!lua_data) lua_data = dupstr(emptystr);
  lua_data_len = Strlen(lua_data) + 1;
  Sfo_unsigned(nhfp, lua_data_len, "luadata-lua_data_len");
  Sfo_char(nhfp, lua_data, "luadata", lua_data_len);
  (lua_data, 0);
}

// TRANSLATOR: AUTO (nhlua.c:1519)
export function nhl_stairways(L) {
  let tmp = gs.stairs, i = 1;
  lua_newtable(L);
  while (tmp) {
    lua_pushinteger(L, i);
    lua_newtable(L);
    nhl_add_table_entry_bool(L, "up", tmp.up);
    nhl_add_table_entry_bool(L, "ladder", tmp.isladder);
    nhl_add_table_entry_int(L, "x", tmp.sx);
    nhl_add_table_entry_int(L, "y", tmp.sy);
    nhl_add_table_entry_int(L, "dnum", tmp.tolev.dnum);
    nhl_add_table_entry_int(L, "dlevel", tmp.tolev.dlevel);
    lua_settable(L, -3);
    tmp = tmp.next;
    i++;
  }
  return 1;
}

// TRANSLATOR: AUTO (nhlua.c:1550)
export function nhl_test(L) {
  let x, y, name, Player = "Player";
  lua_settop(L, 1);
  luaL_checktype(L, 1, LUA_TTABLE);
  x =  get_table_int(L, "x");
  y =  get_table_int(L, "y");
  name = get_table_str_opt(L, "name", Player);
  pline("TEST:{ x=%i, y=%i, name=\"%s\" }",  x,  y, name);
  (name, 0);
  return 1;
}

// TRANSLATOR: AUTO (nhlua.c:1574)
export function nhl_pushkey(L) {
  let argc = lua_gettop(L);
  if (argc === 1) {
    let key = luaL_checkstring(L, 1);
    while ( key) {
      cmdq_add_key(CQ_CANNED, key);
      key++;
    }
  }
  return 0;
}

// TRANSLATOR: AUTO (nhlua.c:1593)
export function nhl_doturn(L, game) {
  let argc = lua_gettop(L), domulti = false;
  if (argc === 1) domulti = lua_toboolean(L, 1);
  do {
    moveloop_core();
  } while (domulti && (game?.multi || 0));
  return 0;
}

// TRANSLATOR: AUTO (nhlua.c:1709)
export function nhl_timer_peek_at(L) {
  let when = 0, timertype = nhl_get_timertype(L, -1), lx, ly, x, y;
  lua_pop(L, 1);
  if (!nhl_get_xy_params(L, lx, ly)) { nhl_error(L, "nhl_timer_peek_at: Wrong args"); return 0; }
  x =  lx;
  y =  ly;
  cvt_to_abscoord( x, y);
  if (timer_is_pos(timertype) && isok(x, y)) when = spot_time_expires(x, y, timertype);
  lua_pushinteger(L, when);
  return 1;
}

// TRANSLATOR: AUTO (nhlua.c:1737)
export function nhl_timer_stop_at(L) {
  let timertype = nhl_get_timertype(L, -1), lx, ly, x, y;
  lua_pop(L, 1);
  if (!nhl_get_xy_params(L, lx, ly)) { nhl_error(L, "nhl_timer_stop_at: Wrong args"); return 0; }
  x =  lx;
  y =  ly;
  cvt_to_abscoord( x, y);
  if (timer_is_pos(timertype) && isok(x, y)) spot_stop_timers(x, y, timertype);
  return 0;
}

// TRANSLATOR: AUTO (nhlua.c:1762)
export function nhl_timer_start_at(L) {
  let timertype = nhl_get_timertype(L, -2), when = lua_tointeger(L, -1);
  let lx, ly, x, y;
  lua_pop(L, 2);
  if (!nhl_get_xy_params(L, lx, ly)) { nhl_error(L, "nhl_timer_start_at: Wrong args"); return 0; }
  x =  lx;
  y =  ly;
  cvt_to_abscoord( x, y);
  if (timer_is_pos(timertype) && isok(x, y)) {
    let where = ( x << 16) |  y;
    spot_stop_timers(x, y, timertype);
    start_timer( when, TIMER_LEVEL, MELT_ICE_AWAY, long_to_any(where));
  }
  return 0;
}

// TRANSLATOR: AUTO (nhlua.c:1987)
export function tutorial(entering) {
  l_nhcore_call(entering ? NHCORE_ENTER_TUTORIAL : NHCORE_LEAVE_TUTORIAL);
  if (!entering) {
    nhcore_call_available[NHCORE_ENTER_TUTORIAL] = nhcore_call_available[NHCORE_LEAVE_TUTORIAL] = false;
  }
}

// TRANSLATOR: AUTO (nhlua.c:2181)
export function nhl_meta_u_newindex(L) {
  nhl_error(L, "Cannot set u table values");
  return 0;
}

// TRANSLATOR: AUTO (nhlua.c:2201)
export function nhl_u_giveobj(L) {
  return nhl_obj_u_giveobj(L);
}

// TRANSLATOR: AUTO (nhlua.c:2242)
export function traceback_handler(L) {
  luaL_traceback(L, L, lua_tostring(L, 1), 0);
  return 1;
}

// TRANSLATOR: AUTO (nhlua.c:2250)
export function nhl_getmeminuse(L) {
  return lua_gc(L, LUA_GCCOUNT) * 1024 + lua_gc(L, LUA_GCCOUNTB);
}

// TRANSLATOR: AUTO (nhlua.c:2758)
export function nhl_clearfromtable(L, flag, tndx, todo) {
  while (todo.when !== EOT) {
    lua_pushnil(L);
    if (todo.when === NEVER || !flag) { lua_setfield(L, tndx, todo.fnname); }
    todo++;
  }
}

// TRANSLATOR: AUTO (nhlua.c:2830)
export function end_luapat() {
  if (luapat) { lua_close(luapat); luapat = null; }
}

// TRANSLATOR: AUTO (nhlua.c:2883)
export function nhl_pushhooked_open_table(L) {
  let hot = lua_getfield(L, LUA_REGISTRYINDEX, HOOKTBLNAME);
  if (hot === LUA_TNONE) {
    lua_newtable(L);
    lua_pushvalue(L, -1);
    lua_setfield(L, LUA_REGISTRYINDEX, HOOKTBLNAME);
  }
}

// TRANSLATOR: AUTO (nhlua.c:811)
export async function nhl_text(L) {
  let argc = lua_gettop(L);
  if (argc > 0) {
    let picks = null, tmpwin;
    tmpwin = create_nhwindow(NHW_MENU);
    start_menu(tmpwin, MENU_BEHAVE_STANDARD);
    while (lua_gettop(L) > 0) {
      let ostr = dupstr(luaL_checkstring(L, 1)), ptr, str = ostr;
      let lstr = str + strlen(str) - 1;
      do {
        let nlp = strchr(str, '\n');
        if (nlp && (nlp - str) <= 76) { ptr = nlp; }
        else { ptr = str + 76; if (ptr > lstr) ptr = lstr; }
        while ((ptr > str) && !( ptr === ' ' || ptr === '\n')) {
          ptr--;
        }
         ptr = '\x00';
        add_menu_str(tmpwin, str);
        str = ptr + 1;
      } while ( str && str <= lstr);
      lua_pop(L, 1);
      (ostr, 0);
    }
    end_menu(tmpwin,  0);
    await select_menu(tmpwin, PICK_NONE, picks);
    destroy_nhwindow(tmpwin);
  }
  return 0;
}
