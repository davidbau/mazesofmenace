// windows.js -- NetHack windowing abstraction layer
// Mirrors src/windows.c + win/tty/wintty.c + win/tty/topl.c

import { nhgetch as defaultNhgetch } from './input.js';

// Window types (wintype.h)
export const NHW_MESSAGE    = 1;
export const NHW_STATUS     = 2;
export const NHW_MAP        = 3;
export const NHW_MENU       = 4;
export const NHW_TEXT       = 5;
export const NHW_PERMINVENT = 6;

// Selection modes (winprocs.h)
export const PICK_NONE = 0;
export const PICK_ONE  = 1;
export const PICK_ANY  = 2;

// Menu behaviours
export const MENU_BEHAVE_STANDARD = 0;
export const MENU_BEHAVE_PERMINV  = 1;

// Text attributes (color.h ATR_*)
export const ATR_NONE      =  0;
export const ATR_ULINE     =  1;
export const ATR_BOLD      =  2;
export const ATR_BLINK     =  4;
export const ATR_INVERSE   =  8;
export const ATR_URGENT    = 16;
export const ATR_NOHISTORY = 32;

// Window ID globals (mirrors decl.c WIN_MESSAGE / WIN_MAP etc.)
export let WIN_MESSAGE, WIN_STATUS, WIN_MAP, WIN_INVEN, BASE_WINDOW;

// --- Internal module state ---
const MAXWIN = 20;
const wins = new Array(MAXWIN).fill(null);

const ttyDisplay = {
    toplin: 0,    // TOPLINE_EMPTY
    inmore: false,
    inread: false,
};

const TOPLINE_EMPTY     = 0;
const TOPLINE_NON_EMPTY = 1;
// const TOPLINE_NEED_MORE = 2;  // reserved for future use

let _display          = null;
let _nhgetch          = defaultNhgetch;
let _rerenderCallback = null;

// WinDesc: mirrors struct WinDesc in win/tty/wintty.h
class WinDesc {
    constructor(type) {
        this.type      = type;
        this.flags     = 0;
        this.active    = false;
        this.mbehavior = MENU_BEHAVE_STANDARD;
        this.data      = [];   // message history or text lines
        this.mlist     = [];   // [{glyphinfo, id, ch, gch, attr, clr, str, itemflags}]
        this.how       = PICK_NONE;
        this.prompt    = '';
    }
}

function allocWin() {
    for (let i = 1; i < MAXWIN; i++) {
        if (!wins[i]) return i;
    }
    throw new Error('nhwindow: out of window slots');
}

// init_nhwindows(display, nhgetch_fn, rerenderFn)
// C ref: tty_init_nhwindows()
export function init_nhwindows(display, nhgetch_fn, rerenderFn) {
    _display          = display;
    if (nhgetch_fn) _nhgetch = nhgetch_fn;
    _rerenderCallback = rerenderFn || null;

    wins.fill(null);
    ttyDisplay.toplin = TOPLINE_EMPTY;
    ttyDisplay.inmore = false;
    ttyDisplay.inread = false;

    WIN_MESSAGE = allocWin();
    wins[WIN_MESSAGE] = new WinDesc(NHW_MESSAGE);
    BASE_WINDOW = WIN_MESSAGE;
}

// create_nhwindow(type) — C ref: tty_create_nhwindow()
export function create_nhwindow(type) {
    const id = allocWin();
    wins[id] = new WinDesc(type);
    return id;
}

// clear_nhwindow(win) — C ref: tty_clear_nhwindow()
export function clear_nhwindow(win) {
    const w = wins[win];
    if (!w) return;
    w.data   = [];
    w.mlist  = [];
    w.how    = PICK_NONE;
    w.prompt = '';
}

// display_nhwindow(win, blocking) — C ref: tty_display_nhwindow()
export async function display_nhwindow(win, blocking) {
    const w = wins[win];
    if (!w) return;
    if (w.type === NHW_MESSAGE && blocking && ttyDisplay.toplin === TOPLINE_NON_EMPTY) {
        if (_display?.putstr_message) _display.putstr_message('--More--');
        await _nhgetch();
        ttyDisplay.toplin = TOPLINE_EMPTY;
    }
}

// destroy_nhwindow(win) — C ref: tty_destroy_nhwindow()
// Frees the window slot; for menu/text windows triggers a game-view rerender.
export function destroy_nhwindow(win) {
    const w = wins[win];
    if (!w) return;
    const type = w.type;
    wins[win] = null;
    if ((type === NHW_MENU || type === NHW_TEXT) && _rerenderCallback) {
        _rerenderCallback();
    }
}

// putstr(win, attr, str) — C ref: tty_putstr()
export function putstr(win, attr, str) {
    const w = wins[win];
    if (!w) return;
    if (w.type === NHW_MESSAGE) {
        if (!(attr & ATR_NOHISTORY)) {
            w.data.push(str);
            if (w.data.length > 20) w.data.shift();
        }
        ttyDisplay.toplin = TOPLINE_NON_EMPTY;
        if (_display?.putstr_message) _display.putstr_message(str);
    } else {
        w.data.push({ attr, str });
    }
}

// start_menu(win, mbehavior) — C ref: tty_start_menu()
export function start_menu(win, mbehavior) {
    const w = wins[win];
    if (!w) return;
    w.mbehavior = mbehavior ?? MENU_BEHAVE_STANDARD;
    w.mlist     = [];
    w.data      = [];
    w.prompt    = '';
}

// add_menu(win, glyphinfo, id, ch, gch, attr, clr, str, itemflags) — C ref: tty_add_menu()
export function add_menu(win, glyphinfo, id, ch, gch, attr, clr, str, itemflags) {
    const w = wins[win];
    if (!w) return;
    w.mlist.push({ glyphinfo, id, ch, gch, attr, clr, str, itemflags });
}

// end_menu(win, prompt) — C ref: tty_end_menu()
// Assigns auto-selector letters (a-z, A-Z) to items that have ch === 0.
export function end_menu(win, prompt) {
    const w = wins[win];
    if (!w) return;
    w.prompt = prompt ?? '';
    let autoChar = 'a'.charCodeAt(0);
    for (const item of w.mlist) {
        if (!item.ch) {
            item.ch = autoChar;
            if (autoChar === 'z'.charCodeAt(0))      autoChar = 'A'.charCodeAt(0);
            else if (autoChar === 'Z'.charCodeAt(0)) autoChar = 0; // exhausted
            else                                      autoChar++;
        }
    }
}

// Build the lines array that will be shown in a menu overlay.
function buildMenuLines(w) {
    const lines = [];
    if (w.prompt) lines.push(w.prompt);
    lines.push('');
    for (const item of w.mlist) {
        const sel = item.ch ? String.fromCharCode(item.ch) + ' - ' : '    ';
        lines.push(sel + item.str);
    }
    return lines;
}

// select_menu(win, how) — C ref: tty_select_menu()
// Returns [{identifier, count}] for selected items, or null for no selection.
export async function select_menu(win, how) {
    const w = wins[win];
    if (!w) return null;
    w.how = how;

    const lines = buildMenuLines(w);
    if (_display) {
        if (typeof _display.renderChargenMenu === 'function') {
            _display.renderChargenMenu(lines, false);
        }
    }

    if (how === PICK_NONE) {
        await _nhgetch();
        return null;
    }

    if (how === PICK_ONE) {
        while (true) {
            const ch = await _nhgetch();
            // ESC, 'q', space, Enter — cancel
            if (ch === 27 || ch === 'q'.charCodeAt(0)
                || ch === ' '.charCodeAt(0) || ch === 13 || ch === 10) {
                return null;
            }
            const item = w.mlist.find(i => i.ch === ch);
            if (item) return [{ identifier: item.id, count: -1 }];
        }
    }

    if (how === PICK_ANY) {
        const selected = new Set();
        while (true) {
            const ch = await _nhgetch();
            if (ch === 13 || ch === 10) {
                // Enter — confirm selection
                const result = [];
                for (const item of w.mlist) {
                    if (item.ch && selected.has(item.ch)) {
                        result.push({ identifier: item.id, count: -1 });
                    }
                }
                return result.length > 0 ? result : null;
            }
            if (ch === 27 || ch === 'q'.charCodeAt(0)) return null;
            if (ch === '.'.charCodeAt(0)) {
                for (const item of w.mlist) if (item.ch) selected.add(item.ch);
            } else if (ch === '-'.charCodeAt(0)) {
                selected.clear();
            } else if (ch === ' '.charCodeAt(0)) {
                // Toggle all
                if (selected.size > 0) selected.clear();
                else for (const item of w.mlist) if (item.ch) selected.add(item.ch);
            } else {
                const item = w.mlist.find(i => i.ch === ch);
                if (item && item.ch) {
                    if (selected.has(item.ch)) selected.delete(item.ch);
                    else selected.add(item.ch);
                }
            }
        }
    }

    return null;
}

// Autotranslated from windows.c:192
export function genl_can_suspend_no() {
  return false;
}

// Autotranslated from windows.c:198
export function genl_can_suspend_yes() {
  return true;
}

// Autotranslated from windows.c:230
export function check_tty_wincap(wincap) {
  let wc = win_choices_find("tty");
  if (wc) return ((wc.procs.wincap & wincap) === wincap);
  return false;
}

// Autotranslated from windows.c:240
export function check_tty_wincap2(wincap2) {
  let wc = win_choices_find("tty");
  if (wc) return ((wc.procs.wincap2 & wincap2) === wincap2);
  return false;
}

// Autotranslated from windows.c:460
export function genl_preference_update(pref) {
  return;
}

// Autotranslated from windows.c:471
export function genl_getmsghistory(init) {
  return  0;
}

// Autotranslated from windows.c:488
export function genl_putmsghistory(msg, is_restoring) {
  if (!is_restoring) pline("%s", msg);
  return;
}

// Autotranslated from windows.c:696
export function hup_create_nhwindow(type) {
  return WIN_ERR;
}

// Autotranslated from windows.c:703
export function hup_select_menu(window, how, menu_list) {
  return -1;
}

// Autotranslated from windows.c:713
export function hup_add_menu(window, glyphinfo, identifier, sel, grpsel, attr, clr, txt, itemflags) {
  return;
}

// Autotranslated from windows.c:729
export function hup_end_menu(window, prompt) {
  return;
}

// Autotranslated from windows.c:736
export function hup_putstr(window, attr, text) {
  return;
}

// Autotranslated from windows.c:743
export function hup_print_glyph(window, x, y, glyphinfo, bkglyphinfo) {
  return;
}

// Autotranslated from windows.c:754
export function hup_outrip(tmpwin, how, when) {
  return;
}

// Autotranslated from windows.c:761
export function hup_curs(window, x, y) {
  return;
}

// Autotranslated from windows.c:768
export function hup_display_nhwindow(window, blocking) {
  return;
}

// Autotranslated from windows.c:775
export function hup_display_file(fname, complain) {
  return;
}

// Autotranslated from windows.c:783
export function hup_cliparound(x, y) {
  return;
}

// Autotranslated from windows.c:815
export function hup_status_update(idx, ptr, chg, pc, color, colormasks) {
  return;
}

// Autotranslated from windows.c:828
export function hup_int_ndecl() {
  return -1;
}

// Autotranslated from windows.c:834
export function hup_void_ndecl() {
  return;
}

// Autotranslated from windows.c:841
export function hup_void_fdecl_int(arg) {
  return;
}

// Autotranslated from windows.c:848
export function hup_void_fdecl_winid(window) {
  return;
}

// Autotranslated from windows.c:855
export function hup_void_fdecl_winid_ulong(window, mbehavior) {
  return;
}

// Autotranslated from windows.c:864
export function hup_void_fdecl_constchar_p(string) {
  return;
}

// Autotranslated from windows.c:871
export function hup_ctrl_nhwindow(window, request, wri) {
  return null;
}

// Autotranslated from windows.c:908
export function genl_status_finish() {
  let i;
  for (i = 0; i < MAXBLSTATS; ++i) {
    if (status_vals) (status_vals[i], 0), status_vals =  0;
  }
}

// Autotranslated from windows.c:921
export function genl_status_enablefield(fieldidx, nm, fmt, enable) {
  status_fieldfmt = fmt;
  status_fieldnm = nm;
  status_activefields = enable;
}

// Autotranslated from windows.c:1243
export function dump_open_log(now) {
  nhUse(now);
}

// Autotranslated from windows.c:1266
export function dump_close_log() {
  if (dumplog_file) { fclose(dumplog_file); dumplog_file = null; }
}

// Autotranslated from windows.c:1275
export function dump_forward_putstr(win, attr, str, no_forward) {
  if (dumplog_file) fprintf(dumplog_file, "%s\n", str);
  if (!no_forward) putstr(win, attr, str);
}

// Autotranslated from windows.c:1285
export function dump_putstr(win, attr, str) {
  if (dumplog_file) fprintf(dumplog_file, "%s\n", str);
}

// Autotranslated from windows.c:1292
export function dump_create_nhwindow(type) {
  return WIN_ERR;
}

// Autotranslated from windows.c:1299
export function dump_clear_nhwindow(win) {
  return;
}

// Autotranslated from windows.c:1306
export function dump_display_nhwindow(win, p) {
  return;
}

// Autotranslated from windows.c:1313
export function dump_destroy_nhwindow(win) {
  return;
}

// Autotranslated from windows.c:1320
export function dump_start_menu(win, mbehavior) {
  return;
}

// Autotranslated from windows.c:1327
export function dump_add_menu(win, glyphinfo, identifier, ch, gch, attr, clr, str, itemflags) {
  if (dumplog_file) {
    if (glyphinfo.glyph === NO_GLYPH) fprintf(dumplog_file, " %s\n", str);
    else {
      fprintf(dumplog_file, " %c - %s\n", ch, str);
    }
  }
}

// Autotranslated from windows.c:1347
export function dump_end_menu(win, str) {
  if (dumplog_file) {
    if (str) fprintf(dumplog_file, "%s\n", str);
    else {
      fputs("\n", dumplog_file);
    }
  }
}

// Autotranslated from windows.c:1358
export function dump_select_menu(win, how, item) {
   item = null;
  return 0;
}

// Autotranslated from windows.c:1409
export function glyph2ttychar(glyph) {
  let glyphinfo;
  map_glyphinfo(0, 0, glyph, 0, glyphinfo);
  return glyphinfo.ttychar;
}

// Autotranslated from windows.c:1418
export function glyph2symidx(glyph, game) {
  let glyphinfo;
  map_glyphinfo(0, 0, glyph, 0, glyphinfo);
  return glyphinfo.game.sym.symidx;
}

// Autotranslated from windows.c:1427
export function encglyph(glyph, game) {
  let encbuf;
  Sprintf(encbuf, "\\G%04X%04X", game.game.svc.context.rndencode, glyph);
  return encbuf;
}

// Autotranslated from windows.c:1438
export function decode_glyph(str, glyph_ptr, game) {
  let rndchk = 0, dcount = 0, retval = 0, dp;
  for ( str && ++dcount <= 4; ++str; ) {
    if ((dp = strchr(hexdd, str)) !== 0) {
      retval++;
      rndchk = (rndchk * 16) + (Math.trunc(dp - hexdd) / 2);
    }
    else {
      break;
    }
  }
  if (rndchk === game.game.svc.context.rndencode) {
     glyph_ptr = dcount = 0;
    for ( str && ++dcount <= 4; ++str; ) {
      if ((dp = strchr(hexdd, str)) !== 0) {
        retval++;
         glyph_ptr = ( glyph_ptr * 16) + (Math.trunc(dp - hexdd) / 2);
      }
      else {
        break;
      }
    }
    return retval;
  }
  return 0;
}

// Autotranslated from windows.c:1527
export function genl_putmixed(window, attr, str) {
  let buf;
  putstr(window, attr, decode_mixed(buf, str));
}
