import { describe, it, beforeEach } from 'node:test';
import assert from 'node:assert/strict';

import {
    createInputQueue,
    setInputRuntime,
    getInputRuntime,
    pushInput,
    nhgetch,
    clearInputQueue,
    ynFunction,
    CMDQ_KEY,
    CMDQ_INT,
    CMDQ_DIR,
    CMDQ_USER_INPUT,
    CQ_CANNED,
    CQ_REPEAT,
    cmdq_add_key,
    cmdq_add_int,
    cmdq_add_dir,
    cmdq_add_userinput,
    cmdq_add_ec,
    cmdq_shift,
    cmdq_reverse,
    cmdq_copy,
    cmdq_pop,
    cmdq_peek,
    cmdq_clear,
} from '../../js/input.js';
import { mapBrowserKeyToNhCode } from '../../js/browser_input.js';

describe('input runtime primitives', () => {
    beforeEach(() => {
        setInputRuntime(createInputQueue());
    });

    it('createInputQueue yields pushed input in order', async () => {
        const runtime = createInputQueue();
        runtime.pushInput('a'.charCodeAt(0));
        runtime.pushInput('b'.charCodeAt(0));
        assert.equal(await runtime.nhgetch(), 'a'.charCodeAt(0));
        assert.equal(await runtime.nhgetch(), 'b'.charCodeAt(0));
    });

    it('module wrappers use active input runtime', async () => {
        const runtime = createInputQueue();
        setInputRuntime(runtime);
        pushInput('x'.charCodeAt(0));
        assert.equal(await nhgetch(), 'x'.charCodeAt(0));
        assert.equal(getInputRuntime(), runtime);
    });

    it('clearInputQueue clears queued input on active runtime', async () => {
        const runtime = createInputQueue();
        setInputRuntime(runtime);
        pushInput('x'.charCodeAt(0));
        clearInputQueue();

        let settled = false;
        const p = nhgetch().then(() => {
            settled = true;
        });
        await new Promise((r) => setTimeout(r, 10));
        assert.equal(settled, false);

        pushInput('y'.charCodeAt(0));
        await p;
    });

    it('ynFunction uses runtime display when explicit display is omitted', async () => {
        const prompts = [];
        const runtime = createInputQueue();
        runtime.getDisplay = () => ({
            putstr_message(msg) {
                prompts.push(msg);
            },
        });
        setInputRuntime(runtime);
        pushInput('y'.charCodeAt(0));

        const result = await ynFunction('Proceed?', 'yn', 'n'.charCodeAt(0));
        assert.equal(result, 'y'.charCodeAt(0));
        assert.equal(prompts.length, 1);
        assert.match(prompts[0], /Proceed\?/);
    });
});

describe('cmdq primitives', () => {
    beforeEach(() => {
        cmdq_clear(CQ_CANNED);
        cmdq_clear(CQ_REPEAT);
    });

    it('queues and pops canned keys in FIFO order', () => {
        cmdq_add_key(CQ_CANNED, 'a'.charCodeAt(0));
        cmdq_add_key(CQ_CANNED, 'b'.charCodeAt(0));
        assert.equal(cmdq_pop(false).key, 'a'.charCodeAt(0));
        assert.equal(cmdq_pop(false).key, 'b'.charCodeAt(0));
        assert.equal(cmdq_pop(false), null);
    });

    it('cmdq_pop uses repeat queue when inDoAgain is true', () => {
        cmdq_add_key(CQ_CANNED, 'c'.charCodeAt(0));
        cmdq_add_key(CQ_REPEAT, 'r'.charCodeAt(0));
        assert.equal(cmdq_pop(true).key, 'r'.charCodeAt(0));
        assert.equal(cmdq_pop(false).key, 'c'.charCodeAt(0));
    });

    it('cmdq_shift moves tail entry to the head', () => {
        cmdq_add_key(CQ_CANNED, 1);
        cmdq_add_key(CQ_CANNED, 2);
        cmdq_add_key(CQ_CANNED, 3);
        cmdq_shift(CQ_CANNED);
        assert.equal(cmdq_pop(false).key, 3);
        assert.equal(cmdq_pop(false).key, 1);
        assert.equal(cmdq_pop(false).key, 2);
    });

    it('cmdq_copy creates independent node chain', () => {
        cmdq_add_key(CQ_CANNED, 1);
        cmdq_add_int(CQ_CANNED, 42);
        cmdq_add_dir(CQ_CANNED, -1, 0, 1);
        cmdq_add_userinput(CQ_CANNED);
        const extcmd = { ef_txt: 'test' };
        cmdq_add_ec(CQ_CANNED, extcmd);

        const copy = cmdq_copy(CQ_CANNED);
        assert.equal(copy.typ, CMDQ_KEY);
        assert.equal(copy.next.typ, CMDQ_INT);
        assert.equal(copy.next.next.typ, CMDQ_DIR);
        assert.equal(copy.next.next.dirx, -1);
        assert.equal(copy.next.next.next.typ, CMDQ_USER_INPUT);
        assert.equal(copy.next.next.next.next.ec_entry, extcmd);

        // Mutate original and verify copy doesn't change.
        const head = cmdq_peek(CQ_CANNED);
        head.key = 99;
        assert.equal(copy.key, 1);
    });

    it('cmdq_reverse reverses linked nodes in-place', () => {
        const n1 = { typ: CMDQ_KEY, key: 1, next: null };
        const n2 = { typ: CMDQ_KEY, key: 2, next: null };
        const n3 = { typ: CMDQ_KEY, key: 3, next: null };
        n1.next = n2;
        n2.next = n3;
        const rev = cmdq_reverse(n1);
        assert.equal(rev.key, 3);
        assert.equal(rev.next.key, 2);
        assert.equal(rev.next.next.key, 1);
        assert.equal(rev.next.next.next, null);
    });
});

describe('browser key mapping', () => {
    it('maps numpad keys when number_pad is enabled', () => {
        const code = mapBrowserKeyToNhCode(
            { key: '8', location: 3, ctrlKey: false, altKey: false, metaKey: false },
            { number_pad: true }
        );
        assert.equal(code, 'k'.charCodeAt(0));
    });

    it('maps numpad keys when number_pad mode is numeric and > 0', () => {
        const code = mapBrowserKeyToNhCode(
            { key: '8', location: 3, ctrlKey: false, altKey: false, metaKey: false },
            { number_pad: 2 }
        );
        assert.equal(code, 'k'.charCodeAt(0));
    });

    it('does not map numpad keys when number_pad mode is 0 or -1', () => {
        const offCode = mapBrowserKeyToNhCode(
            { key: '8', location: 3, ctrlKey: false, altKey: false, metaKey: false },
            { number_pad: 0 }
        );
        const legacyOffCode = mapBrowserKeyToNhCode(
            { key: '8', location: 3, ctrlKey: false, altKey: false, metaKey: false },
            { number_pad: -1 }
        );
        assert.equal(offCode, '8'.charCodeAt(0));
        assert.equal(legacyOffCode, '8'.charCodeAt(0));
    });

    it('maps space to rest only when rest_on_space is enabled', () => {
        const enabled = mapBrowserKeyToNhCode(
            { key: ' ', location: 0, ctrlKey: false, altKey: false, metaKey: false },
            { rest_on_space: true }
        );
        const disabled = mapBrowserKeyToNhCode(
            { key: ' ', location: 0, ctrlKey: false, altKey: false, metaKey: false },
            { rest_on_space: false }
        );
        assert.equal(enabled, '.'.charCodeAt(0));
        assert.equal(disabled, ' '.charCodeAt(0));
    });

    it('maps arrow keys to vi movement', () => {
        const code = mapBrowserKeyToNhCode(
            { key: 'ArrowLeft', location: 0, ctrlKey: false, altKey: false, metaKey: false },
            {}
        );
        assert.equal(code, 'h'.charCodeAt(0));
    });

    it('maps ctrl-letter combinations to C() codes', () => {
        const code = mapBrowserKeyToNhCode(
            { key: 'a', location: 0, ctrlKey: true, altKey: false, metaKey: false },
            {}
        );
        assert.equal(code, 1);
    });

    it('maps alt-letter combinations from physical key code even with composed key values', () => {
        const code = mapBrowserKeyToNhCode(
            { key: 'Ã¬', code: 'KeyL', location: 0, ctrlKey: false, altKey: true, metaKey: false },
            {}
        );
        assert.equal(code, ('l'.charCodeAt(0) | 0x80));
    });
});
