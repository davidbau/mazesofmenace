// test/comparison/comparator_policy.js
// Comparator policies decide how raw recorded JS traces are judged against C.
// Replay/runtime should stay policy-free; add sparse-boundary allowances here.

import {
    compareRng,
    compareScreenLines,
    compareScreenAnsi,
    ansiLineToCells,
    compareEvents,
} from './comparators.js';
import { getSessionScreenAnsiLines } from './session_loader.js';
import { decodeDecSpecialChar } from './symset_normalization.js';

function normalizeGameplayScreenLines(lines) {
    return (Array.isArray(lines) ? lines : [])
        .map((line) => String(line || '').replace(/\r$/, '').replace(/[\x0e\x0f]/g, ''));
}

function ansiCellsToPlainLine(line) {
    return ansiLineToCells(line).map((cell) => cell?.ch || ' ').join('');
}

function decodeSOSILine(line) {
    const src = String(line || '').replace(/\r$/, '');
    let result = '';
    let inDec = false;
    for (let i = 0; i < src.length; i++) {
        const ch = src[i];
        if (ch === '\x0e') { inDec = true; continue; }
        if (ch === '\x0f') { inDec = false; continue; }
        result += inDec ? decodeDecSpecialChar(ch) : ch;
    }
    return result;
}

function resolveGameplayComparableLines(plainLines, ansiLines, session) {
    const ansi = Array.isArray(ansiLines) ? ansiLines : [];
    const decgraphics = session?.meta?.options?.symset === 'DECgraphics';
    if (ansi.length > 0) {
        return ansi.map((line) => ansiCellsToPlainLine(line));
    }
    const plain = Array.isArray(plainLines) ? plainLines : [];
    if (!decgraphics) {
        return plain.map(decodeSOSILine);
    }
    return plain
        .map((line) => String(line || '').replace(/\r$/, '').replace(/[\x0e\x0f]/g, ''))
        .map((line) => [...line].map((ch) => decodeDecSpecialChar(ch)).join(''));
}

function compareGameplayScreens(actualLines, expectedLines, session, {
    actualAnsi = null,
    expectedAnsi = null,
} = {}) {
    const comparableActual = resolveGameplayComparableLines(actualLines, actualAnsi, session).slice();
    const comparableExpected = resolveGameplayComparableLines(expectedLines, expectedAnsi, session).slice();
    for (let row = 0; row < Math.min(comparableActual.length, comparableExpected.length); row++) {
        if (isStartupToplineAlias(comparableActual[row], comparableExpected[row])) {
            comparableActual[row] = '';
            comparableExpected[row] = '';
        }
    }
    const normalizedExpected = normalizeGameplayScreenLines(comparableExpected);
    const normalizedActual = normalizeGameplayScreenLines(comparableActual);
    return compareScreenLines(normalizedActual, normalizedExpected);
}

function approximateStepForRngIndex(session, normalizedIndex) {
    let cumulative = 0;
    const count = (entries) => {
        let n = 0;
        for (const e of entries) {
            if (typeof e !== 'string' || !e.length) continue;
            const c = e[0];
            if (c === '>' || c === '<' || c === '^') continue;
            const stripped = e.replace(/^\d+\s+/, '').replace(/ @ .*/, '');
            if (stripped.startsWith('rne(') || stripped.startsWith('rnz(') || stripped.startsWith('d(')) continue;
            n++;
        }
        return n;
    };
    cumulative += count(session.startup?.rng || []);
    for (let i = 0; i < session.steps.length; i++) {
        cumulative += count(session.steps[i].rng || []);
        if (normalizedIndex < cumulative) return i + 1;
    }
    return 'n/a';
}

function expectedDelayBoundaryCount(step) {
    const entries = Array.isArray(step?.rng) ? step.rng : [];
    let comparable = false;
    let count = 0;
    for (const entry of entries) {
        if (typeof entry !== 'string') continue;
        if (entry.startsWith('^delay_output[')
            || entry.includes('animation(tmp_at)')) {
            comparable = true;
        }
        if (entry.startsWith('>runmode_delay_output') && entry.includes('animation(tmp_at)')) {
            count++;
        }
    }
    return { comparable, count };
}

function isMapLoadPromptAlias(line) {
    const text = String(line || '').replace(/ +$/, '').trimStart();
    return text.startsWith('Load which des lua file?') || text.startsWith('Load which level?');
}

function isHarnessMapDumpLine(line) {
    const text = String(line || '').replace(/ +$/, '').trimStart();
    return /^Map dumped to \/tmp\/[^ ]*dumpmap\.txt\.$/.test(text);
}

function isWelcomeTopline(line) {
    const text = String(line || '').replace(/ +$/, '').trimStart();
    return /^NetHack Royal Jelly -- Welcome to the Mazes of Menace! \[WIZARD MODE\] \(seed:\d+\)$/.test(text);
}

function isStartupToplineAlias(actualLine, expectedLine) {
    return (isHarnessMapDumpLine(actualLine) && isWelcomeTopline(expectedLine))
        || (isHarnessMapDumpLine(expectedLine) && isWelcomeTopline(actualLine));
}

export function createGameplayComparatorPolicy(session, options = {}) {
    const name = options.name || 'strict-default';
    return {
        name,
        compareRng(allJsRng, allSessionRng) {
            const rngCmp = compareRng(allJsRng, allSessionRng);
            if (rngCmp.firstDivergence) {
                rngCmp.firstDivergence.step = approximateStepForRngIndex(
                    session, rngCmp.firstDivergence.index
                );
            }
            return rngCmp;
        },
        compareScreenStep(actualStep, expectedStep) {
            const expectedAnsi = getSessionScreenAnsiLines(expectedStep);
            return compareGameplayScreens(actualStep?.screen || [], expectedStep?.screen || [], session, {
                actualAnsi: actualStep?.screenAnsi,
                expectedAnsi,
            });
        },
        compareColorStep(actualStep, expectedStep) {
            const expectedAnsi = getSessionScreenAnsiLines(expectedStep);
            if (!expectedAnsi.length || !Array.isArray(actualStep?.screenAnsi)) {
                return null;
            }
            const actualAnsi = actualStep.screenAnsi.slice();
            const expectedMasked = expectedAnsi.slice();
            const actualPlain = actualAnsi.map((line) => ansiCellsToPlainLine(line));
            const expectedPlain = expectedMasked.map((line) => ansiCellsToPlainLine(line));
            for (let row = 0; row < Math.min(actualPlain.length, expectedPlain.length); row++) {
                if (isMapLoadPromptAlias(actualPlain[row]) && isMapLoadPromptAlias(expectedPlain[row])) {
                    actualAnsi[row] = '';
                    expectedMasked[row] = '';
                } else if (isStartupToplineAlias(actualPlain[row], expectedPlain[row])) {
                    actualAnsi[row] = '';
                    expectedMasked[row] = '';
                }
            }
            return compareScreenAnsi(actualAnsi, expectedMasked);
        },
        compareEvents(allJsRng, allSessionRng) {
            return compareEvents(allJsRng, allSessionRng);
        },
        compareAnimationBoundariesStep(actualStep, expectedStep) {
            const expected = expectedDelayBoundaryCount(expectedStep);
            if (!expected.comparable) return null;
            const expectedCount = expected.count;
            const actualCount = Array.isArray(actualStep?.animationBoundaries)
                ? actualStep.animationBoundaries.length
                : 0;
            const match = expectedCount === actualCount;
            return {
                matched: match ? 1 : 0,
                total: 1,
                match,
                firstDiff: match ? null : {
                    expectedCount,
                    actualCount,
                },
            };
        },
    };
}
