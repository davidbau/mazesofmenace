<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Play NetHack in your browser - A classic roguelike dungeon crawler adventure. Explore the Mazes of Menace and retrieve the Amulet of Yendor.">
    <meta name="theme-color" content="#f9f7f1">
    <title>NetHack Royal Jelly -- Mazes of Menace</title>
    <link rel="icon" type="image/svg+xml" href="favicon.svg">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=EB+Garamond:ital,wght@0,400;0,500;0,600;0,700;1,400;1,500&display=swap" rel="stylesheet">

    <!-- Open Graph / Social Media -->
    <meta property="og:type" content="website">
    <meta property="og:title" content="NetHack Royal Jelly -- Mazes of Menace">
    <meta property="og:description" content="Play NetHack in your browser - A classic roguelike dungeon crawler adventure.">
    <meta property="og:site_name" content="NetHack JS">
    <style>
        /* ============================================================
           CSS Custom Properties (Design Tokens)
           ============================================================ */
        :root {
            /* Colors - Light Mode */
            --color-bg: #f9f7f1;
            --color-text: #333;
            --color-text-muted: #666;
            --color-text-light: #888;
            --color-accent: #6b2c2c;
            --color-accent-dark: #4a2020;
            --color-border: #2a2a2a;
            --color-terminal-bg: #000;
            --color-terminal-border: #2a2a2a;
            --color-shadow: rgba(0, 0, 0, 0.15);

            /* Spacing */
            --spacing-xs: 0.3em;
            --spacing-sm: 0.5em;
            --spacing-md: 1em;
            --spacing-lg: 1.5em;

            /* Typography */
            --font-mono: "Courier New", "Liberation Mono", monospace;
            --font-serif: 'EB Garamond', Georgia, serif;
            --font-size-sm: 13px;
            --font-size-md: 16px;
            --game-font-size: 16px;

            /* Transitions */
            --transition-fast: 0.2s;
        }

        /* ============================================================
           Base Styles
           ============================================================ */
        html {
            scroll-behavior: smooth;
        }

        /* Respect user's motion preferences */
        @media (prefers-reduced-motion: reduce) {
            html {
                scroll-behavior: auto;
            }

            * {
                animation-duration: 0.01ms !important;
                animation-iteration-count: 1 !important;
                transition-duration: 0.01ms !important;
            }
        }

        body {
            background: var(--color-bg);
            color: var(--color-text);
            font-family: var(--font-serif);
            margin: 0;
            padding: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            transition: background-color var(--transition-fast), color var(--transition-fast);
        }

        /* ============================================================
           Layout
           ============================================================ */
        #page {
            display: flex;
            flex-direction: column;
            align-items: center;
            width: 100%;
        }

        #nav-spacer {
            visibility: hidden;
            pointer-events: none;
            flex-shrink: 0;
            width: 100%;
        }

        /* ============================================================
           Navigation
           ============================================================ */
        #nav {
            display: flex;
            flex-wrap: wrap;
            gap: var(--spacing-lg);
            padding: var(--spacing-sm) 0;
            font-size: calc(var(--game-font-size) * 1.0);
            justify-content: center;
            width: 100%;
            order: -2;  /* Ensure nav appears first */
        }

        #nav a {
            color: var(--color-accent-dark);
            text-decoration: none;
            font-weight: 500;
            transition: color var(--transition-fast);
        }

        #nav a:hover {
            color: var(--color-accent);
            text-decoration: underline;
        }

        #nav a:focus-visible {
            outline: 2px solid var(--color-accent);
            outline-offset: 3px;
            border-radius: 2px;
        }

        /* ============================================================
           Control Buttons
           ============================================================ */
        #controls {
            position: fixed;
            bottom: 20px;
            right: 20px;
            display: flex;
            gap: var(--spacing-sm);
            z-index: 10;
            filter: drop-shadow(0 2px 8px var(--color-shadow));
            order: -1;  /* Ensure controls appear after nav */
        }

        #controls button {
            background: var(--color-bg);
            border: 2px solid var(--color-accent);
            color: var(--color-accent);
            padding: 0.4em 0.8em;
            font-size: calc(var(--game-font-size) * 1.0);
            font-weight: 600;
            cursor: pointer;
            border-radius: 4px;
            transition: all var(--transition-fast);
            font-family: var(--font-serif);
            will-change: transform, background-color, color;
            user-select: none;
            -webkit-user-select: none;
        }

        /* Game glyphs and key labels stay in the game font */
        .mono-char {
            font-family: var(--font-mono);
        }

        #controls button:hover {
            background: var(--color-accent);
            color: #fff;
        }

        #controls button:active {
            transform: scale(0.95);
        }

        @media (prefers-reduced-motion: no-preference) {
            #controls button {
                will-change: transform;
            }
        }

        /* Hamburger button active state */
        #panel-toggle.menu-open {
            background: var(--color-accent);
            color: var(--color-bg);
        }

        /* Hamburger popup menu */
        #hamburger-menu {
            display: none;
            position: absolute;
            bottom: calc(100% + 8px);
            right: 0;
            flex-direction: column;
            background: var(--color-bg);
            border: 2px solid var(--color-accent);
            border-radius: 4px;
            min-width: 200px;
            box-shadow: 0 4px 16px var(--color-shadow);
            z-index: 100;
        }

        #hamburger-menu.open {
            display: flex;
        }

        #hamburger-menu .hm-item {
            background: none;
            border: none;
            border-top: 1px solid var(--color-accent);
            border-radius: 0;
            color: var(--color-accent);
            padding: 0.5em 1em;
            text-align: left;
            cursor: pointer;
            font-family: var(--font-serif);
            font-size: calc(var(--game-font-size) * 1.0);
            white-space: nowrap;
            width: 100%;
            transition: background var(--transition-fast), color var(--transition-fast);
            filter: none;
            user-select: none;
            -webkit-user-select: none;
        }

        #hamburger-menu .hm-item:first-child {
            border-top: none;
        }

        .hm-check {
            display: inline-block;
            width: 1.2em;
        }

        #hamburger-menu .hm-item:hover:not(:disabled) {
            background: var(--color-accent);
            color: #fff;
        }

        #hamburger-menu .hm-item:disabled {
            opacity: 0.35;
            cursor: default;
        }

        .hm-divider {
            border-top: 2px solid var(--color-accent);
            margin: 0;
        }

        /* ============================================================
           Dark Mode Variables
           ============================================================ */
        body.dark-mode {
            --color-bg: #111;
            --color-text: #aaa;
            --color-text-muted: #888;
            --color-text-light: #666;
            --color-accent: #555;
            --color-accent-dark: #888;
            --color-shadow: rgba(0, 0, 0, 0.4);
        }

        /* ============================================================
           Side Panels
           ============================================================ */
        .side-panel {
            color: var(--color-text);
        }

        #hover-panel {
            padding-left: var(--spacing-md);
        }

        #hover-info {
            visibility: hidden;
            background: var(--color-terminal-bg);
            padding: 0.8em;
            border-radius: 4px;
        }

        #hover-info.visible {
            visibility: visible;
        }

        /* Dark mode specific overrides */
        body.dark-mode #controls {
            filter: drop-shadow(0 2px 12px var(--color-shadow));
        }

        body.dark-mode #controls button {
            background: #222;
        }

        body.dark-mode #controls button:hover {
            background: #333;
            border-color: #666;
        }

        body.dark-mode #hamburger-menu {
            background: #222;
        }

        body.dark-mode #hamburger-menu .hm-item {
            background: #222;
            color: #888;
            border-top-color: #444;
        }

        body.dark-mode #hamburger-menu .hm-item:hover:not(:disabled) {
            background: #444;
            color: #ccc;
        }

        body.dark-mode .hm-divider {
            border-top-color: #444;
        }

        body.dark-mode #keyref td:first-child {
            color: #d4d4d4;
        }

        body.dark-mode #keyref .keyref-section td {
            color: #ccc;
        }

        body.dark-mode #hover-info {
            border: 1px solid #444;
        }

        #main {
            display: flex;
            flex-wrap: wrap;
            gap: 0 16px;
            align-items: flex-start;
            width: 100%;
            justify-content: center;
            order: 0;  /* Ensure main appears after nav and controls */
        }

        /* ============================================================
           Game Terminal
           ============================================================ */
        #game {
            /* Terminal container - classic terminal on elegant background */
            background: var(--color-terminal-bg);
            border: 3px solid var(--color-terminal-border);
            padding: 6px;
            box-shadow:
                0 4px 12px var(--color-shadow),
                0 2px 4px rgba(0, 0, 0, 0.1);
            border-radius: 4px;
            flex-shrink: 0;
            /* Pre-size to prevent layout shift when game loads */
            /* Terminal is 80 cols × 24 rows at 16px font, 1.125 line-height, 8px padding */
            /* font-family must match terminal so ch unit is computed correctly */
            font-family: var(--font-mono);
            min-width: calc(80ch + 16px);  /* 80 chars + padding */
            min-height: calc(24 * var(--game-font-size) * 1.125 + 16px);  /* 24 rows × line-height + padding */
            max-width: 100%;
            overflow: auto;
        }

        #terminal {
            /* The pre element is created by display.js */
            /* These styles are set in JS but we provide fallbacks */
            font-family: var(--font-mono);
            font-size: var(--font-size-md);
            line-height: 1.125;
            background: var(--color-terminal-bg);
            color: #fff;
        }

        /* Prevent text selection during gameplay */
        #game * {
            user-select: none;
            -webkit-user-select: none;
        }

        /* Loading message */
        #loading {
            color: var(--color-text-muted);
            font-size: 15px;
            padding: 20px;
            /* Center in the pre-sized container */
            display: grid;
            place-items: center;
            min-height: calc(24 * var(--game-font-size) * 1.125 + 16px - 40px);  /* Match game height minus padding */
            font-weight: 500;
            letter-spacing: 0.02em;
            text-align: center;
            white-space: normal;
        }

        /* Loading animation */
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        @media (prefers-reduced-motion: no-preference) {
            #loading {
                animation: pulse 2s ease-in-out infinite;
            }
        }

        /* Focus indicator */
        #game:focus-within {
            border-color: var(--color-accent);
            box-shadow:
                0 4px 12px var(--color-shadow),
                0 2px 4px rgba(0, 0, 0, 0.1),
                0 0 0 2px rgba(107, 44, 44, 0.2);
        }

        /* --- Side panels --- */
        .side-panel {
            font-size: calc(var(--game-font-size) * 0.875);
            line-height: 1.3;
            width: calc(var(--game-font-size) * 11.25);
            flex-shrink: 0;
            position: relative;
            z-index: 1;
            overflow: hidden;
        }

        .side-panel.hidden {
            display: none;
        }

        /* Hide side panels until gameplay is active */
        body:not(.gameplay-active) .side-panel {
            visibility: hidden;
        }

        /* ============================================================
           Keyboard Reference (Left Panel)
           ============================================================ */
        #keyref {
            padding-right: var(--spacing-md);
            margin-top: calc(var(--game-font-size) * -0.6);
            line-height: 1.22;
        }

        #keyref table {
            border-spacing: 0;
        }

        #keyref td {
            padding: 0 var(--spacing-sm) 0 0;
            white-space: nowrap;
        }

        #keyref td:first-child {
            font-family: var(--font-mono);
            color: #444;
            text-align: right;
            padding-right: 0.8em;
        }

        #keyref .keyref-section td {
            font-family: var(--font-serif);
            color: #555;
            font-size: calc(var(--game-font-size) * 0.75);
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            padding-top: 0.6em;
            text-align: left;
        }

        /* Hover info panel (right panel) - styling set above with dark background */

        #hover-symbol {
            font-family: var(--font-mono);
            font-size: calc(var(--game-font-size) * 1.75);
            line-height: 1;
            display: block;
            margin-bottom: 0.3em;
            color: #fff;  /* Always light on dark background */
        }

        #hover-name {
            color: #ddd;  /* Light on dark background */
            font-size: calc(var(--game-font-size) * 0.875);
            display: block;
            margin-bottom: 0.2em;
        }

        #hover-desc {
            color: #ccc;  /* Light on dark background */
            font-size: calc(var(--game-font-size) * 0.6875);
            display: block;
        }

        #hover-stats {
            color: #aaa;  /* Light on dark background */
            font-size: calc(var(--game-font-size) * 0.625);
            display: block;
            margin-top: 0.3em;
        }

        /* ============================================================
           Documentation Overlay
           Fullscreen iframe for guidebook/spoilers with minimized game
           ============================================================ */
        #docs-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            z-index: 100;
            background: var(--color-bg);
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.4s ease, visibility 0.4s;
        }

        #docs-frame {
            width: 100%;
            height: 100%;
            border: none;
        }

        #docs-close {
            position: fixed;
            top: 10px;
            right: 10px;
            z-index: 101;
            background: var(--color-accent);
            color: #fff;
            border: none;
            width: 36px;
            height: 36px;
            font-size: 20px;
            border-radius: 50%;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 2px 8px var(--color-shadow);
            transition: transform var(--transition-fast), background-color var(--transition-fast);
        }

        #docs-close:hover {
            background: var(--color-accent-dark);
            transform: scale(1.1);
        }

        /* Docs mode: two-phase animation
           Phase 1 (docs-fixed): position fixed at scale(1) — instant
           Phase 2 (docs-mode):  scale down to saved scale — animated
           Position + scale are JS-controlled (drag/resize/persist). */
        body.docs-fixed #page {
            position: fixed;
            z-index: 102;
            pointer-events: auto;
            overflow: hidden;
            transition: transform 0.4s ease, box-shadow 0.4s ease, border-radius 0.4s ease, outline 0.4s ease;
        }

        body.docs-mode #docs-overlay {
            opacity: 1;
            visibility: visible;
        }

        body.docs-mode #page {
            /* position + scale set via inline styles by minimap JS */
            cursor: grab;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.4);
            border-radius: 8px;
            outline: 3px solid var(--color-accent);
        }

        body.docs-mode #page:hover {
            box-shadow: 0 4px 24px rgba(0, 0, 0, 0.6);
            outline-color: var(--color-accent-dark);
        }

        body.docs-mode #nav,
        body.docs-mode #nav-spacer,
        body.docs-mode #controls,
        body.docs-mode .side-panel {
            display: none;
        }

        body.docs-mode #page,
        body.docs-mode #main {
            width: fit-content;
        }

        body.docs-mode.dark-mode #docs-overlay {
            background: #1a1a1a;
        }

        /* ============================================================
           Fullscreen Mode
           Game terminal fills the screen; all chrome hidden
           ============================================================ */
        body.fullscreen-mode {
            background: #000;
            overflow: hidden;
        }

        body.fullscreen-mode #nav,
        body.fullscreen-mode #nav-spacer,
        body.fullscreen-mode #controls,
        body.fullscreen-mode .side-panel {
            display: none;
        }

        body.fullscreen-mode #game {
            padding: 0;
            border: none;
            min-width: 0;
            min-height: 0;
        }

        /* ============================================================
           Responsive Design - Tablet & Below (< 1100px)
           Stack panels vertically, hide panel toggle, adjust controls
           ============================================================ */
        @media (max-width: 1100px) {
            #main {
                flex-direction: column;
                align-items: center;
            }

            #main {
                /* Reorder: game first, then panels below */
            }

            #keyref {
                width: auto;
                max-width: 780px;
                order: 1;
            }

            #hover-panel {
                width: auto;
                max-width: 780px;
                order: 2;
                padding-top: 0.5em;
            }

            #game {
                order: 0;
            }

            #keyref table {
                display: flex;
                flex-wrap: wrap;
                gap: 0 2em;
            }

            #keyref tr {
                display: flex;
            }

            /* On narrow screens, hide panel toggle (panels are below anyway) */
            #panel-toggle {
                display: none;
            }

            /* Adjust control position for narrow screens */
            #controls {
                bottom: 10px;
                right: 10px;
                gap: 0.4em;
            }

            #controls button {
                padding: 0.3em 0.6em;
                font-size: 13px;
            }
        }

        /* ============================================================
           Responsive Design - Mobile (< 600px)
           Compact navigation, reduced spacing, smaller controls
           ============================================================ */
        @media (max-width: 600px) {
            #nav {
                font-size: calc(var(--game-font-size) * 0.75);
                gap: 1em;
                padding: 0.75em 0.5em;
            }

            #page {
                padding: 0 0.5em;
            }

            #controls {
                bottom: 8px;
                right: 8px;
            }
        }

        /* ============================================================
           Confirmation Dialog
           ============================================================ */
        #confirm-modal {
            display: none;
            position: fixed;
            inset: 0;
            z-index: 200;
            background: rgba(0, 0, 0, 0.35);
            align-items: center;
            justify-content: center;
        }

        #confirm-modal.open {
            display: flex;
        }

        #confirm-box {
            background: var(--color-bg);
            border: 2px solid var(--color-accent);
            border-radius: 4px;
            padding: 1.2em 1.5em;
            font-family: var(--font-serif);
            color: var(--color-accent);
            box-shadow: 0 4px 16px var(--color-shadow);
            max-width: 280px;
        }

        #confirm-msg {
            margin: 0 0 1em 0;
            font-size: calc(var(--game-font-size) * 1.1);
        }

        #confirm-buttons {
            display: flex;
            gap: var(--spacing-sm);
            justify-content: flex-end;
        }

        #confirm-buttons button {
            background: var(--color-bg);
            border: 2px solid var(--color-accent);
            color: var(--color-accent);
            padding: 0.3em 0.9em;
            font-family: var(--font-serif);
            font-size: calc(var(--game-font-size) * 1.0);
            font-weight: 600;
            cursor: pointer;
            border-radius: 4px;
            transition: all var(--transition-fast);
        }

        #confirm-buttons button:hover {
            background: var(--color-accent);
            color: #fff;
        }

        body.dark-mode #confirm-box {
            background: #1a1a1a;
            color: #bbb;
            border-color: #666;
        }

        body.dark-mode #confirm-msg {
            color: #bbb;
        }

        body.dark-mode #confirm-buttons button {
            background: #1a1a1a;
            color: #bbb;
            border-color: #666;
        }

        body.dark-mode #confirm-buttons button:hover {
            background: #444;
            color: #eee;
            border-color: #888;
        }

    </style>
</head>
<body>
    <div id="page">
        <nav id="nav" role="navigation" aria-label="Main navigation">
            <a href="guidebook/" tabindex="-1">How to Play NetHack</a>
            <a href="spoilers/" tabindex="-1">Spoilers</a>
            <a href="README.html" tabindex="-1">About This Project</a>
        </nav>
        <div id="controls">
            <button id="font-smaller" title="Decrease font size" aria-label="Decrease font size" tabindex="-1"><span class="mono-char">A</span>−</button>
            <button id="font-larger" title="Increase font size" aria-label="Increase font size" tabindex="-1"><span class="mono-char">A</span>+</button>
            <button id="panel-toggle" title="Game menu" aria-label="Open game menu" tabindex="-1">☰</button>
            <div id="hamburger-menu">
                <button class="hm-item" id="hm-save-quit"><span class="hm-check"></span>Save &amp; quit</button>
                <button class="hm-item" id="hm-new-game"><span class="hm-check"></span>New game</button>
                <div class="hm-divider"></div>
                <button class="hm-item" id="hm-del-bones"><span class="hm-check"></span>Delete bones</button>
                <button class="hm-item" id="hm-reset-opts"><span class="hm-check"></span>Reset options</button>
                <div class="hm-divider"></div>
                <button class="hm-item" id="hm-fullscreen"><span class="hm-check"></span>Fullscreen</button>
                <button class="hm-item" id="hm-darkmode"><span class="hm-check"></span>Dark mode</button>
                <button class="hm-item" id="hm-keyref"><span class="hm-check"></span>Control help</button>
            </div>
        </div>
        <main id="main" role="main">
            <!-- Left: keyboard controls -->
            <aside id="keyref" class="side-panel" role="complementary" aria-label="Keyboard reference">
                <table>
                    <tr class="keyref-section"><td colspan="2">Move</td></tr>
                    <tr><td>h j k l</td><td>left/down/up/right</td></tr>
                    <tr><td>y u b n</td><td>diagonals</td></tr>
                    <tr><td>.</td><td>wait one turn</td></tr>
                    <tr><td>s</td><td>search adjacent</td></tr>
                    <tr><td>&lt; &gt;</td><td>go up/down stairs</td></tr>
                    <tr class="keyref-section"><td colspan="2">Actions</td></tr>
                    <tr><td>o</td><td>open door</td></tr>
                    <tr><td>c</td><td>close door</td></tr>
                    <tr><td>,</td><td>pick up item</td></tr>
                    <tr><td>d</td><td>drop item</td></tr>
                    <tr><td>e</td><td>eat</td></tr>
                    <tr><td>q</td><td>quaff (drink)</td></tr>
                    <tr><td>r</td><td>read scroll</td></tr>
                    <tr><td>z</td><td>zap wand</td></tr>
                    <tr class="keyref-section"><td colspan="2">Equipment</td></tr>
                    <tr><td>w</td><td>wield weapon</td></tr>
                    <tr><td>W</td><td>wear armor</td></tr>
                    <tr><td>P</td><td>put on ring</td></tr>
                    <tr><td>T</td><td>take off armor</td></tr>
                    <tr><td>R</td><td>remove ring</td></tr>
                    <tr class="keyref-section"><td colspan="2">Info</td></tr>
                    <tr><td>i</td><td>inventory</td></tr>
                    <tr><td>/</td><td>identify symbol</td></tr>
                    <tr><td>:</td><td>look here</td></tr>
                    <tr><td>?</td><td>help</td></tr>

                </table>
            </aside>

            <!-- Center: game terminal -->
            <div id="game" role="application" aria-label="NetHack game terminal">
                <div id="loading" role="status" aria-live="polite">Loading NetHack JS...</div>
            </div>

            <!-- Right: hover symbol info -->
            <aside id="hover-panel" class="side-panel" role="complementary" aria-label="Symbol information">
                <div id="hover-info">
                    <span id="hover-symbol"></span>
                    <span id="hover-name"></span>
                    <span id="hover-desc"></span>
                    <span id="hover-stats"></span>
                </div>
            </aside>
        </main>
        <!-- Phantom spacer that mirrors #nav height so body centering aligns
             the game (not the nav+game block) with the viewport midpoint. -->
        <div id="nav-spacer" aria-hidden="true"></div>
    </div>

    <!-- Documentation iframe overlay (hidden by default) -->
    <div id="docs-overlay">
        <iframe id="docs-frame" title="Documentation"></iframe>
        <button id="docs-close" title="Return to game" aria-label="Close documentation">✕</button>
    </div>

    <script>
    /* ============================================================
       Welcome Message & Keyboard Shortcuts Hint
       ============================================================ */
    (function() {
        // Performance mark for page ready
        if (window.performance && performance.mark) {
            performance.mark('ui-ready');
        }

        console.log('%cNetHack Royal Jelly - Mazes of Menace', 'font-size: 18px; font-weight: bold; color: #6b2c2c;');
        console.log('%cHave fun exploring the dungeons!', 'color: #4a2020; font-style: italic;');
    })();

    /* ============================================================
       Side Panel Toggle Management
       Controls visibility of left (keyref) and right (hover) panels
       State persists via localStorage
       ============================================================ */
    (function() {
        var keyrefPanel = document.getElementById('keyref');
        var hoverPanel = document.getElementById('hover-panel');
        var panelToggle = document.getElementById('panel-toggle');
        var gameDiv = document.getElementById('game');
        var autoHidden = false;

        // helppanel values: 'both' | 'control' (LHS only) | 'objects' (RHS only) | 'none'
        function getHelppanel() {
            try {
                var opts = JSON.parse(localStorage.getItem('menace-options')) || {};
                if ('helppanel' in opts) return String(opts.helppanel) || 'both';
                // Legacy fallback: old key stored presence when hidden
                return localStorage.getItem('menace-panels-hidden') ? 'none' : 'both';
            } catch(e) { return 'both'; }
        }
        function setHelppanel(val) {
            try {
                var opts = JSON.parse(localStorage.getItem('menace-options')) || {};
                opts.helppanel = val;
                localStorage.setItem('menace-options', JSON.stringify(opts));
            } catch(e) {}
        }

        // Apply panel visibility: autoHidden overrides mode and hides everything
        function applyPanels() {
            var mode = autoHidden ? 'none' : getHelppanel();
            keyrefPanel.classList.toggle('hidden', mode !== 'both' && mode !== 'control');
            hoverPanel.classList.toggle('hidden',  mode !== 'both' && mode !== 'objects');
        }

        function updateToggleButton() {
            var mode = getHelppanel();
            if (autoHidden) {
                panelToggle.classList.add('panels-auto-hidden');
                panelToggle.classList.remove('panels-hidden');
            } else if (mode === 'none') {
                panelToggle.classList.remove('panels-auto-hidden');
                panelToggle.classList.add('panels-hidden');
            } else {
                panelToggle.classList.remove('panels-auto-hidden');
                panelToggle.classList.remove('panels-hidden');
            }
        }

        /**
         * Check whether side panels fit alongside the game terminal.
         * Auto-hides panels when viewport is too narrow, respects helppanel mode.
         */
        function checkPanelFit() {
            var mode = getHelppanel();

            // 'none' mode: panels intentionally hidden, no auto-hide logic needed
            if (mode === 'none') return;

            // Only auto-hide on wide screens where panels are side-by-side
            if (window.innerWidth < 1100) {
                if (autoHidden) { autoHidden = false; applyPanels(); updateToggleButton(); }
                return;
            }

            // Compute game terminal's minimum occupied width (content + padding + border)
            var gs = getComputedStyle(gameDiv);
            var gameNeeded = (parseFloat(gs.minWidth) || 0)
                + (parseFloat(gs.paddingLeft) || 0) + (parseFloat(gs.paddingRight) || 0)
                + (parseFloat(gs.borderLeftWidth) || 0) + (parseFloat(gs.borderRightWidth) || 0);

            // Side panels scale with --game-font-size; compute from CSS variable
            var fontSize = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--game-font-size')) || 16;
            var panelWidth = fontSize * 11.25; // matches calc(var(--game-font-size) * 11.25)
            var panelPadding = fontSize; // 1em padding per panel
            var panelCount = (mode === 'both') ? 2 : 1;
            var totalNeeded = gameNeeded + (panelWidth + panelPadding) * panelCount + 16 * panelCount;

            // Use clientWidth (excludes scrollbar) for accurate available layout space
            var availableWidth = document.documentElement.clientWidth;

            if (totalNeeded > availableWidth) {
                if (!autoHidden) { autoHidden = true;  applyPanels(); updateToggleButton(); }
            } else {
                if (autoHidden)  { autoHidden = false; applyPanels(); updateToggleButton(); }
            }
        }

        // Menu toggle: flip between 'none' and 'both' only
        function togglePanels() {
            if (autoHidden) return;
            setHelppanel(getHelppanel() === 'none' ? 'both' : 'none');
            applyPanels();
            updateToggleButton();
        }

        // Restore user preference
        applyPanels();

        // Re-evaluate on viewport resize
        window.addEventListener('resize', checkPanelFit);

        // Re-evaluate when game terminal resizes (e.g. font-size changes ch units)
        if (window.ResizeObserver) {
            new ResizeObserver(checkPanelFit).observe(gameDiv);
        }

        checkPanelFit();
        updateToggleButton();

        // Expose so font-size controls can trigger a re-check
        window._checkPanelFit = checkPanelFit;

        // Expose for hamburger menu
        window._panelFns = {
            toggle: togglePanels,
            isAutoHidden: function() { return autoHidden; },
        };
    })();

    /* ============================================================
       Theme Toggle and Font Size Controls
       Manages dark/light mode switching and terminal font sizing
       Preferences persist via localStorage with error handling
       ============================================================ */
    (function() {
        const fontSmaller = document.getElementById('font-smaller');
        const fontLarger = document.getElementById('font-larger');
        const gameDiv = document.getElementById('game');

        // Load saved color scheme: 'dark', 'light', or 'system' (follow OS preference)
        function getColorScheme() {
            try {
                var opts = JSON.parse(localStorage.getItem('menace-options')) || {};
                if ('darkmode' in opts) return String(opts.darkmode) || 'system';
                // Legacy fallback: menace-theme key
                var legacy = localStorage.getItem('menace-theme');
                return legacy === 'dark' ? 'dark' : legacy === 'light' ? 'light' : 'system';
            } catch(e) { return 'system'; }
        }
        function applyColorScheme(scheme) {
            var prefersDark = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;
            document.body.classList.toggle('dark-mode',
                scheme === 'dark' || (scheme === 'system' && prefersDark));
        }
        applyColorScheme(getColorScheme());
        // Reapply when OS preference changes (only relevant in 'system' mode)
        if (window.matchMedia) {
            window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', function() {
                if (getColorScheme() === 'system') applyColorScheme('system');
            });
        }

        // Load and apply saved font size
        let savedFontSize = '16';
        try {
            savedFontSize = localStorage.getItem('menace-font-size') || '16';
        } catch(e) {}

        /**
         * Apply font size to game container and terminal
         * @param {string|number} size - Font size in pixels
         */
        function applyFontSize(size) {
            // Update CSS custom property for nav/controls scaling
            document.documentElement.style.setProperty('--game-font-size', size + 'px');

            // Apply to game div - will cascade to terminal when it's created
            gameDiv.style.fontSize = size + 'px';

            // Also apply directly to terminal if it already exists
            const terminal = document.getElementById('terminal');
            if (terminal) {
                terminal.style.fontSize = size + 'px';
            }

            // Re-check panel fit synchronously: getComputedStyle returns updated ch-based
            // min-width immediately after fontSize is set, so panels are shown/hidden
            // correctly on the first paint (avoids a one-frame layout shift via RAF).
            if (window._checkPanelFit) window._checkPanelFit();
        }

        applyFontSize(savedFontSize);

        // Expose for hamburger menu and fullscreen
        window._applyFontSize = applyFontSize;

        // Menu toggle: flip between explicit 'light' and 'dark' (ignores 'system' once clicked)
        window._toggleDarkMode = function() {
            var isDark = document.body.classList.contains('dark-mode');
            var next = isDark ? 'light' : 'dark';
            applyColorScheme(next);
            try {
                var opts = JSON.parse(localStorage.getItem('menace-options')) || {};
                opts.darkmode = next;
                localStorage.setItem('menace-options', JSON.stringify(opts));
            } catch(e) {}
        };

        // Font size controls
        fontSmaller.addEventListener('click', function() {
            let size = 16;
            try {
                size = parseInt(localStorage.getItem('menace-font-size')) || 16;
            } catch(e) {}
            size = Math.max(12, size - 2);
            applyFontSize(size);
            try {
                localStorage.setItem('menace-font-size', size);
            } catch(e) {}
            this.blur();
        });

        fontLarger.addEventListener('click', function() {
            let size = 16;
            try {
                size = parseInt(localStorage.getItem('menace-font-size')) || 16;
            } catch(e) {}
            size = Math.min(24, size + 2);
            applyFontSize(size);
            try {
                localStorage.setItem('menace-font-size', size);
            } catch(e) {}
            this.blur();
        });
    })();

    /* ============================================================
       Nav Spacer — keeps game vertically centered in viewport
       A phantom div at the bottom of #page mirrors #nav height so
       body's align-items:center aligns the game, not the nav+game.
       ============================================================ */
    (function() {
        var navEl  = document.getElementById('nav');
        var spacer = document.getElementById('nav-spacer');
        if (!navEl || !spacer) return;
        function syncSpacer() { spacer.style.height = navEl.offsetHeight + 'px'; }
        syncSpacer();
        if (window.ResizeObserver) new ResizeObserver(syncSpacer).observe(navEl);
        window.addEventListener('resize', syncSpacer);
    })();

    /* ============================================================
       Fullscreen Mode
       Fills viewport with 80×24 terminal at optimal font size.
       ============================================================ */
    (function() {
        var preFontSize = null;  // font size before entering fullscreen

        // Compute largest integer font size where 80 cols and 24 rows fit
        function computeFullscreenFontSize() {
            var vw = window.innerWidth, vh = window.innerHeight;
            // Measure character width for the game font at a reference size
            var ref = 100;
            var testEl = document.createElement('span');
            testEl.style.cssText = 'position:fixed;visibility:hidden;' +
                'font-family:"Courier New","Liberation Mono",monospace;' +
                'font-size:' + ref + 'px;line-height:1;';
            testEl.textContent = '0';
            document.body.appendChild(testEl);
            var chWidth = testEl.offsetWidth;
            document.body.removeChild(testEl);
            var fromW = Math.floor(vw * ref / (80 * chWidth));
            var fromH = Math.floor(vh / (24 * 1.125));
            return Math.max(8, Math.min(fromW, fromH));
        }

        function enterFullscreen() {
            try { preFontSize = parseInt(localStorage.getItem('menace-font-size')) || 16; } catch(e) {}
            var el = document.documentElement;
            var req = el.requestFullscreen || el.webkitRequestFullscreen || el.mozRequestFullScreen;
            if (req) req.call(el).catch(function(err) { console.warn('Fullscreen failed:', err); });
        }

        function exitFullscreen() {
            var exit = document.exitFullscreen || document.webkitExitFullscreen || document.mozCancelFullScreen;
            if (exit) exit.call(document).catch(function() {});
        }

        function onFullscreenChange() {
            var fsEl = document.fullscreenElement || document.webkitFullscreenElement
                    || document.mozFullScreenElement;
            if (fsEl) {
                document.body.classList.add('fullscreen-mode');
                if (window._applyFontSize) window._applyFontSize(computeFullscreenFontSize());
            } else {
                document.body.classList.remove('fullscreen-mode');
                if (window._applyFontSize && preFontSize) window._applyFontSize(preFontSize);
                preFontSize = null;
            }
            if (window._checkPanelFit) window._checkPanelFit();
        }
        document.addEventListener('fullscreenchange',       onFullscreenChange);
        document.addEventListener('webkitfullscreenchange', onFullscreenChange);
        document.addEventListener('mozfullscreenchange',    onFullscreenChange);

        // Refit on resize while fullscreen (e.g. rotation)
        window.addEventListener('resize', function() {
            if (document.body.classList.contains('fullscreen-mode') && window._applyFontSize) {
                window._applyFontSize(computeFullscreenFontSize());
            }
        });

        window._toggleFullscreen = function() {
            var fsEl = document.fullscreenElement || document.webkitFullscreenElement
                    || document.mozFullScreenElement;
            if (fsEl) exitFullscreen(); else enterFullscreen();
        };
    })();

    /* ============================================================
       Hamburger Menu
       Popup menu attached to the ☰ button with game options
       ============================================================ */
    (function() {
        var panelToggle = document.getElementById('panel-toggle');
        var menu = document.getElementById('hamburger-menu');
        var menuBackdrop = null;  // transparent overlay to catch outside clicks
        function showConfirm(msg) {
            var confirmModal = document.getElementById('confirm-modal');
            return new Promise(function(resolve) {
                document.getElementById('confirm-msg').textContent = msg;
                confirmModal.classList.add('open');
                function done(result) {
                    confirmModal.classList.remove('open');
                    btnYes.removeEventListener('click', onYes);
                    btnNo.removeEventListener('click', onNo);
                    resolve(result);
                }
                function onYes() { done(true); }
                function onNo()  { done(false); }
                var btnYes = document.getElementById('confirm-yes');
                var btnNo  = document.getElementById('confirm-no');
                btnYes.addEventListener('click', onYes);
                btnNo.addEventListener('click', onNo);
            });
        }

        // Close confirm on Escape
        document.addEventListener('keydown', function(e) {
            var cm = document.getElementById('confirm-modal');
            if (e.key === 'Escape' && cm && cm.classList.contains('open')) {
                cm.classList.remove('open');
            }
        });

        function isOpen() { return menu.classList.contains('open'); }

        function openMenu() {
            // Block during docs-mode transition
            if (document.body.classList.contains('docs-fixed')) return;

            // Enable/disable game-state items
            var inGame = document.body.classList.contains('gameplay-active');
            document.getElementById('hm-save-quit').disabled = !inGame;
            document.getElementById('hm-new-game').disabled = false;

            // Checkmark toggles
            var isDark = document.body.classList.contains('dark-mode');
            document.querySelector('#hm-darkmode .hm-check').textContent = isDark ? '✓' : '';

            var isFs = !!(document.fullscreenElement || document.webkitFullscreenElement
                       || document.mozFullScreenElement);
            document.querySelector('#hm-fullscreen .hm-check').textContent = isFs ? '✓' : '';

            var keyref = document.getElementById('keyref');
            var keyrefVisible = keyref && !keyref.classList.contains('hidden');
            document.querySelector('#hm-keyref .hm-check').textContent = keyrefVisible ? '✓' : '';

            // Grayed-out state for data-dependent items
            var hasOptions = false;
            try { hasOptions = !!localStorage.getItem('menace-options'); } catch(e) {}
            document.getElementById('hm-reset-opts').disabled = !hasOptions;

            var hasBones = false;
            try {
                for (var i = 0; i < localStorage.length; i++) {
                    if (localStorage.key(i).startsWith('menace-bones-')) { hasBones = true; break; }
                }
            } catch(e) {}
            document.getElementById('hm-del-bones').disabled = !hasBones;

            // Backdrop captures outside clicks to dismiss
            if (!menuBackdrop) {
                menuBackdrop = document.createElement('div');
                // z-index:9 = below #controls (z-index:10, its own stacking context),
                // so menu buttons are clickable; above regular content for outside-click capture
                menuBackdrop.style.cssText = 'position:fixed;inset:0;z-index:9;';
                menuBackdrop.addEventListener('mousedown', closeMenu);
                document.body.appendChild(menuBackdrop);
            }
            menu.classList.add('open');
            panelToggle.classList.add('menu-open');
        }

        function closeMenu() {
            if (menuBackdrop) {
                document.body.removeChild(menuBackdrop);
                menuBackdrop = null;
            }
            menu.classList.remove('open');
            panelToggle.classList.remove('menu-open');
        }

        // Toggle menu on hamburger click; Ctrl/Cmd+click saves keylog
        panelToggle.addEventListener('click', function(e) {
            if (e.ctrlKey || e.metaKey) {
                e.preventDefault();
                e.stopPropagation();
                if (window.save_keylog) window.save_keylog();
                return;
            }
            if (isOpen()) closeMenu(); else openMenu();
            this.blur();
        });

        // Close on Escape (backdrop handles outside clicks)
        document.addEventListener('keydown', function(e) {
            if (e.key === 'Escape' && isOpen()) closeMenu();
        });

        // Also close if font button clicked while menu open
        document.getElementById('font-smaller').addEventListener('mousedown', closeMenu);
        document.getElementById('font-larger').addEventListener('mousedown', closeMenu);

        // Menu actions
        document.getElementById('hm-save-quit').addEventListener('click', function() {
            if (this.disabled) return;
            closeMenu();
            if (window._saveAndQuit) window._saveAndQuit();
        });

        document.getElementById('hm-new-game').addEventListener('click', async function() {
            closeMenu();
            var inGame = document.body.classList.contains('gameplay-active');
            if (inGame) {
                var ok = await showConfirm('Quit the current game without saving?');
                if (!ok) return;
            }
            if (window._newGame) window._newGame();
        });

        document.getElementById('hm-keyref').addEventListener('click', function() {
            if (window._panelFns) window._panelFns.toggle();
            closeMenu();
        });

        document.getElementById('hm-fullscreen').addEventListener('click', function() {
            closeMenu();
            if (window._toggleFullscreen) window._toggleFullscreen();
        });

        document.getElementById('hm-darkmode').addEventListener('click', function() {
            if (window._toggleDarkMode) window._toggleDarkMode();
            closeMenu();
        });

        document.getElementById('hm-reset-opts').addEventListener('click', function() {
            if (this.disabled) return;
            try { localStorage.removeItem('menace-options'); } catch(e) {}
            // Remove legacy keys now superseded by menace-options
            try { localStorage.removeItem('menace-theme'); } catch(e) {}
            try { localStorage.removeItem('menace-panels-hidden'); } catch(e) {}
            closeMenu();
        });

        document.getElementById('hm-del-bones').addEventListener('click', function() {
            if (this.disabled) return;
            try {
                var keys = [];
                for (var i = 0; i < localStorage.length; i++) {
                    if (localStorage.key(i).startsWith('menace-bones-')) keys.push(localStorage.key(i));
                }
                keys.forEach(function(k) { localStorage.removeItem(k); });
            } catch(e) {}
            closeMenu();
        });
    })();

    /* ============================================================
       Hover Info Background Management
       Shows/hides black background when hover info becomes visible
       Uses MutationObserver for efficient style change detection
       ============================================================ */
    (function() {
        const hoverInfo = document.getElementById('hover-info');
        if (!hoverInfo) return;

        // Use MutationObserver to watch for visibility changes
        const observer = new MutationObserver(function(mutations) {
            mutations.forEach(function(mutation) {
                if (mutation.type === 'attributes' && mutation.attributeName === 'style') {
                    const isVisible = hoverInfo.style.visibility === 'visible' ||
                                    window.getComputedStyle(hoverInfo).visibility === 'visible';
                    if (isVisible) {
                        hoverInfo.classList.add('visible');
                    } else {
                        hoverInfo.classList.remove('visible');
                    }
                }
            });
        });

        observer.observe(hoverInfo, {
            attributes: true,
            attributeFilter: ['style']
        });
    })();

    /* ============================================================
       Terminal Creation Observer
       Watches for terminal element creation and applies saved font size
       Disconnects after successful application for performance
       ============================================================ */
    (function() {
        const gameDiv = document.getElementById('game');
        let savedFontSize = null;
        try {
            savedFontSize = localStorage.getItem('menace-font-size');
        } catch(e) {}
        if (!savedFontSize || !gameDiv) return;

        const observer = new MutationObserver(function(mutations) {
            const terminal = document.getElementById('terminal');
            if (terminal && !terminal.dataset.fontApplied) {
                terminal.style.fontSize = savedFontSize + 'px';
                terminal.dataset.fontApplied = 'true';
                observer.disconnect();
            }
        });

        observer.observe(gameDiv, {
            childList: true,
            subtree: true
        });
    })();


    /* ============================================================
       Game Focus Management & Load Timeout
       Automatically focus game when terminal loads
       Show error message if game fails to load within timeout
       ============================================================ */
    (function() {
        const gameDiv = document.getElementById('game');
        const loadingDiv = document.getElementById('loading');
        if (!gameDiv) return;

        let gameLoaded = false;

        // Watch for terminal creation and focus it
        const observer = new MutationObserver(function(mutations) {
            const terminal = document.getElementById('terminal');
            if (terminal) {
                gameLoaded = true;

                // Performance mark for game load
                if (window.performance && performance.mark) {
                    performance.mark('game-loaded');
                    try {
                        performance.measure('game-load-time', 'ui-ready', 'game-loaded');
                        const measure = performance.getEntriesByName('game-load-time')[0];
                        console.log('%cGame loaded in ' + Math.round(measure.duration) + 'ms', 'color: #4a2020;');
                    } catch(e) {}
                }

                // Small delay to ensure game is ready
                setTimeout(function() {
                    terminal.focus();
                }, 100);
                observer.disconnect();
            }
        });

        observer.observe(gameDiv, {
            childList: true,
            subtree: true
        });

        // Timeout: show error if game doesn't load within 30 seconds
        setTimeout(function() {
            if (!gameLoaded && loadingDiv) {
                loadingDiv.innerHTML = 'Failed to load NetHack. Please refresh the page.<br><small style="margin-top: 0.5em; display: block;">Check the browser console for error details.</small>';
                loadingDiv.style.color = '#c33';
                console.error('NetHack failed to load within timeout period');
            }
        }, 30000);
    })();

    /* ============================================================
       Documentation Overlay Mode
       Shows guidebook/spoilers in iframe while minimizing game
       Uses History API to update URL for bookmarkability
       ============================================================ */
    (function() {
        const docsOverlay = document.getElementById('docs-overlay');
        const docsFrame = document.getElementById('docs-frame');
        const docsClose = document.getElementById('docs-close');
        const page = document.getElementById('page');
        const nav = document.getElementById('nav');

        if (!docsOverlay || !docsFrame || !docsClose || !nav) return;

        // Map of hash keys to iframe sources
        const docsRoutes = {
            'guidebook': 'guidebook/',
            'spoilers': 'spoilers/',
            'readme': 'README.html'
        };

        var ignoreHashChange = false;

        // ── Minimap drag / resize / persist ──────────────────────────────────
        // The minimap (#page scaled down) is draggable from the interior and
        // resizable by dragging any border edge.  Position is persisted as an
        // offset from the nearest horizontal/vertical edge-or-center so it
        // stays anchored correctly when the window is resized.

        var MM_OPTS_KEY = 'menace-options';
        var MM_EDGE = 8;     // px hit-zone for resize border
        var MM_MIN  = 0.15;  // minimum scale
        var MM_MAX  = 0.90;  // maximum scale
        var MM_SNAP = 15;    // px snap zone for center/middle alignment
        var MM_DEFAULT_SCALE = 0.50;

        // Classify minimap position into nearest anchor (same logic as mmSave)
        function computeAnchor(left, top, w, h) {
            var vw = window.innerWidth, vh = window.innerHeight;
            var cx = left + w / 2, cy = top + h / 2;
            var dL = left, dR = vw - left - w, dCH = Math.abs(cx - vw / 2);
            var dT = top,  dB = vh - top  - h, dCV = Math.abs(cy - vh / 2);
            return {
                hSide: (dL <= dR && dL <= dCH) ? 'l' : (dR <= dL && dR <= dCH) ? 'r' : 'c',
                vSide: (dT <= dB && dT <= dCV) ? 't' : (dB <= dT && dB <= dCV) ? 'b' : 'm',
            };
        }

        var mmState   = null;   // null = idle; object while dragging/resizing
        var mmDidMove = false;  // suppress click-to-close after drag
        var mmOverlay = null;   // transparent capture div during drag

        // Parse compact minimap string, e.g. "r17b10s47", "c0m0s50", "l".
        // Tokens: l|r|c[n]  t|b|m[n]  s[n]  (any order, all optional).
        // Defaults: r10, b10, s50; c and m default offset to 0.
        function mmParse(str) {
            var h = 'r', hOff = 10, v = 'b', vOff = 10, scale = MM_DEFAULT_SCALE;
            var re = /([lrcbtms])([+-]?\d+)?/g, m;
            while ((m = re.exec(str || '')) !== null) {
                var n = m[2] !== undefined ? parseInt(m[2], 10) : null;
                if      (m[1] === 'l') { h = 'l'; hOff = n !== null ? n : 10; }
                else if (m[1] === 'r') { h = 'r'; hOff = n !== null ? n : 10; }
                else if (m[1] === 'c') { h = 'c'; hOff = n !== null ? n : 0;  }
                else if (m[1] === 't') { v = 't'; vOff = n !== null ? n : 10; }
                else if (m[1] === 'b') { v = 'b'; vOff = n !== null ? n : 10; }
                else if (m[1] === 'm') { v = 'm'; vOff = n !== null ? n : 0;  }
                else if (m[1] === 's') { scale = (n !== null ? n : 50) / 100; }
            }
            return { hSide: h, hOff: hOff, vSide: v, vOff: vOff, scale: scale };
        }

        // Read minimap string from menace-options (returns '' if absent)
        function mmLoad() {
            try { return (JSON.parse(localStorage.getItem(MM_OPTS_KEY)) || {}).minimap || ''; }
            catch(e) { return ''; }
        }

        // Persist position as compact string into menace-options
        function mmSave(left, top, scale) {
            var vw = window.innerWidth, vh = window.innerHeight;
            var nw = page.scrollWidth, nh = page.scrollHeight;
            var w = nw * scale, h = nh * scale;
            var anch = computeAnchor(left, top, w, h);
            var hOff = anch.hSide === 'l' ? left :
                       anch.hSide === 'r' ? vw - left - w :
                                            (left + w / 2) - vw / 2;
            var vOff = anch.vSide === 't' ? top :
                       anch.vSide === 'b' ? vh - top - h :
                                            (top + h / 2) - vh / 2;
            var str = anch.hSide + Math.round(hOff) +
                      anch.vSide + Math.round(vOff) +
                      's' + Math.round(scale * 100);
            try {
                var opts = JSON.parse(localStorage.getItem(MM_OPTS_KEY)) || {};
                opts.minimap = str;
                localStorage.setItem(MM_OPTS_KEY, JSON.stringify(opts));
            } catch(e) {}
        }

        // Compute { left, top, scale } from saved anchor (or default bottom-right)
        function mmRestore() {
            var d = mmParse(mmLoad());
            var nw = page.scrollWidth, nh = page.scrollHeight;
            var vw = window.innerWidth, vh = window.innerHeight;
            var w = nw * d.scale, h = nh * d.scale;
            var left, top;
            if      (d.hSide === 'l') left = d.hOff;
            else if (d.hSide === 'r') left = vw - w - d.hOff;
            else                      left = vw / 2 + d.hOff - w / 2;
            if      (d.vSide === 't') top = d.vOff;
            else if (d.vSide === 'b') top = vh - h - d.vOff;
            else                      top = vh / 2 + d.vOff - h / 2;
            // Clamp so minimap is never fully off-screen
            left = Math.max(-(w * 0.8), Math.min(vw - w * 0.2, left));
            top  = Math.max(-(h * 0.8), Math.min(vh - h * 0.2, top));
            return { left: left, top: top, scale: d.scale };
        }

        // Apply { left, top, scale } as inline styles (instant=true suppresses transition)
        function mmApply(pos, instant) {
            if (instant) { page.style.transition = 'none'; page.offsetHeight; }
            page.style.left           = pos.left + 'px';
            page.style.top            = pos.top  + 'px';
            page.style.right          = 'auto';
            page.style.bottom         = 'auto';
            page.style.transformOrigin = 'top left';
            page.style.transform      = 'scale(' + pos.scale + ')';
            if (instant) { page.offsetHeight; page.style.transition = ''; }
        }

        // Update cursor based on mouse position over the minimap
        function mmUpdateCursor(e) {
            if (mmState) return;
            var rect = page.getBoundingClientRect();
            var x = e.clientX - rect.left, y = e.clientY - rect.top;
            var w = rect.width, h = rect.height;
            var L = x < MM_EDGE, R = x > w - MM_EDGE;
            var T = y < MM_EDGE, B = y > h - MM_EDGE;
            if      (L && T) page.style.cursor = 'nw-resize';
            else if (R && T) page.style.cursor = 'ne-resize';
            else if (L && B) page.style.cursor = 'sw-resize';
            else if (R && B) page.style.cursor = 'se-resize';
            else if (L)      page.style.cursor = 'w-resize';
            else if (R)      page.style.cursor = 'e-resize';
            else if (T)      page.style.cursor = 'n-resize';
            else if (B)      page.style.cursor = 's-resize';
            else             page.style.cursor = 'grab';
        }

        page.addEventListener('mousemove', function(e) {
            if (document.body.classList.contains('docs-mode')) mmUpdateCursor(e);
        });

        page.addEventListener('mousedown', function(e) {
            if (!document.body.classList.contains('docs-mode')) return;
            e.preventDefault();

            var rect  = page.getBoundingClientRect();
            var x = e.clientX - rect.left, y = e.clientY - rect.top;
            var w = rect.width, h = rect.height;
            var L = x < MM_EDGE, R = x > w - MM_EDGE;
            var T = y < MM_EDGE, B = y > h - MM_EDGE;
            var onEdge = L || R || T || B;
            var scale = page.scrollWidth ? w / page.scrollWidth : MM_DEFAULT_SCALE;

            mmState = {
                mode:   onEdge ? 'resize' : 'drag',
                edges:  { L: L, R: R, T: T, B: B },
                mx0: e.clientX, my0: e.clientY,
                left0: rect.left, top0: rect.top,
                w0: w, h0: h, scale0: scale,
                nw: page.scrollWidth, nh: page.scrollHeight,
                anchor: computeAnchor(rect.left, rect.top, w, h),
            };
            mmDidMove = false;

            // Overlay captures mouse events even when over the iframe
            var cur = onEdge ? page.style.cursor : 'grabbing';
            mmOverlay = document.createElement('div');
            mmOverlay.style.cssText = 'position:fixed;inset:0;z-index:9999;cursor:' + cur;
            document.body.appendChild(mmOverlay);

            page.style.transition = 'none';  // no easing during drag
        });

        document.addEventListener('mousemove', function(e) {
            if (!mmState) return;
            var dx = e.clientX - mmState.mx0, dy = e.clientY - mmState.my0;
            if (Math.abs(dx) > 2 || Math.abs(dy) > 2) mmDidMove = true;

            if (mmState.mode === 'drag') {
                var rawLeft = mmState.left0 + dx, rawTop = mmState.top0 + dy;
                var vw = window.innerWidth, vh = window.innerHeight;
                var w = mmState.scale0 * mmState.nw, h = mmState.scale0 * mmState.nh;
                // Snap to horizontal center and vertical middle within MM_SNAP pixels
                var snapLeft = Math.abs(rawLeft - (vw - w) / 2) < MM_SNAP
                    ? (vw - w) / 2 : rawLeft;
                var snapTop  = Math.abs(rawTop  - (vh - h) / 2) < MM_SNAP
                    ? (vh - h) / 2 : rawTop;
                page.style.left = snapLeft + 'px';
                page.style.top  = snapTop  + 'px';
            } else {
                // Resize: scale from dragged edge(s), position pinned to anchor
                var e_ = mmState.edges;
                var scale = mmState.scale0;

                // Determine scale from whichever edges are being dragged
                if (e_.R || e_.L) {
                    var sh = e_.R ? (mmState.w0 + dx) / mmState.nw
                                  : (mmState.w0 - dx) / mmState.nw;
                    scale = sh;
                }
                if (e_.B || e_.T) {
                    var sv = e_.B ? (mmState.h0 + dy) / mmState.nh
                                  : (mmState.h0 - dy) / mmState.nh;
                    scale = (e_.R || e_.L) ? (scale + sv) / 2 : sv;
                }
                scale = Math.max(MM_MIN, Math.min(MM_MAX, scale));

                // Position: pin the anchor side (the side/center nearest the viewport edge)
                var anch = mmState.anchor;
                var left = anch.hSide === 'r' ? mmState.left0 + mmState.w0 - scale * mmState.nw :
                           anch.hSide === 'c' ? mmState.left0 + mmState.w0 / 2 - scale * mmState.nw / 2 :
                                                mmState.left0;  // 'l': left edge pinned
                var top  = anch.vSide === 'b' ? mmState.top0 + mmState.h0 - scale * mmState.nh :
                           anch.vSide === 'm' ? mmState.top0 + mmState.h0 / 2 - scale * mmState.nh / 2 :
                                                mmState.top0;   // 't': top edge pinned

                page.style.left      = left  + 'px';
                page.style.top       = top   + 'px';
                page.style.transform = 'scale(' + scale + ')';
            }
        });

        document.addEventListener('mouseup', function() {
            if (!mmState) return;
            page.style.transition = '';   // restore CSS transition
            if (mmOverlay) { document.body.removeChild(mmOverlay); mmOverlay = null; }

            if (!mmDidMove) {
                // Quick click (no drag) — restore full game
                mmState = null;
                closeDocs(true);
                return;
            }

            var bcrW  = page.getBoundingClientRect().width;
            var scale = page.scrollWidth ? bcrW / page.scrollWidth : MM_DEFAULT_SCALE;
            mmSave(parseFloat(page.style.left) || 0, parseFloat(page.style.top) || 0, scale);
            mmState = null;
        });

        // Reposition minimap when viewport is resized
        window.addEventListener('resize', function() {
            if (document.body.classList.contains('docs-mode')) mmApply(mmRestore(), true);
        });

        // ── end minimap ───────────────────────────────────────────────────────

        function openDocs(src, hash, animate) {
            docsFrame.src = src;

            if (animate) {
                // Capture the game terminal's rect BEFORE any layout changes.
                // We use #game (not #page) because #page is width:100% in normal
                // flow but width:fit-content in docs-mode — different left edges.
                var gameEl = document.getElementById('game');
                var fromRect = (gameEl || page).getBoundingClientRect();

                // Apply docs-mode + minimap position instantly (no transition yet).
                // mmRestore() needs docs-mode active for correct page.scrollWidth.
                document.body.classList.add('docs-fixed');
                document.body.classList.add('docs-mode');
                var target = mmRestore();
                mmApply(target, true);   // sets left/top/scale with transition:none

                // FLIP invert: translate+scale so the element visually appears
                // to still be at fromRect (the game's natural position).
                var nw = page.scrollWidth;
                var dx = fromRect.left - target.left;
                var dy = fromRect.top  - target.top;
                var si = nw > 0 ? fromRect.width / nw : 1;

                page.style.transition = 'none';
                page.style.transform  =
                    'translate(' + dx + 'px,' + dy + 'px) scale(' + si + ')';
                page.offsetHeight;   // commit FLIP invert with no transition

                // Remove invert — CSS transition animates from fromRect to target.
                // No cleanup needed: final state is scale(target.scale) at left/top.
                page.style.transition = '';
                page.style.transform  = 'scale(' + target.scale + ')';
            } else {
                document.body.classList.add('docs-fixed');
                document.body.classList.add('docs-mode');
                // mmRestore() called AFTER docs-mode so page.scrollWidth is content width
                mmApply(mmRestore(), true);
            }
            if (window.location.hash !== '#' + hash) {
                ignoreHashChange = true;
                window.location.hash = '#' + hash;
            }
        }

        function mmClearStyles() {
            page.style.left = page.style.top = page.style.right = page.style.bottom = '';
            page.style.transform = page.style.transformOrigin = page.style.transition = '';
            page.style.cursor = '';
        }

        function closeDocs(animate) {
            if (animate) {
                // FLIP animation: zoom game back to its normal position
                var first = page.getBoundingClientRect();

                document.body.classList.remove('docs-mode');
                document.body.classList.remove('docs-fixed');
                mmClearStyles();  // clear inline minimap styles before measuring natural pos
                var last = page.getBoundingClientRect();

                // Hide surrounding UI during zoom — they'll fade in after
                var extras = page.querySelectorAll('#nav, #controls, .side-panel');
                extras.forEach(function(el) {
                    el.style.opacity = '0';
                    el.style.pointerEvents = 'none';
                    el.style.transition = 'none';
                });

                // Invert: apply transform so it still looks miniaturized
                var dx = first.left - last.left;
                var dy = first.top - last.top;
                var sx = first.width / last.width;
                var sy = first.height / last.height;
                page.style.transformOrigin = '0 0';
                page.style.transform = 'translate(' + dx + 'px,' + dy + 'px) scale(' + sx + ',' + sy + ')';

                page.offsetHeight; // force reflow

                page.style.transition = 'transform 0.4s ease';
                page.style.transform = '';

                function cleanup() {
                    page.removeEventListener('transitionend', cleanup);
                    page.style.transition = '';
                    page.style.transformOrigin = '';
                    page.style.transform = '';
                    extras.forEach(function(el) {
                        el.style.pointerEvents = '';
                        el.style.transition = 'opacity 0.3s ease';
                        el.style.opacity = '';
                    });
                    setTimeout(function() {
                        extras.forEach(function(el) {
                            el.style.transition = '';
                            el.style.opacity = '';
                        });
                    }, 350);
                }
                page.addEventListener('transitionend', cleanup);
                setTimeout(cleanup, 500);
            } else {
                document.body.classList.remove('docs-mode');
                document.body.classList.remove('docs-fixed');
                mmClearStyles();
            }

            docsFrame.src = 'about:blank';
            if (window.location.hash) {
                history.replaceState(null, '', window.location.pathname + window.location.search);
            }
        }

        // Intercept nav link clicks (let modified clicks open in new tab)
        nav.addEventListener('click', function(e) {
            if (e.ctrlKey || e.metaKey || e.shiftKey || e.altKey) return;
            const link = e.target.closest('a');
            if (!link) return;

            const href = link.getAttribute('href');
            if (href.startsWith('guidebook')) {
                e.preventDefault();
                e.stopPropagation();
                openDocs('guidebook/', 'guidebook', true);
            } else if (href.startsWith('spoilers')) {
                e.preventDefault();
                e.stopPropagation();
                openDocs('spoilers/', 'spoilers', true);
            } else if (href.startsWith('README')) {
                e.preventDefault();
                e.stopPropagation();
                openDocs('README.html', 'readme', true);
            }
        });

        // Close button
        docsClose.addEventListener('click', function() {
            closeDocs(true);
            this.blur();
        });

        // Escape key to close docs
        document.addEventListener('keydown', function(e) {
            if (e.key === 'Escape' && document.body.classList.contains('docs-mode')) {
                closeDocs(true);
            }
        });

        // Handle browser back/forward via hash changes
        window.addEventListener('hashchange', function() {
            if (ignoreHashChange) { ignoreHashChange = false; return; }
            var hash = window.location.hash.replace('#', '');
            var src = docsRoutes[hash];
            if (src) {
                // Open or switch docs content
                if (!document.body.classList.contains('docs-mode')) {
                    openDocs(src, hash, false);
                } else {
                    docsFrame.src = src;
                }
            } else {
                if (document.body.classList.contains('docs-mode')) {
                    closeDocs(false);
                }
            }
        });

        // Check if we should open docs based on initial hash
        var initialHash = window.location.hash.replace('#', '');
        var initialSrc = docsRoutes[initialHash];
        if (initialSrc) {
            openDocs(initialSrc, initialHash, false);
        }
    })();
    </script>

    <!-- Confirmation dialog -->
    <div id="confirm-modal">
        <div id="confirm-box">
            <p id="confirm-msg"></p>
            <div id="confirm-buttons">
                <button id="confirm-no">No</button>
                <button id="confirm-yes">Yes</button>
            </div>
        </div>
    </div>

    <!-- ES6 Module entry point -->
    <script type="module" src="js/nethack.js"></script>

    <!-- Fallback for browsers without module support -->
    <noscript>
        <p>NetHack JS requires JavaScript to be enabled.</p>
    </noscript>
</body>
</html>
